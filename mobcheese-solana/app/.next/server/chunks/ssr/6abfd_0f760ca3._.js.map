{"version":3,"sources":["../../../../../../mobcheese-solana/app/node_modules/file-uri-to-path/index.js","../../../../../../mobcheese-solana/app/node_modules/bindings/bindings.js","../../../../../../mobcheese-solana/app/node_modules/bigint-buffer/dist/node.js","../../../../../../mobcheese-solana/app/node_modules/bignumber.js/bignumber.mjs","../../../../../../mobcheese-solana/app/node_modules/%40solana/buffer-layout-utils/lib/esm/base.mjs","../../../../../../mobcheese-solana/app/node_modules/%40solana/buffer-layout-utils/lib/esm/bigint.mjs","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token-metadata/src/field.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/transferFee/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/burnChecked.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/mintToChecked.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/approveChecked.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/burn.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/amountToUiAmount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/transferChecked.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/mintTo.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/approve.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/transfer.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/errors.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/scaledUiAmount/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/metadataPointer/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/pausable/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/tokenMetadata/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/groupMemberPointer/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/tokenGroup/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/transferFee/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/memoTransfer/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/buffer-layout-utils/src/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/cpiGuard/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/groupPointer/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/defaultAccountState/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/interestBearingMint/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/transferHook/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/state/index.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/cpiGuard/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/memoTransfer/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/state/mint.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/state/multisig.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/internal.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/buffer-layout-utils/src/base.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/internal.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/interestBearingMint/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/initializeMint.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/interestBearingMint/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/extensionType.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/pausable/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/state/account.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/metadataPointer/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/scaledUiAmount/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/serialization.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/groupPointer/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/permanentDelegate.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/initializeMint2.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/scaledUiAmount/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/groupMemberPointer/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/buffer-layout-utils/src/web3.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/metadataPointer/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/transferFee/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/initializeMultisig.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/pausable/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/mintCloseAuthority.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/initializeAccount2.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/initializeAccount3.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/groupMemberPointer/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/groupPointer/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/initializePermanentDelegate.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/accountType.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/buffer-layout-utils/lib/esm/native.mjs","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/transferHook/pubkeyData.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token-group/src/state/tokenGroup.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token-metadata/src/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/associatedTokenAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/burn.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/getOrCreateAssociatedTokenAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/defaultAccountState/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/cpiGuard/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/memoTransfer/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/reallocate.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/createAssociatedTokenAccountIdempotent.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/transfer.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/setAuthority.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/closeAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/mintToChecked.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/freezeAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/createMint.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/transferChecked.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/decode.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/createWrappedNativeAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/createAssociatedTokenAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/createNativeMint.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/transferHook/instructions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/initializeImmutableOwner.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/buffer-layout-utils/lib/esm/web3.mjs","../../../../../../mobcheese-solana/app/node_modules/%40solana/buffer-layout-utils/lib/esm/decimal.mjs","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/tokenMetadata/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/nonTransferable.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/transferHook/actions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/tokenGroup/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/uiAmountToAmount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/defaultAccountState/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/createMultisig.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token-group/src/instruction.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/assertions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token-metadata/src/instruction.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/types.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/amountToUiAmount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/tokenMetadata/actions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token-group/src/state/tokenGroupMember.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-strings/src/assertions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/initializeNonTransferableMint.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/interestBearingMint/actions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/bytes.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/options/src/option.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/immutableOwner.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/initializeAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/closeAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/initializeMintCloseAuthority.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/thawAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/transferHook/state.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/transferHook/seeds.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/errors/src/codes.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/createNativeMint.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-strings/src/baseX.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/syncNative.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/uiAmountToAmount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/syncNative.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/setAuthority.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/defaultAccountState/actions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/utils.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/options/src/unwrap-option.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/pausable/actions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/revoke.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/cpiGuard/actions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/memoTransfer/actions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/revoke.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/recoverNested.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/thawAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/common.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/burnChecked.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/createAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/approve.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/instructions/freezeAccount.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/scaledUiAmount/actions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/options/src/option-codec.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/tokenGroup/actions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/extensions/transferFee/actions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/approveChecked.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/spl-token/src/actions/mintTo.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/utils.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/array.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/codec.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/f32.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/f64.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/combine-codec.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-strings/src/base10.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/i128.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-strings/src/base16.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/options/src/unwrap-option-recursively.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/bit-array.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/add-codec-sentinel.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/i16.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/i32.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/i64.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-strings/src/base58.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-strings/src/baseX-reslice.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/boolean.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/i8.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/bytes.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/short-u16.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/assertions.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-strings/src/base64.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/constant.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/add-codec-size-prefix.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/u128.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-strings/src/null-characters.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/tuple.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/text-encoding-impl/src/index.node.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-strings/src/utf8.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/errors/src/context.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/u16.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/fix-codec-size.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/u32.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/union.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/errors/src/messages.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/u64.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-numbers/src/u8.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/offset-codec.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/resize-codec.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/discriminated-union.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/pad-codec.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/enum-helpers.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/reverse-codec.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/enum.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-core/src/transform-codec.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/hidden-prefix.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/errors/src/message-formatter.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/hidden-suffix.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/map.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/unit.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/nullable.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/errors/src/error.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/errors/src/stack-trace.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/errors/src/rpc-enum-errors.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/set.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/codecs-data-structures/src/struct.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/errors/src/instruction-error.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/errors/src/transaction-error.ts","../../../../../../mobcheese-solana/app/node_modules/%40solana/errors/src/json-rpc-error.ts"],"sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar sep = require('path').sep || '/';\n\n/**\n * Module exports.\n */\n\nmodule.exports = fileUriToPath;\n\n/**\n * File URI to Path function.\n *\n * @param {String} uri\n * @return {String} path\n * @api public\n */\n\nfunction fileUriToPath (uri) {\n  if ('string' != typeof uri ||\n      uri.length <= 7 ||\n      'file://' != uri.substring(0, 7)) {\n    throw new TypeError('must pass in a file:// URI to convert to a file path');\n  }\n\n  var rest = decodeURI(uri.substring(7));\n  var firstSlash = rest.indexOf('/');\n  var host = rest.substring(0, firstSlash);\n  var path = rest.substring(firstSlash + 1);\n\n  // 2.  Scheme Definition\n  // As a special case, <host> can be the string \"localhost\" or the empty\n  // string; this is interpreted as \"the machine from which the URL is\n  // being interpreted\".\n  if ('localhost' == host) host = '';\n\n  if (host) {\n    host = sep + sep + host;\n  }\n\n  // 3.2  Drives, drive letters, mount points, file system root\n  // Drive letters are mapped into the top of a file URI in various ways,\n  // depending on the implementation; some applications substitute\n  // vertical bar (\"|\") for the colon after the drive letter, yielding\n  // \"file:///c|/tmp/test.txt\".  In some cases, the colon is left\n  // unchanged, as in \"file:///c:/tmp/test.txt\".  In other cases, the\n  // colon is simply omitted, as in \"file:///c/tmp/test.txt\".\n  path = path.replace(/^(.+)\\|/, '$1:');\n\n  // for Windows, we need to invert the path separators from what a URI uses\n  if (sep == '\\\\') {\n    path = path.replace(/\\//g, '\\\\');\n  }\n\n  if (/^.+\\:/.test(path)) {\n    // has Windows drive at beginning of path\n  } else {\n    // unix path…\n    path = sep + path;\n  }\n\n  return host + path;\n}\n","/**\n * Module dependencies.\n */\n\nvar fs = require('fs'),\n  path = require('path'),\n  fileURLToPath = require('file-uri-to-path'),\n  join = path.join,\n  dirname = path.dirname,\n  exists =\n    (fs.accessSync &&\n      function(path) {\n        try {\n          fs.accessSync(path);\n        } catch (e) {\n          return false;\n        }\n        return true;\n      }) ||\n    fs.existsSync ||\n    path.existsSync,\n  defaults = {\n    arrow: process.env.NODE_BINDINGS_ARROW || ' → ',\n    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled',\n    platform: process.platform,\n    arch: process.arch,\n    nodePreGyp:\n      'node-v' +\n      process.versions.modules +\n      '-' +\n      process.platform +\n      '-' +\n      process.arch,\n    version: process.versions.node,\n    bindings: 'bindings.node',\n    try: [\n      // node-gyp's linked version in the \"build\" dir\n      ['module_root', 'build', 'bindings'],\n      // node-waf and gyp_addon (a.k.a node-gyp)\n      ['module_root', 'build', 'Debug', 'bindings'],\n      ['module_root', 'build', 'Release', 'bindings'],\n      // Debug files, for development (legacy behavior, remove for node v0.9)\n      ['module_root', 'out', 'Debug', 'bindings'],\n      ['module_root', 'Debug', 'bindings'],\n      // Release files, but manually compiled (legacy behavior, remove for node v0.9)\n      ['module_root', 'out', 'Release', 'bindings'],\n      ['module_root', 'Release', 'bindings'],\n      // Legacy from node-waf, node <= 0.4.x\n      ['module_root', 'build', 'default', 'bindings'],\n      // Production \"Release\" buildtype binary (meh...)\n      ['module_root', 'compiled', 'version', 'platform', 'arch', 'bindings'],\n      // node-qbs builds\n      ['module_root', 'addon-build', 'release', 'install-root', 'bindings'],\n      ['module_root', 'addon-build', 'debug', 'install-root', 'bindings'],\n      ['module_root', 'addon-build', 'default', 'install-root', 'bindings'],\n      // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}\n      ['module_root', 'lib', 'binding', 'nodePreGyp', 'bindings']\n    ]\n  };\n\n/**\n * The main `bindings()` function loads the compiled bindings for a given module.\n * It uses V8's Error API to determine the parent filename that this function is\n * being invoked from, which is then used to find the root directory.\n */\n\nfunction bindings(opts) {\n  // Argument surgery\n  if (typeof opts == 'string') {\n    opts = { bindings: opts };\n  } else if (!opts) {\n    opts = {};\n  }\n\n  // maps `defaults` onto `opts` object\n  Object.keys(defaults).map(function(i) {\n    if (!(i in opts)) opts[i] = defaults[i];\n  });\n\n  // Get the module root\n  if (!opts.module_root) {\n    opts.module_root = exports.getRoot(exports.getFileName());\n  }\n\n  // Ensure the given bindings name ends with .node\n  if (path.extname(opts.bindings) != '.node') {\n    opts.bindings += '.node';\n  }\n\n  // https://github.com/webpack/webpack/issues/4175#issuecomment-342931035\n  var requireFunc =\n    typeof __webpack_require__ === 'function'\n      ? __non_webpack_require__\n      : require;\n\n  var tries = [],\n    i = 0,\n    l = opts.try.length,\n    n,\n    b,\n    err;\n\n  for (; i < l; i++) {\n    n = join.apply(\n      null,\n      opts.try[i].map(function(p) {\n        return opts[p] || p;\n      })\n    );\n    tries.push(n);\n    try {\n      b = opts.path ? requireFunc.resolve(n) : requireFunc(n);\n      if (!opts.path) {\n        b.path = n;\n      }\n      return b;\n    } catch (e) {\n      if (e.code !== 'MODULE_NOT_FOUND' &&\n          e.code !== 'QUALIFIED_PATH_RESOLUTION_FAILED' &&\n          !/not find/i.test(e.message)) {\n        throw e;\n      }\n    }\n  }\n\n  err = new Error(\n    'Could not locate the bindings file. Tried:\\n' +\n      tries\n        .map(function(a) {\n          return opts.arrow + a;\n        })\n        .join('\\n')\n  );\n  err.tries = tries;\n  throw err;\n}\nmodule.exports = exports = bindings;\n\n/**\n * Gets the filename of the JavaScript file that invokes this function.\n * Used to help find the root directory of a module.\n * Optionally accepts an filename argument to skip when searching for the invoking filename\n */\n\nexports.getFileName = function getFileName(calling_file) {\n  var origPST = Error.prepareStackTrace,\n    origSTL = Error.stackTraceLimit,\n    dummy = {},\n    fileName;\n\n  Error.stackTraceLimit = 10;\n\n  Error.prepareStackTrace = function(e, st) {\n    for (var i = 0, l = st.length; i < l; i++) {\n      fileName = st[i].getFileName();\n      if (fileName !== __filename) {\n        if (calling_file) {\n          if (fileName !== calling_file) {\n            return;\n          }\n        } else {\n          return;\n        }\n      }\n    }\n  };\n\n  // run the 'prepareStackTrace' function above\n  Error.captureStackTrace(dummy);\n  dummy.stack;\n\n  // cleanup\n  Error.prepareStackTrace = origPST;\n  Error.stackTraceLimit = origSTL;\n\n  // handle filename that starts with \"file://\"\n  var fileSchema = 'file://';\n  if (fileName.indexOf(fileSchema) === 0) {\n    fileName = fileURLToPath(fileName);\n  }\n\n  return fileName;\n};\n\n/**\n * Gets the root directory of a module, given an arbitrary filename\n * somewhere in the module tree. The \"root directory\" is the directory\n * containing the `package.json` file.\n *\n *   In:  /home/nate/node-native-module/lib/index.js\n *   Out: /home/nate/node-native-module\n */\n\nexports.getRoot = function getRoot(file) {\n  var dir = dirname(file),\n    prev;\n  while (true) {\n    if (dir === '.') {\n      // Avoids an infinite loop in rare cases, like the REPL\n      dir = process.cwd();\n    }\n    if (\n      exists(join(dir, 'package.json')) ||\n      exists(join(dir, 'node_modules'))\n    ) {\n      // Found the 'package.json' file or 'node_modules' dir; we're done\n      return dir;\n    }\n    if (prev === dir) {\n      // Got to the top\n      throw new Error(\n        'Could not find module root given file: \"' +\n          file +\n          '\". Do you have a `package.json` file? '\n      );\n    }\n    // Try the parent dir next\n    prev = dir;\n    dir = join(dir, '..');\n  }\n};\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet converter;\n{\n    try {\n        converter = require('bindings')('bigint_buffer');\n    }\n    catch (e) {\n        console.warn('bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)');\n    }\n}\n/**\n * Convert a little-endian buffer into a BigInt.\n * @param buf The little-endian buffer to convert\n * @returns A BigInt with the little-endian representation of buf.\n */\nfunction toBigIntLE(buf) {\n    if (converter === undefined) {\n        const reversed = Buffer.from(buf);\n        reversed.reverse();\n        const hex = reversed.toString('hex');\n        if (hex.length === 0) {\n            return BigInt(0);\n        }\n        return BigInt(`0x${hex}`);\n    }\n    return converter.toBigInt(buf, false);\n}\nexports.toBigIntLE = toBigIntLE;\n/**\n * Convert a big-endian buffer into a BigInt\n * @param buf The big-endian buffer to convert.\n * @returns A BigInt with the big-endian representation of buf.\n */\nfunction toBigIntBE(buf) {\n    if (converter === undefined) {\n        const hex = buf.toString('hex');\n        if (hex.length === 0) {\n            return BigInt(0);\n        }\n        return BigInt(`0x${hex}`);\n    }\n    return converter.toBigInt(buf, true);\n}\nexports.toBigIntBE = toBigIntBE;\n/**\n * Convert a BigInt to a little-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A little-endian buffer representation of num.\n */\nfunction toBufferLE(num, width) {\n    if (converter === undefined) {\n        const hex = num.toString(16);\n        const buffer = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n        buffer.reverse();\n        return buffer;\n    }\n    // Allocation is done here, since it is slower using napi in C\n    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);\n}\nexports.toBufferLE = toBufferLE;\n/**\n * Convert a BigInt to a big-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A big-endian buffer representation of num.\n */\nfunction toBufferBE(num, width) {\n    if (converter === undefined) {\n        const hex = num.toString(16);\n        return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n    }\n    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);\n}\nexports.toBufferBE = toBufferBE;\n","/*\r\n *      bignumber.js v9.3.1\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\nvar\r\n  isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n  mathceil = Math.ceil,\r\n  mathfloor = Math.floor,\r\n\r\n  bignumberError = '[BigNumber Error] ',\r\n  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n  BASE = 1e14,\r\n  LOG_BASE = 14,\r\n  MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n  SQRT_BASE = 1e7,\r\n\r\n  // EDITABLE\r\n  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n  // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n  MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n/*\r\n * Create and return a BigNumber constructor.\r\n */\r\nfunction clone(configObject) {\r\n  var div, convertBase, parseNumeric,\r\n    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n    ONE = new BigNumber(1),\r\n\r\n\r\n    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n    // The default values below must be integers within the inclusive ranges stated.\r\n    // The values can also be changed at run-time using BigNumber.set.\r\n\r\n    // The maximum number of decimal places for operations involving division.\r\n    DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n    // The rounding mode used when rounding to the above decimal places, and when using\r\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n    // UP         0 Away from zero.\r\n    // DOWN       1 Towards zero.\r\n    // CEIL       2 Towards +Infinity.\r\n    // FLOOR      3 Towards -Infinity.\r\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n    // The exponent value at and beneath which toString returns exponential notation.\r\n    // Number type: -7\r\n    TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n    // The exponent value at and above which toString returns exponential notation.\r\n    // Number type: 21\r\n    TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n    // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // Number type: -324  (5e-324)\r\n    MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // Number type:  308  (1.7976931348623157e+308)\r\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n    MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    CRYPTO = false,                          // true or false\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN      1 The remainder has the same sign as the dividend.\r\n    //             This modulo mode is commonly known as 'truncated division' and is\r\n    //             equivalent to (a % n) in JavaScript.\r\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n    //             The remainder is always positive.\r\n    //\r\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n    // modes are commonly used for the modulus operation.\r\n    // Although the other rounding modes can also be used, they may not give useful results.\r\n    MODULO_MODE = 1,                         // 0 to 9\r\n\r\n    // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n    POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n    // The format specification used by the BigNumber.prototype.toFormat method.\r\n    FORMAT = {\r\n      prefix: '',\r\n      groupSize: 3,\r\n      secondaryGroupSize: 0,\r\n      groupSeparator: ',',\r\n      decimalSeparator: '.',\r\n      fractionGroupSize: 0,\r\n      fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n      suffix: ''\r\n    },\r\n\r\n    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n    // '-', '.', whitespace, or repeated character.\r\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n    alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n  //------------------------------------------------------------------------------------------\r\n\r\n\r\n  // CONSTRUCTOR\r\n\r\n\r\n  /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */\r\n  function BigNumber(v, b) {\r\n    var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n      x = this;\r\n\r\n    // Enable constructor call without `new`.\r\n    if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n    if (b == null) {\r\n\r\n      if (v && v._isBigNumber === true) {\r\n        x.s = v.s;\r\n\r\n        if (!v.c || v.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n        } else if (v.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = v.e;\r\n          x.c = v.c.slice();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n        // Use `1 / n` to handle minus zero also.\r\n        x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n        // Fast path for integers, where n < 2147483648 (2**31).\r\n        if (v === ~~v) {\r\n          for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n          if (e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else {\r\n            x.e = e;\r\n            x.c = [v];\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        str = String(v);\r\n      } else {\r\n\r\n        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n      // Exponential form?\r\n      if ((i = str.search(/e/i)) > 0) {\r\n\r\n        // Determine exponent.\r\n        if (e < 0) e = i;\r\n        e += +str.slice(i + 1);\r\n        str = str.substring(0, i);\r\n      } else if (e < 0) {\r\n\r\n        // Integer.\r\n        e = str.length;\r\n      }\r\n\r\n    } else {\r\n\r\n      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n      intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n      // Allow exponential notation to be used with base 10 argument, while\r\n      // also rounding to DECIMAL_PLACES as with other bases.\r\n      if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n        x = new BigNumber(v);\r\n        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n      }\r\n\r\n      str = String(v);\r\n\r\n      if (isNum = typeof v == 'number') {\r\n\r\n        // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n          throw Error\r\n           (tooManyDigits + v);\r\n        }\r\n      } else {\r\n        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      alphabet = ALPHABET.slice(0, b);\r\n      e = i = 0;\r\n\r\n      // Check that str is a valid base b number.\r\n      // Don't use RegExp, so alphabet can contain special characters.\r\n      for (len = str.length; i < len; i++) {\r\n        if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n          if (c == '.') {\r\n\r\n            // If '.' is not the first character and it has not be found before.\r\n            if (i > e) {\r\n              e = len;\r\n              continue;\r\n            }\r\n          } else if (!caseChanged) {\r\n\r\n            // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n              caseChanged = true;\r\n              i = -1;\r\n              e = 0;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          return parseNumeric(x, String(v), isNum, b);\r\n        }\r\n      }\r\n\r\n      // Prevent later check for length on converted number.\r\n      isNum = false;\r\n      str = convertBase(str, b, 10, x.s);\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n      else e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n    if (str = str.slice(i, ++len)) {\r\n      len -= i;\r\n\r\n      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n      if (isNum && BigNumber.DEBUG &&\r\n        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n          throw Error\r\n           (tooManyDigits + (x.s * v));\r\n      }\r\n\r\n       // Overflow?\r\n      if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        x.c = x.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      } else {\r\n        x.e = e;\r\n        x.c = [];\r\n\r\n        // Transform base\r\n\r\n        // e is the base 10 exponent.\r\n        // i is where to slice str to get the first element of the coefficient array.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n        if (i < len) {\r\n          if (i) x.c.push(+str.slice(0, i));\r\n\r\n          for (len -= LOG_BASE; i < len;) {\r\n            x.c.push(+str.slice(i, i += LOG_BASE));\r\n          }\r\n\r\n          i = LOG_BASE - (str = str.slice(i)).length;\r\n        } else {\r\n          i -= len;\r\n        }\r\n\r\n        for (; i--; str += '0');\r\n        x.c.push(+str);\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    }\r\n  }\r\n\r\n\r\n  // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n  BigNumber.clone = clone;\r\n\r\n  BigNumber.ROUND_UP = 0;\r\n  BigNumber.ROUND_DOWN = 1;\r\n  BigNumber.ROUND_CEIL = 2;\r\n  BigNumber.ROUND_FLOOR = 3;\r\n  BigNumber.ROUND_HALF_UP = 4;\r\n  BigNumber.ROUND_HALF_DOWN = 5;\r\n  BigNumber.ROUND_HALF_EVEN = 6;\r\n  BigNumber.ROUND_HALF_CEIL = 7;\r\n  BigNumber.ROUND_HALF_FLOOR = 8;\r\n  BigNumber.EUCLID = 9;\r\n\r\n\r\n  /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */\r\n  BigNumber.config = BigNumber.set = function (obj) {\r\n    var p, v;\r\n\r\n    if (obj != null) {\r\n\r\n      if (typeof obj == 'object') {\r\n\r\n        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          DECIMAL_PLACES = v;\r\n        }\r\n\r\n        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 8, p);\r\n          ROUNDING_MODE = v;\r\n        }\r\n\r\n        // EXPONENTIAL_AT {number|number[]}\r\n        // Integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, 0, p);\r\n            intCheck(v[1], 0, MAX, p);\r\n            TO_EXP_NEG = v[0];\r\n            TO_EXP_POS = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n          }\r\n        }\r\n\r\n        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n        if (obj.hasOwnProperty(p = 'RANGE')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, -1, p);\r\n            intCheck(v[1], 1, MAX, p);\r\n            MIN_EXP = v[0];\r\n            MAX_EXP = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            if (v) {\r\n              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' cannot be zero: ' + v);\r\n            }\r\n          }\r\n        }\r\n\r\n        // CRYPTO {boolean} true or false.\r\n        // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n        // '[BigNumber Error] crypto unavailable'\r\n        if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n          v = obj[p];\r\n          if (v === !!v) {\r\n            if (v) {\r\n              if (typeof crypto != 'undefined' && crypto &&\r\n               (crypto.getRandomValues || crypto.randomBytes)) {\r\n                CRYPTO = v;\r\n              } else {\r\n                CRYPTO = !v;\r\n                throw Error\r\n                 (bignumberError + 'crypto unavailable');\r\n              }\r\n            } else {\r\n              CRYPTO = v;\r\n            }\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' not true or false: ' + v);\r\n          }\r\n        }\r\n\r\n        // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 9, p);\r\n          MODULO_MODE = v;\r\n        }\r\n\r\n        // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          POW_PRECISION = v;\r\n        }\r\n\r\n        // FORMAT {object}\r\n        // '[BigNumber Error] FORMAT not an object: {v}'\r\n        if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n          v = obj[p];\r\n          if (typeof v == 'object') FORMAT = v;\r\n          else throw Error\r\n           (bignumberError + p + ' not an object: ' + v);\r\n        }\r\n\r\n        // ALPHABET {string}\r\n        // '[BigNumber Error] ALPHABET invalid: {v}'\r\n        if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n          v = obj[p];\r\n\r\n          // Disallow if less than two characters,\r\n          // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n          if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n            ALPHABET = v;\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' invalid: ' + v);\r\n          }\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Object expected: {v}'\r\n        throw Error\r\n         (bignumberError + 'Object expected: ' + obj);\r\n      }\r\n    }\r\n\r\n    return {\r\n      DECIMAL_PLACES: DECIMAL_PLACES,\r\n      ROUNDING_MODE: ROUNDING_MODE,\r\n      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n      RANGE: [MIN_EXP, MAX_EXP],\r\n      CRYPTO: CRYPTO,\r\n      MODULO_MODE: MODULO_MODE,\r\n      POW_PRECISION: POW_PRECISION,\r\n      FORMAT: FORMAT,\r\n      ALPHABET: ALPHABET\r\n    };\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */\r\n  BigNumber.isBigNumber = function (v) {\r\n    if (!v || v._isBigNumber !== true) return false;\r\n    if (!BigNumber.DEBUG) return true;\r\n\r\n    var i, n,\r\n      c = v.c,\r\n      e = v.e,\r\n      s = v.s;\r\n\r\n    out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n        // If the first element is zero, the BigNumber value must be zero.\r\n        if (c[0] === 0) {\r\n          if (e === 0 && c.length === 1) return true;\r\n          break out;\r\n        }\r\n\r\n        // Calculate number of digits that c[0] should have, based on the exponent.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (i < 1) i += LOG_BASE;\r\n\r\n        // Calculate number of digits of c[0].\r\n        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n        if (String(c[0]).length == i) {\r\n\r\n          for (i = 0; i < c.length; i++) {\r\n            n = c[i];\r\n            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n          }\r\n\r\n          // Last element cannot be zero, unless it is the only element.\r\n          if (n !== 0) return true;\r\n        }\r\n      }\r\n\r\n    // Infinity/NaN\r\n    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n      return true;\r\n    }\r\n\r\n    throw Error\r\n      (bignumberError + 'Invalid BigNumber: ' + v);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.maximum = BigNumber.max = function () {\r\n    return maxOrMin(arguments, -1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.minimum = BigNumber.min = function () {\r\n    return maxOrMin(arguments, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */\r\n  BigNumber.random = (function () {\r\n    var pow2_53 = 0x20000000000000;\r\n\r\n    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n    // Check if Math.random() produces more than 32 bits of randomness.\r\n    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n     ? function () { return mathfloor(Math.random() * pow2_53); }\r\n     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n       (Math.random() * 0x800000 | 0); };\r\n\r\n    return function (dp) {\r\n      var a, b, e, k, v,\r\n        i = 0,\r\n        c = [],\r\n        rand = new BigNumber(ONE);\r\n\r\n      if (dp == null) dp = DECIMAL_PLACES;\r\n      else intCheck(dp, 0, MAX);\r\n\r\n      k = mathceil(dp / LOG_BASE);\r\n\r\n      if (CRYPTO) {\r\n\r\n        // Browsers supporting crypto.getRandomValues.\r\n        if (crypto.getRandomValues) {\r\n\r\n          a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n          for (; i < k;) {\r\n\r\n            // 53 bits:\r\n            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n            //                                     11111 11111111 11111111\r\n            // 0x20000 is 2^21.\r\n            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n            // Rejection sampling:\r\n            // 0 <= v < 9007199254740992\r\n            // Probability that v >= 9e15, is\r\n            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n            if (v >= 9e15) {\r\n              b = crypto.getRandomValues(new Uint32Array(2));\r\n              a[i] = b[0];\r\n              a[i + 1] = b[1];\r\n            } else {\r\n\r\n              // 0 <= v <= 8999999999999999\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 2;\r\n            }\r\n          }\r\n          i = k / 2;\r\n\r\n        // Node.js supporting crypto.randomBytes.\r\n        } else if (crypto.randomBytes) {\r\n\r\n          // buffer\r\n          a = crypto.randomBytes(k *= 7);\r\n\r\n          for (; i < k;) {\r\n\r\n            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n            // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n            // 0 <= v < 9007199254740992\r\n            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n            if (v >= 9e15) {\r\n              crypto.randomBytes(7).copy(a, i);\r\n            } else {\r\n\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 7;\r\n            }\r\n          }\r\n          i = k / 7;\r\n        } else {\r\n          CRYPTO = false;\r\n          throw Error\r\n           (bignumberError + 'crypto unavailable');\r\n        }\r\n      }\r\n\r\n      // Use Math.random.\r\n      if (!CRYPTO) {\r\n\r\n        for (; i < k;) {\r\n          v = random53bitInt();\r\n          if (v < 9e15) c[i++] = v % 1e14;\r\n        }\r\n      }\r\n\r\n      k = c[--i];\r\n      dp %= LOG_BASE;\r\n\r\n      // Convert trailing digits to zeros according to dp.\r\n      if (k && dp) {\r\n        v = POWS_TEN[LOG_BASE - dp];\r\n        c[i] = mathfloor(k / v) * v;\r\n      }\r\n\r\n      // Remove trailing elements which are zero.\r\n      for (; c[i] === 0; c.pop(), i--);\r\n\r\n      // Zero?\r\n      if (i < 0) {\r\n        c = [e = 0];\r\n      } else {\r\n\r\n        // Remove leading elements which are zero and adjust exponent accordingly.\r\n        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n        // Count the digits of the first element of c to determine leading zeros, and...\r\n        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n        // adjust the exponent accordingly.\r\n        if (i < LOG_BASE) e -= LOG_BASE - i;\r\n      }\r\n\r\n      rand.e = e;\r\n      rand.c = c;\r\n      return rand;\r\n    };\r\n  })();\r\n\r\n\r\n   /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.sum = function () {\r\n    var i = 1,\r\n      args = arguments,\r\n      sum = new BigNumber(args[0]);\r\n    for (; i < args.length;) sum = sum.plus(args[i++]);\r\n    return sum;\r\n  };\r\n\r\n\r\n  // PRIVATE FUNCTIONS\r\n\r\n\r\n  // Called by BigNumber and BigNumber.prototype.toString.\r\n  convertBase = (function () {\r\n    var decimal = '0123456789';\r\n\r\n    /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */\r\n    function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n      var j,\r\n        arr = [0],\r\n        arrL,\r\n        i = 0,\r\n        len = str.length;\r\n\r\n      for (; i < len;) {\r\n        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n        arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n        for (j = 0; j < arr.length; j++) {\r\n\r\n          if (arr[j] > baseOut - 1) {\r\n            if (arr[j + 1] == null) arr[j + 1] = 0;\r\n            arr[j + 1] += arr[j] / baseOut | 0;\r\n            arr[j] %= baseOut;\r\n          }\r\n        }\r\n      }\r\n\r\n      return arr.reverse();\r\n    }\r\n\r\n    // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n    // If the caller is toString, we are converting from base 10 to baseOut.\r\n    // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n    return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n      var alphabet, d, e, k, r, x, xc, y,\r\n        i = str.indexOf('.'),\r\n        dp = DECIMAL_PLACES,\r\n        rm = ROUNDING_MODE;\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        k = POW_PRECISION;\r\n\r\n        // Unlimited precision.\r\n        POW_PRECISION = 0;\r\n        str = str.replace('.', '');\r\n        y = new BigNumber(baseIn);\r\n        x = y.pow(str.length - i);\r\n        POW_PRECISION = k;\r\n\r\n        // Convert str as if an integer, then restore the fraction part by dividing the\r\n        // result by its base raised to a power.\r\n\r\n        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n         10, baseOut, decimal);\r\n        y.e = y.c.length;\r\n      }\r\n\r\n      // Convert the number as integer.\r\n\r\n      xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n       ? (alphabet = ALPHABET, decimal)\r\n       : (alphabet = decimal, ALPHABET));\r\n\r\n      // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n      e = k = xc.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xc[--k] == 0; xc.pop());\r\n\r\n      // Zero?\r\n      if (!xc[0]) return alphabet.charAt(0);\r\n\r\n      // Does str represent an integer? If so, no need for the division.\r\n      if (i < 0) {\r\n        --e;\r\n      } else {\r\n        x.c = xc;\r\n        x.e = e;\r\n\r\n        // The sign is needed for correct rounding.\r\n        x.s = sign;\r\n        x = div(x, y, dp, rm, baseOut);\r\n        xc = x.c;\r\n        r = x.r;\r\n        e = x.e;\r\n      }\r\n\r\n      // xc now represents str converted to baseOut.\r\n\r\n      // The index of the rounding digit.\r\n      d = e + dp + 1;\r\n\r\n      // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n      i = xc[d];\r\n\r\n      // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n      k = baseOut / 2;\r\n      r = r || d < 0 || xc[d + 1] != null;\r\n\r\n      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n      // If the index of the rounding digit is not greater than zero, or xc represents\r\n      // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n      // such as 0.00001.\r\n      if (d < 1 || !xc[0]) {\r\n\r\n        // 1^-dp or 0\r\n        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n      } else {\r\n\r\n        // Truncate xc to the required number of decimal places.\r\n        xc.length = d;\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (--baseOut; ++xc[--d] > baseOut;) {\r\n            xc[d] = 0;\r\n\r\n            if (!d) {\r\n              ++e;\r\n              xc = [1].concat(xc);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (k = xc.length; !xc[--k];);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n        // Add leading zeros, decimal point and trailing zeros as required.\r\n        str = toFixedPoint(str, e, alphabet.charAt(0));\r\n      }\r\n\r\n      // The caller will add the sign.\r\n      return str;\r\n    };\r\n  })();\r\n\r\n\r\n  // Perform division in the specified base. Called by div and convertBase.\r\n  div = (function () {\r\n\r\n    // Assume non-zero x and k.\r\n    function multiply(x, k, base) {\r\n      var m, temp, xlo, xhi,\r\n        carry = 0,\r\n        i = x.length,\r\n        klo = k % SQRT_BASE,\r\n        khi = k / SQRT_BASE | 0;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        xlo = x[i] % SQRT_BASE;\r\n        xhi = x[i] / SQRT_BASE | 0;\r\n        m = khi * xlo + xhi * klo;\r\n        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n        x[i] = temp % base;\r\n      }\r\n\r\n      if (carry) x = [carry].concat(x);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, cmp;\r\n\r\n      if (aL != bL) {\r\n        cmp = aL > bL ? 1 : -1;\r\n      } else {\r\n\r\n        for (i = cmp = 0; i < aL; i++) {\r\n\r\n          if (a[i] != b[i]) {\r\n            cmp = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return cmp;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n    }\r\n\r\n    // x: dividend, y: divisor.\r\n    return function (x, y, dp, rm, base) {\r\n      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n        yL, yz,\r\n        s = x.s == y.s ? 1 : -1,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n        return new BigNumber(\r\n\r\n         // Return NaN if either NaN, or both Infinity or 0.\r\n         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n          // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\r\n          xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n       );\r\n      }\r\n\r\n      q = new BigNumber(s);\r\n      qc = q.c = [];\r\n      e = x.e - y.e;\r\n      s = dp + e + 1;\r\n\r\n      if (!base) {\r\n        base = BASE;\r\n        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n        s = s / LOG_BASE | 0;\r\n      }\r\n\r\n      // Result exponent may be one less then the current value of e.\r\n      // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n      for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n      if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n      if (s < 0) {\r\n        qc.push(1);\r\n        more = true;\r\n      } else {\r\n        xL = xc.length;\r\n        yL = yc.length;\r\n        i = 0;\r\n        s += 2;\r\n\r\n        // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n        n = mathfloor(base / (yc[0] + 1));\r\n\r\n        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n        if (n > 1) {\r\n          yc = multiply(yc, n, base);\r\n          xc = multiply(xc, n, base);\r\n          yL = yc.length;\r\n          xL = xc.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xc.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL; rem[remL++] = 0);\r\n        yz = yc.slice();\r\n        yz = [0].concat(yz);\r\n        yc0 = yc[0];\r\n        if (yc[1] >= base / 2) yc0++;\r\n        // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n        do {\r\n          n = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yc, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, n.\r\n\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // n is how many times the divisor goes into the current remainder.\r\n            n = mathfloor(rem0 / yc0);\r\n\r\n            //  Algorithm:\r\n            //  product = divisor multiplied by trial digit (n).\r\n            //  Compare product and remainder.\r\n            //  If product is greater than remainder:\r\n            //    Subtract divisor from product, decrement trial digit.\r\n            //  Subtract product from remainder.\r\n            //  If product was less than remainder at the last compare:\r\n            //    Compare new remainder and divisor.\r\n            //    If remainder is greater than divisor:\r\n            //      Subtract divisor from remainder, increment trial digit.\r\n\r\n            if (n > 1) {\r\n\r\n              // n may be > base only when base is 3.\r\n              if (n >= base) n = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiply(yc, n, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              // If product > remainder then trial digit n too high.\r\n              // n is 1 too high about 5% of the time, and is not known to have\r\n              // ever been more than 1 too high.\r\n              while (compare(prod, rem, prodL, remL) == 1) {\r\n                n--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                prodL = prod.length;\r\n                cmp = 1;\r\n              }\r\n            } else {\r\n\r\n              // n is 0 or 1, cmp is -1.\r\n              // If n is 0, there is no need to compare yc and rem again below,\r\n              // so change cmp to 1 to avoid it.\r\n              // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n              if (n == 0) {\r\n\r\n                // divisor < remainder, so n must be at least 1.\r\n                cmp = n = 1;\r\n              }\r\n\r\n              // product = divisor\r\n              prod = yc.slice();\r\n              prodL = prod.length;\r\n            }\r\n\r\n            if (prodL < remL) prod = [0].concat(prod);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n            remL = rem.length;\r\n\r\n             // If product was < remainder.\r\n            if (cmp == -1) {\r\n\r\n              // Compare divisor and new remainder.\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              // Trial digit n too low.\r\n              // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n              while (compare(yc, rem, yL, remL) < 1) {\r\n                n++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                remL = rem.length;\r\n              }\r\n            }\r\n          } else if (cmp === 0) {\r\n            n++;\r\n            rem = [0];\r\n          } // else cmp === 1 and n will be 0\r\n\r\n          // Add the next digit, n, to the result array.\r\n          qc[i++] = n;\r\n\r\n          // Update the remainder.\r\n          if (rem[0]) {\r\n            rem[remL++] = xc[xi] || 0;\r\n          } else {\r\n            rem = [xc[xi]];\r\n            remL = 1;\r\n          }\r\n        } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n        more = rem[0] != null;\r\n\r\n        // Leading zero?\r\n        if (!qc[0]) qc.splice(0, 1);\r\n      }\r\n\r\n      if (base == BASE) {\r\n\r\n        // To calculate q.e, first get the number of digits of qc[0].\r\n        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n      // Caller is convertBase.\r\n      } else {\r\n        q.e = e;\r\n        q.r = +more;\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */\r\n  function format(n, i, rm, id) {\r\n    var c0, e, ne, len, str;\r\n\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n\r\n    if (!n.c) return n.toString();\r\n\r\n    c0 = n.c[0];\r\n    ne = n.e;\r\n\r\n    if (i == null) {\r\n      str = coeffToString(n.c);\r\n      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n       ? toExponential(str, ne)\r\n       : toFixedPoint(str, ne, '0');\r\n    } else {\r\n      n = round(new BigNumber(n), i, rm);\r\n\r\n      // n.e may have changed if the value was rounded up.\r\n      e = n.e;\r\n\r\n      str = coeffToString(n.c);\r\n      len = str.length;\r\n\r\n      // toPrecision returns exponential notation if the number of significant digits\r\n      // specified is less than the number of digits necessary to represent the integer\r\n      // part of the value in fixed-point notation.\r\n\r\n      // Exponential notation.\r\n      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n        // Append zeros?\r\n        for (; len < i; str += '0', len++);\r\n        str = toExponential(str, e);\r\n\r\n      // Fixed-point notation.\r\n      } else {\r\n        i -= ne + (id === 2 && e > ne);\r\n        str = toFixedPoint(str, e, '0');\r\n\r\n        // Append zeros?\r\n        if (e + 1 > len) {\r\n          if (--i > 0) for (str += '.'; i--; str += '0');\r\n        } else {\r\n          i += e - len;\r\n          if (i > 0) {\r\n            if (e + 1 == len) str += '.';\r\n            for (; i--; str += '0');\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return n.s < 0 && c0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Handle BigNumber.max and BigNumber.min.\r\n  // If any number is NaN, return NaN.\r\n  function maxOrMin(args, n) {\r\n    var k, y,\r\n      i = 1,\r\n      x = new BigNumber(args[0]);\r\n\r\n    for (; i < args.length; i++) {\r\n      y = new BigNumber(args[i]);\r\n      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */\r\n  function normalise(n, c, e) {\r\n    var i = 1,\r\n      j = c.length;\r\n\r\n     // Remove trailing zeros.\r\n    for (; !c[--j]; c.pop());\r\n\r\n    // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n    for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n    // Overflow?\r\n    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n      // Infinity.\r\n      n.c = n.e = null;\r\n\r\n    // Underflow?\r\n    } else if (e < MIN_EXP) {\r\n\r\n      // Zero.\r\n      n.c = [n.e = 0];\r\n    } else {\r\n      n.e = e;\r\n      n.c = c;\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n\r\n  // Handle values that fail the validity test in BigNumber.\r\n  parseNumeric = (function () {\r\n    var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n      dotAfter = /^([^.]+)\\.$/,\r\n      dotBefore = /^\\.([^.]+)$/,\r\n      isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n      whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n    return function (x, str, isNum, b) {\r\n      var base,\r\n        s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n      // No exception on ±Infinity or NaN.\r\n      if (isInfinityOrNaN.test(s)) {\r\n        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n      } else {\r\n        if (!isNum) {\r\n\r\n          // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n          s = s.replace(basePrefix, function (m, p1, p2) {\r\n            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n            return !b || b == base ? p1 : m;\r\n          });\r\n\r\n          if (b) {\r\n            base = b;\r\n\r\n            // E.g. '1.' to '1', '.1' to '0.1'\r\n            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n          }\r\n\r\n          if (str != s) return new BigNumber(s, base);\r\n        }\r\n\r\n        // '[BigNumber Error] Not a number: {n}'\r\n        // '[BigNumber Error] Not a base {b} number: {n}'\r\n        if (BigNumber.DEBUG) {\r\n          throw Error\r\n            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n        }\r\n\r\n        // NaN\r\n        x.s = null;\r\n      }\r\n\r\n      x.c = x.e = null;\r\n    }\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */\r\n  function round(x, sd, rm, r) {\r\n    var d, i, j, k, n, ni, rd,\r\n      xc = x.c,\r\n      pows10 = POWS_TEN;\r\n\r\n    // if x is not Infinity or NaN...\r\n    if (xc) {\r\n\r\n      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n      // ni is the index of n within x.c.\r\n      // d is the number of digits of n.\r\n      // i is the index of rd within n including leading zeros.\r\n      // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n      out: {\r\n\r\n        // Get the number of digits of the first element of xc.\r\n        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n        i = sd - d;\r\n\r\n        // If the rounding digit is in the first element of xc...\r\n        if (i < 0) {\r\n          i += LOG_BASE;\r\n          j = sd;\r\n          n = xc[ni = 0];\r\n\r\n          // Get the rounding digit at index j of n.\r\n          rd = mathfloor(n / pows10[d - j - 1] % 10);\r\n        } else {\r\n          ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n          if (ni >= xc.length) {\r\n\r\n            if (r) {\r\n\r\n              // Needed by sqrt.\r\n              for (; xc.length <= ni; xc.push(0));\r\n              n = rd = 0;\r\n              d = 1;\r\n              i %= LOG_BASE;\r\n              j = i - LOG_BASE + 1;\r\n            } else {\r\n              break out;\r\n            }\r\n          } else {\r\n            n = k = xc[ni];\r\n\r\n            // Get the number of digits of n.\r\n            for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n            // Get the index of rd within n.\r\n            i %= LOG_BASE;\r\n\r\n            // Get the index of rd within n, adjusted for leading zeros.\r\n            // The number of leading zeros of n is given by LOG_BASE - d.\r\n            j = i - LOG_BASE + d;\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\r\n          }\r\n        }\r\n\r\n        r = r || sd < 0 ||\r\n\r\n        // Are there any non-zero digits after the rounding digit?\r\n        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n        r = rm < 4\r\n         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n           rm == (x.s < 0 ? 8 : 7));\r\n\r\n        if (sd < 1 || !xc[0]) {\r\n          xc.length = 0;\r\n\r\n          if (r) {\r\n\r\n            // Convert sd to decimal places.\r\n            sd -= x.e + 1;\r\n\r\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n            x.e = -sd || 0;\r\n          } else {\r\n\r\n            // Zero.\r\n            xc[0] = x.e = 0;\r\n          }\r\n\r\n          return x;\r\n        }\r\n\r\n        // Remove excess digits.\r\n        if (i == 0) {\r\n          xc.length = ni;\r\n          k = 1;\r\n          ni--;\r\n        } else {\r\n          xc.length = ni + 1;\r\n          k = pows10[LOG_BASE - i];\r\n\r\n          // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n          // j > 0 means i > number of leading zeros of n.\r\n          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n        }\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          for (; ;) {\r\n\r\n            // If the digit to be rounded up is in the first element of xc...\r\n            if (ni == 0) {\r\n\r\n              // i will be the length of xc[0] before k is added.\r\n              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n              j = xc[0] += k;\r\n              for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n              // if i != k the length has increased.\r\n              if (i != k) {\r\n                x.e++;\r\n                if (xc[0] == BASE) xc[0] = 1;\r\n              }\r\n\r\n              break;\r\n            } else {\r\n              xc[ni] += k;\r\n              if (xc[ni] != BASE) break;\r\n              xc[ni--] = 0;\r\n              k = 1;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Remove trailing zeros.\r\n        for (i = xc.length; xc[--i] === 0; xc.pop());\r\n      }\r\n\r\n      // Overflow? Infinity.\r\n      if (x.e > MAX_EXP) {\r\n        x.c = x.e = null;\r\n\r\n      // Underflow? Zero.\r\n      } else if (x.e < MIN_EXP) {\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function valueOf(n) {\r\n    var str,\r\n      e = n.e;\r\n\r\n    if (e === null) return n.toString();\r\n\r\n    str = coeffToString(n.c);\r\n\r\n    str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n      ? toExponential(str, e)\r\n      : toFixedPoint(str, e, '0');\r\n\r\n    return n.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new BigNumber(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */\r\n  P.comparedTo = function (y, b) {\r\n    return compare(this, new BigNumber(y, b));\r\n  };\r\n\r\n\r\n  /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.decimalPlaces = P.dp = function (dp, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), dp + x.e + 1, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last number.\r\n    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n    if (n < 0) n = 0;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.dividedBy = P.div = function (y, b) {\r\n    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */\r\n  P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n    return div(this, new BigNumber(y, b), 0, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */\r\n  P.exponentiatedBy = P.pow = function (n, m) {\r\n    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n      x = this;\r\n\r\n    n = new BigNumber(n);\r\n\r\n    // Allow NaN and ±Infinity, but not other non-integers.\r\n    if (n.c && !n.isInteger()) {\r\n      throw Error\r\n        (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n    }\r\n\r\n    if (m != null) m = new BigNumber(m);\r\n\r\n    // Exponent of MAX_SAFE_INTEGER is 15.\r\n    nIsBig = n.e > 14;\r\n\r\n    // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\r\n    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n      // The sign of the result of pow when x is negative depends on the evenness of n.\r\n      // If +n overflows to ±Infinity, the evenness of n would be not be known.\r\n      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\r\n      return m ? y.mod(m) : y;\r\n    }\r\n\r\n    nIsNeg = n.s < 0;\r\n\r\n    if (m) {\r\n\r\n      // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n      isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n      if (isModExp) x = x.mod(m);\r\n\r\n    // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n    // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\r\n    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n      // [1, 240000000]\r\n      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n      // [80000000000000]  [99999750000000]\r\n      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n      // If x is negative and n is odd, k = -0, else k = 0.\r\n      k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n      // If x >= 1, k = ±Infinity.\r\n      if (x.e > -1) k = 1 / k;\r\n\r\n      // If n is negative return ±0, else return ±Infinity.\r\n      return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n    } else if (POW_PRECISION) {\r\n\r\n      // Truncating each coefficient array to a length of k after each multiplication\r\n      // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n      // i.e. there will be a minimum of 28 guard digits retained.\r\n      k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n    }\r\n\r\n    if (nIsBig) {\r\n      half = new BigNumber(0.5);\r\n      if (nIsNeg) n.s = 1;\r\n      nIsOdd = isOdd(n);\r\n    } else {\r\n      i = Math.abs(+valueOf(n));\r\n      nIsOdd = i % 2;\r\n    }\r\n\r\n    y = new BigNumber(ONE);\r\n\r\n    // Performs 54 loop iterations for n of 9007199254740991.\r\n    for (; ;) {\r\n\r\n      if (nIsOdd) {\r\n        y = y.times(x);\r\n        if (!y.c) break;\r\n\r\n        if (k) {\r\n          if (y.c.length > k) y.c.length = k;\r\n        } else if (isModExp) {\r\n          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (i) {\r\n        i = mathfloor(i / 2);\r\n        if (i === 0) break;\r\n        nIsOdd = i % 2;\r\n      } else {\r\n        n = n.times(half);\r\n        round(n, n.e + 1, 1);\r\n\r\n        if (n.e > 14) {\r\n          nIsOdd = isOdd(n);\r\n        } else {\r\n          i = +valueOf(n);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        }\r\n      }\r\n\r\n      x = x.times(x);\r\n\r\n      if (k) {\r\n        if (x.c && x.c.length > k) x.c.length = k;\r\n      } else if (isModExp) {\r\n        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n      }\r\n    }\r\n\r\n    if (isModExp) return y;\r\n    if (nIsNeg) y = ONE.div(y);\r\n\r\n    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */\r\n  P.integerValue = function (rm) {\r\n    var n = new BigNumber(this);\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n    return round(n, n.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isEqualTo = P.eq = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.c;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isGreaterThan = P.gt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */\r\n  P.isInteger = function () {\r\n    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isLessThan = P.lt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */\r\n  P.isNegative = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */\r\n  P.isPositive = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.c && this.c[0] == 0;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.minus = function (y, b) {\r\n    var i, j, t, xLTy,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Either Infinity?\r\n      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n      // Either zero?\r\n      if (!xc[0] || !yc[0]) {\r\n\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n         ROUNDING_MODE == 3 ? -0 : 0);\r\n      }\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Determine which is the bigger number.\r\n    if (a = xe - ye) {\r\n\r\n      if (xLTy = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      for (b = a; b--; t.push(0));\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n\r\n        if (xc[b] != yc[b]) {\r\n          xLTy = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xLTy) {\r\n      t = xc;\r\n      xc = yc;\r\n      yc = t;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    b = (j = yc.length) - (i = xc.length);\r\n\r\n    // Append zeros to xc if shorter.\r\n    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n    if (b > 0) for (; b--; xc[i++] = 0);\r\n    b = BASE - 1;\r\n\r\n    // Subtract yc from xc.\r\n    for (; j > a;) {\r\n\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i]; xc[i] = b);\r\n        --xc[i];\r\n        xc[j] += BASE;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n    // Zero?\r\n    if (!xc[0]) {\r\n\r\n      // Following IEEE 754 (2008) 6.3,\r\n      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n      y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n    // for finite x and y.\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */\r\n  P.modulo = P.mod = function (y, b) {\r\n    var q, s,\r\n      x = this;\r\n\r\n    y = new BigNumber(y, b);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n    if (!x.c || !y.s || y.c && !y.c[0]) {\r\n      return new BigNumber(NaN);\r\n\r\n    // Return x if y is Infinity or x is zero.\r\n    } else if (!y.c || x.c && !x.c[0]) {\r\n      return new BigNumber(x);\r\n    }\r\n\r\n    if (MODULO_MODE == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // r = x - qy    where  0 <= r < abs(y)\r\n      s = y.s;\r\n      y.s = 1;\r\n      q = div(x, y, 0, 3);\r\n      y.s = s;\r\n      q.s *= s;\r\n    } else {\r\n      q = div(x, y, 0, MODULO_MODE);\r\n    }\r\n\r\n    y = x.minus(q.times(y));\r\n\r\n    // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */\r\n  P.multipliedBy = P.times = function (y, b) {\r\n    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n      base, sqrtBase,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new BigNumber(y, b)).c;\r\n\r\n    // Either NaN, ±Infinity or ±0?\r\n    if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n      // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n        y.c = y.e = y.s = null;\r\n      } else {\r\n        y.s *= x.s;\r\n\r\n        // Return ±Infinity if either is ±Infinity.\r\n        if (!xc || !yc) {\r\n          y.c = y.e = null;\r\n\r\n        // Return ±0 if either is ±0.\r\n        } else {\r\n          y.c = [0];\r\n          y.e = 0;\r\n        }\r\n      }\r\n\r\n      return y;\r\n    }\r\n\r\n    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n    y.s *= x.s;\r\n    xcL = xc.length;\r\n    ycL = yc.length;\r\n\r\n    // Ensure xc points to longer array and xcL to its length.\r\n    if (xcL < ycL) {\r\n      zc = xc;\r\n      xc = yc;\r\n      yc = zc;\r\n      i = xcL;\r\n      xcL = ycL;\r\n      ycL = i;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n    base = BASE;\r\n    sqrtBase = SQRT_BASE;\r\n\r\n    for (i = ycL; --i >= 0;) {\r\n      c = 0;\r\n      ylo = yc[i] % sqrtBase;\r\n      yhi = yc[i] / sqrtBase | 0;\r\n\r\n      for (k = xcL, j = i + k; j > i;) {\r\n        xlo = xc[--k] % sqrtBase;\r\n        xhi = xc[k] / sqrtBase | 0;\r\n        m = yhi * xlo + xhi * ylo;\r\n        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n        zc[j--] = xlo % base;\r\n      }\r\n\r\n      zc[j] = c;\r\n    }\r\n\r\n    if (c) {\r\n      ++e;\r\n    } else {\r\n      zc.splice(0, 1);\r\n    }\r\n\r\n    return normalise(y, zc, e);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */\r\n  P.negated = function () {\r\n    var x = new BigNumber(this);\r\n    x.s = -x.s || null;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.plus = function (y, b) {\r\n    var t,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n     if (a != b) {\r\n      y.s = -b;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Return ±Infinity if either ±Infinity.\r\n      if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n      // Either zero?\r\n      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n    if (a = xe - ye) {\r\n      if (a > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        a = -a;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; a--; t.push(0));\r\n      t.reverse();\r\n    }\r\n\r\n    a = xc.length;\r\n    b = yc.length;\r\n\r\n    // Point xc to the longer array, and b to the shorter length.\r\n    if (a - b < 0) {\r\n      t = yc;\r\n      yc = xc;\r\n      xc = t;\r\n      b = a;\r\n    }\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n    for (a = 0; b;) {\r\n      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n    }\r\n\r\n    if (a) {\r\n      xc = [a].concat(xc);\r\n      ++ye;\r\n    }\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    // ye = MAX_EXP + 1 possible\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.precision = P.sd = function (sd, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (sd != null && sd !== !!sd) {\r\n      intCheck(sd, 1, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), sd, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    v = c.length - 1;\r\n    n = v * LOG_BASE + 1;\r\n\r\n    if (v = c[v]) {\r\n\r\n      // Subtract the number of trailing zeros of the last element.\r\n      for (; v % 10 == 0; v /= 10, n--);\r\n\r\n      // Add the number of digits of the first element.\r\n      for (v = c[0]; v >= 10; v /= 10, n++);\r\n    }\r\n\r\n    if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */\r\n  P.shiftedBy = function (k) {\r\n    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n    return this.times('1e' + k);\r\n  };\r\n\r\n\r\n  /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, r, rep, t,\r\n      x = this,\r\n      c = x.c,\r\n      s = x.s,\r\n      e = x.e,\r\n      dp = DECIMAL_PLACES + 4,\r\n      half = new BigNumber('0.5');\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !c || !c[0]) {\r\n      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n    }\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+valueOf(x));\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = coeffToString(c);\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(+n);\r\n      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new BigNumber(n);\r\n    } else {\r\n      r = new BigNumber(s + '');\r\n    }\r\n\r\n    // Check for zero.\r\n    // r could be zero if MIN_EXP is changed after the this value was created.\r\n    // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n    // coeffToString to throw.\r\n    if (r.c[0]) {\r\n      e = r.e;\r\n      s = e + dp;\r\n      if (s < 3) s = 0;\r\n\r\n      // Newton-Raphson iteration.\r\n      for (; ;) {\r\n        t = r;\r\n        r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n          // The exponent of r may here be one less than the final result exponent,\r\n          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n          // are indexed correctly.\r\n          if (r.e < e) --s;\r\n          n = n.slice(s - 3, s + 1);\r\n\r\n          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n          // iteration.\r\n          if (n == '9999' || !rep && n == '4999') {\r\n\r\n            // On the first iteration only, check to see if rounding up gives the\r\n            // exact result as the nines may infinitely repeat.\r\n            if (!rep) {\r\n              round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n              if (t.times(t).eq(x)) {\r\n                r = t;\r\n                break;\r\n              }\r\n            }\r\n\r\n            dp += 4;\r\n            s += 4;\r\n            rep = 1;\r\n          } else {\r\n\r\n            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n            // result. If not, then there are further digits and m will be truthy.\r\n            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n              // Truncate to the first rounding digit.\r\n              round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n              m = !r.times(r).eq(x);\r\n            }\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp++;\r\n    }\r\n    return format(this, dp, rm, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp = dp + this.e + 1;\r\n    }\r\n    return format(this, dp, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */\r\n  P.toFormat = function (dp, rm, format) {\r\n    var str,\r\n      x = this;\r\n\r\n    if (format == null) {\r\n      if (dp != null && rm && typeof rm == 'object') {\r\n        format = rm;\r\n        rm = null;\r\n      } else if (dp && typeof dp == 'object') {\r\n        format = dp;\r\n        dp = rm = null;\r\n      } else {\r\n        format = FORMAT;\r\n      }\r\n    } else if (typeof format != 'object') {\r\n      throw Error\r\n        (bignumberError + 'Argument not an object: ' + format);\r\n    }\r\n\r\n    str = x.toFixed(dp, rm);\r\n\r\n    if (x.c) {\r\n      var i,\r\n        arr = str.split('.'),\r\n        g1 = +format.groupSize,\r\n        g2 = +format.secondaryGroupSize,\r\n        groupSeparator = format.groupSeparator || '',\r\n        intPart = arr[0],\r\n        fractionPart = arr[1],\r\n        isNeg = x.s < 0,\r\n        intDigits = isNeg ? intPart.slice(1) : intPart,\r\n        len = intDigits.length;\r\n\r\n      if (g2) {\r\n        i = g1;\r\n        g1 = g2;\r\n        g2 = i;\r\n        len -= i;\r\n      }\r\n\r\n      if (g1 > 0 && len > 0) {\r\n        i = len % g1 || g1;\r\n        intPart = intDigits.substr(0, i);\r\n        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n        if (isNeg) intPart = '-' + intPart;\r\n      }\r\n\r\n      str = fractionPart\r\n       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n        ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n         '$&' + (format.fractionGroupSeparator || ''))\r\n        : fractionPart)\r\n       : intPart;\r\n    }\r\n\r\n    return (format.prefix || '') + str + (format.suffix || '');\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */\r\n  P.toFraction = function (md) {\r\n    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n      x = this,\r\n      xc = x.c;\r\n\r\n    if (md != null) {\r\n      n = new BigNumber(md);\r\n\r\n      // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n        throw Error\r\n          (bignumberError + 'Argument ' +\r\n            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n      }\r\n    }\r\n\r\n    if (!xc) return new BigNumber(x);\r\n\r\n    d = new BigNumber(ONE);\r\n    n1 = d0 = new BigNumber(ONE);\r\n    d1 = n0 = new BigNumber(ONE);\r\n    s = coeffToString(xc);\r\n\r\n    // Determine initial denominator.\r\n    // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n    e = d.e = s.length - x.e - 1;\r\n    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n    exp = MAX_EXP;\r\n    MAX_EXP = 1 / 0;\r\n    n = new BigNumber(s);\r\n\r\n    // n0 = d1 = 0\r\n    n0.c[0] = 0;\r\n\r\n    for (; ;)  {\r\n      q = div(n, d, 0, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.comparedTo(md) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      n1 = n0.plus(q.times(d2 = n1));\r\n      n0 = d2;\r\n      d = n.minus(q.times(d2 = d));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = div(md.minus(d0), d1, 0, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n    e = e * 2;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n    MAX_EXP = exp;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */\r\n  P.toNumber = function () {\r\n    return +valueOf(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    if (sd != null) intCheck(sd, 1, MAX);\r\n    return format(this, sd, rm, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */\r\n  P.toString = function (b) {\r\n    var str,\r\n      n = this,\r\n      s = n.s,\r\n      e = n.e;\r\n\r\n    // Infinity or NaN?\r\n    if (e === null) {\r\n      if (s) {\r\n        str = 'Infinity';\r\n        if (s < 0) str = '-' + str;\r\n      } else {\r\n        str = 'NaN';\r\n      }\r\n    } else {\r\n      if (b == null) {\r\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n         ? toExponential(coeffToString(n.c), e)\r\n         : toFixedPoint(coeffToString(n.c), e, '0');\r\n      } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n        str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n      } else {\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n      }\r\n\r\n      if (s < 0 && n.c[0]) str = '-' + str;\r\n    }\r\n\r\n    return str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    return valueOf(this);\r\n  };\r\n\r\n\r\n  P._isBigNumber = true;\r\n\r\n  P[Symbol.toStringTag] = 'BigNumber';\r\n\r\n  // Node.js v10.12.0+\r\n  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;\r\n\r\n  if (configObject != null) BigNumber.set(configObject);\r\n\r\n  return BigNumber;\r\n}\r\n\r\n\r\n// PRIVATE HELPER FUNCTIONS\r\n\r\n// These functions don't need access to variables,\r\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\nfunction bitFloor(n) {\r\n  var i = n | 0;\r\n  return n > 0 || n === i ? i : i - 1;\r\n}\r\n\r\n\r\n// Return a coefficient array as a string of base 10 digits.\r\nfunction coeffToString(a) {\r\n  var s, z,\r\n    i = 1,\r\n    j = a.length,\r\n    r = a[0] + '';\r\n\r\n  for (; i < j;) {\r\n    s = a[i++] + '';\r\n    z = LOG_BASE - s.length;\r\n    for (; z--; s = '0' + s);\r\n    r += s;\r\n  }\r\n\r\n  // Determine trailing zeros.\r\n  for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n  return r.slice(0, j + 1 || 1);\r\n}\r\n\r\n\r\n// Compare the value of BigNumbers x and y.\r\nfunction compare(x, y) {\r\n  var a, b,\r\n    xc = x.c,\r\n    yc = y.c,\r\n    i = x.s,\r\n    j = y.s,\r\n    k = x.e,\r\n    l = y.e;\r\n\r\n  // Either NaN?\r\n  if (!i || !j) return null;\r\n\r\n  a = xc && !xc[0];\r\n  b = yc && !yc[0];\r\n\r\n  // Either zero?\r\n  if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n  // Signs differ?\r\n  if (i != j) return i;\r\n\r\n  a = i < 0;\r\n  b = k == l;\r\n\r\n  // Either Infinity?\r\n  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n  // Compare exponents.\r\n  if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n  j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n  // Compare lengths.\r\n  return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n}\r\n\r\n\r\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */\r\nfunction intCheck(n, min, max, name) {\r\n  if (n < min || n > max || n !== mathfloor(n)) {\r\n    throw Error\r\n     (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n       ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n       : ' not a primitive number: ') + String(n));\r\n  }\r\n}\r\n\r\n\r\n// Assumes finite n.\r\nfunction isOdd(n) {\r\n  var k = n.c.length - 1;\r\n  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n}\r\n\r\n\r\nfunction toExponential(str, e) {\r\n  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n   (e < 0 ? 'e' : 'e+') + e;\r\n}\r\n\r\n\r\nfunction toFixedPoint(str, e, z) {\r\n  var len, zs;\r\n\r\n  // Negative exponent?\r\n  if (e < 0) {\r\n\r\n    // Prepend zeros.\r\n    for (zs = z + '.'; ++e; zs += z);\r\n    str = zs + str;\r\n\r\n  // Positive exponent\r\n  } else {\r\n    len = str.length;\r\n\r\n    // Append zeros.\r\n    if (++e > len) {\r\n      for (zs = z, e -= len; --e; zs += z);\r\n      str += zs;\r\n    } else if (e < len) {\r\n      str = str.slice(0, e) + '.' + str.slice(e);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// EXPORT\r\n\r\n\r\nexport var BigNumber = clone();\r\n\r\nexport default BigNumber;\r\n","export const encodeDecode = (layout) => {\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    return { decode, encode };\n};\n//# sourceMappingURL=base.js.map","import { blob } from '@solana/buffer-layout';\nimport { toBigIntBE, toBigIntLE, toBufferBE, toBufferLE } from 'bigint-buffer';\nimport { encodeDecode } from './base.mjs';\nexport const bigInt = (length) => (property) => {\n    const layout = blob(length, property);\n    const { encode, decode } = encodeDecode(layout);\n    const bigIntLayout = layout;\n    bigIntLayout.decode = (buffer, offset) => {\n        const src = decode(buffer, offset);\n        return toBigIntLE(Buffer.from(src));\n    };\n    bigIntLayout.encode = (bigInt, buffer, offset) => {\n        const src = toBufferLE(bigInt, length);\n        return encode(src, buffer, offset);\n    };\n    return bigIntLayout;\n};\nexport const bigIntBE = (length) => (property) => {\n    const layout = blob(length, property);\n    const { encode, decode } = encodeDecode(layout);\n    const bigIntLayout = layout;\n    bigIntLayout.decode = (buffer, offset) => {\n        const src = decode(buffer, offset);\n        return toBigIntBE(Buffer.from(src));\n    };\n    bigIntLayout.encode = (bigInt, buffer, offset) => {\n        const src = toBufferBE(bigInt, length);\n        return encode(src, buffer, offset);\n    };\n    return bigIntLayout;\n};\nexport const u64 = bigInt(8);\nexport const u64be = bigIntBE(8);\nexport const u128 = bigInt(16);\nexport const u128be = bigIntBE(16);\nexport const u192 = bigInt(24);\nexport const u192be = bigIntBE(24);\nexport const u256 = bigInt(32);\nexport const u256be = bigIntBE(32);\n//# sourceMappingURL=bigint.js.map","import type { Codec } from '@solana/codecs';\nimport {\n    addCodecSizePrefix,\n    getU32Codec,\n    getUtf8Codec,\n    getStructCodec,\n    getTupleCodec,\n    getUnitCodec,\n} from '@solana/codecs';\n\nexport enum Field {\n    Name,\n    Symbol,\n    Uri,\n}\n\ntype FieldLayout = { __kind: 'Name' } | { __kind: 'Symbol' } | { __kind: 'Uri' } | { __kind: 'Key'; value: [string] };\n\nexport const getFieldCodec = () =>\n    [\n        ['Name', getUnitCodec()],\n        ['Symbol', getUnitCodec()],\n        ['Uri', getUnitCodec()],\n        ['Key', getStructCodec([['value', getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n    ] as const;\n\nexport function getFieldConfig(field: Field | string): FieldLayout {\n    if (field === Field.Name || field === 'Name' || field === 'name') {\n        return { __kind: 'Name' };\n    } else if (field === Field.Symbol || field === 'Symbol' || field === 'symbol') {\n        return { __kind: 'Symbol' };\n    } else if (field === Field.Uri || field === 'Uri' || field === 'uri') {\n        return { __kind: 'Uri' };\n    } else {\n        return { __kind: 'Key', value: [field] };\n    }\n}\n","import { struct, u16, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, Signer, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { COptionPublicKeyLayout } from '../../serialization.js';\n\nexport enum TransferFeeInstruction {\n    InitializeTransferFeeConfig = 0,\n    TransferCheckedWithFee = 1,\n    WithdrawWithheldTokensFromMint = 2,\n    WithdrawWithheldTokensFromAccounts = 3,\n    HarvestWithheldTokensToMint = 4,\n    SetTransferFee = 5,\n}\n\n// InitializeTransferFeeConfig\n\n/** TODO: docs */\nexport interface InitializeTransferFeeConfigInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n    transferFeeConfigAuthority: PublicKey | null;\n    withdrawWithheldAuthority: PublicKey | null;\n    transferFeeBasisPoints: number;\n    maximumFee: bigint;\n}\n\n/** TODO: docs */\nexport const initializeTransferFeeConfigInstructionData = struct<InitializeTransferFeeConfigInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    new COptionPublicKeyLayout('transferFeeConfigAuthority'),\n    new COptionPublicKeyLayout('withdrawWithheldAuthority'),\n    u16('transferFeeBasisPoints'),\n    u64('maximumFee'),\n]);\n\n/**\n * Construct an InitializeTransferFeeConfig instruction\n *\n * @param mint            Token mint account\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee        Maximum fee assessed on transfers\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferFeeConfigInstruction(\n    mint: PublicKey,\n    transferFeeConfigAuthority: PublicKey | null,\n    withdrawWithheldAuthority: PublicKey | null,\n    transferFeeBasisPoints: number,\n    maximumFee: bigint,\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(78); // worst-case size\n    initializeTransferFeeConfigInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n            transferFeeConfigAuthority: transferFeeConfigAuthority,\n            withdrawWithheldAuthority: withdrawWithheldAuthority,\n            transferFeeBasisPoints: transferFeeBasisPoints,\n            maximumFee: maximumFee,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeTransferFeeConfigInstructionData.getSpan(data)),\n    });\n}\n\n/** A decoded, valid InitializeTransferFeeConfig instruction */\nexport interface DecodedInitializeTransferFeeConfigInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n        transferFeeConfigAuthority: PublicKey | null;\n        withdrawWithheldAuthority: PublicKey | null;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an InitializeTransferFeeConfig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeTransferFeeConfigInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedInitializeTransferFeeConfigInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeTransferFeeConfigInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeTransferFeeConfig instruction */\nexport interface DecodedInitializeTransferFeeConfigInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n        transferFeeConfigAuthority: PublicKey | null;\n        withdrawWithheldAuthority: PublicKey | null;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an InitializeTransferFeeConfig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeTransferFeeConfigInstructionUnchecked {\n    const {\n        instruction,\n        transferFeeInstruction,\n        transferFeeConfigAuthority,\n        withdrawWithheldAuthority,\n        transferFeeBasisPoints,\n        maximumFee,\n    } = initializeTransferFeeConfigInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            transferFeeConfigAuthority,\n            withdrawWithheldAuthority,\n            transferFeeBasisPoints,\n            maximumFee,\n        },\n    };\n}\n\n// TransferCheckedWithFee\nexport interface TransferCheckedWithFeeInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n    amount: bigint;\n    decimals: number;\n    fee: bigint;\n}\n\nexport const transferCheckedWithFeeInstructionData = struct<TransferCheckedWithFeeInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u64('amount'),\n    u8('decimals'),\n    u64('fee'),\n]);\n\n/**\n * Construct an TransferCheckedWithFee instruction\n *\n * @param source          The source account\n * @param mint            The token mint\n * @param destination     The destination account\n * @param authority       The source account's owner/delegate\n * @param signers         The signer account(s)\n * @param amount          The amount of tokens to transfer\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedWithFeeInstruction(\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\n    transferCheckedWithFeeInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n            amount,\n            decimals,\n            fee,\n        },\n        data,\n    );\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners,\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid TransferCheckedWithFee instruction */\nexport interface DecodedTransferCheckedWithFeeInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n        amount: bigint;\n        decimals: number;\n        fee: bigint;\n    };\n}\n\n/**\n * Decode a TransferCheckedWithFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedWithFeeInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedTransferCheckedWithFeeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedWithFeeInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, mint, destination, authority, signers },\n        data,\n    } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated TransferCheckedWithFees instruction */\nexport interface DecodedTransferCheckedWithFeeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n        amount: bigint;\n        decimals: number;\n        fee: bigint;\n    };\n}\n\n/**\n * Decode a TransferCheckedWithFees instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedWithFeeInstructionUnchecked({\n    programId,\n    keys: [source, mint, destination, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedTransferCheckedWithFeeInstructionUnchecked {\n    const { instruction, transferFeeInstruction, amount, decimals, fee } =\n        transferCheckedWithFeeInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            amount,\n            decimals,\n            fee,\n        },\n    };\n}\n\n// WithdrawWithheldTokensFromMint\nexport interface WithdrawWithheldTokensFromMintInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n}\n\nexport const withdrawWithheldTokensFromMintInstructionData = struct<WithdrawWithheldTokensFromMintInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n\n/**\n * Construct a WithdrawWithheldTokensFromMint instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromMintInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    signers: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\n    withdrawWithheldTokensFromMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint,\n        },\n        data,\n    );\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        signers,\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\nexport interface DecodedWithdrawWithheldTokensFromMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedWithdrawWithheldTokensFromMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, signers },\n        data,\n    } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\nexport interface DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\n    const { instruction, transferFeeInstruction } = withdrawWithheldTokensFromMintInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n\n// WithdrawWithheldTokensFromAccounts\nexport interface WithdrawWithheldTokensFromAccountsInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n    numTokenAccounts: number;\n}\n\nexport const withdrawWithheldTokensFromAccountsInstructionData =\n    struct<WithdrawWithheldTokensFromAccountsInstructionData>([\n        u8('instruction'),\n        u8('transferFeeInstruction'),\n        u8('numTokenAccounts'),\n    ]);\n\n/**\n * Construct a WithdrawWithheldTokensFromAccounts instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromAccountsInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    signers: (Signer | PublicKey)[],\n    sources: PublicKey[],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\n    withdrawWithheldTokensFromAccountsInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n            numTokenAccounts: sources.length,\n        },\n        data,\n    );\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        signers,\n    );\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n        numTokenAccounts: number;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedWithdrawWithheldTokensFromAccountsInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, signers, sources },\n        data,\n    } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n            sources: sources ? sources : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n        numTokenAccounts: number;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({\n    programId,\n    keys,\n    data,\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\n    const { instruction, transferFeeInstruction, numTokenAccounts } =\n        withdrawWithheldTokensFromAccountsInstructionData.decode(data);\n    const [mint, destination, authority, signers, sources] = [\n        keys[0],\n        keys[1],\n        keys[2],\n        keys.slice(3, 3 + numTokenAccounts),\n        keys.slice(-1 * numTokenAccounts),\n    ];\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            numTokenAccounts,\n        },\n    };\n}\n\n// HarvestWithheldTokensToMint\n\nexport interface HarvestWithheldTokensToMintInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n}\n\nexport const harvestWithheldTokensToMintInstructionData = struct<HarvestWithheldTokensToMintInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n\n/**\n * Construct a HarvestWithheldTokensToMint instruction\n *\n * @param mint              The token mint\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createHarvestWithheldTokensToMintInstruction(\n    mint: PublicKey,\n    sources: PublicKey[],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\n    harvestWithheldTokensToMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint,\n        },\n        data,\n    );\n    const keys: AccountMeta[] = [];\n    keys.push({ pubkey: mint, isSigner: false, isWritable: true });\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\nexport interface DecodedHarvestWithheldTokensToMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n    };\n}\n\n/**\n * Decode a HarvestWithheldTokensToMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedHarvestWithheldTokensToMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, sources },\n        data,\n    } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\nexport interface DecodedHarvestWithheldTokensToMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n    };\n}\n\n/**\n * Decode a HarvestWithheldTokensToMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked({\n    programId,\n    keys: [mint, ...sources],\n    data,\n}: TransactionInstruction): DecodedHarvestWithheldTokensToMintInstructionUnchecked {\n    const { instruction, transferFeeInstruction } = harvestWithheldTokensToMintInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n\n// SetTransferFee\n\nexport interface SetTransferFeeInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.SetTransferFee;\n    transferFeeBasisPoints: number;\n    maximumFee: bigint;\n}\n\nexport const setTransferFeeInstructionData = struct<SetTransferFeeInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u16('transferFeeBasisPoints'),\n    u64('maximumFee'),\n]);\n\n/**\n * Construct a SetTransferFeeInstruction instruction\n *\n * @param mint                      The token mint\n * @param authority                 The authority of the transfer fee\n * @param signers                   The signer account(s)\n * @param transferFeeBasisPoints    Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee                Maximum fee assessed on transfers\n * @param programID                 SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSetTransferFeeInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    signers: (Signer | PublicKey)[],\n    transferFeeBasisPoints: number,\n    maximumFee: bigint,\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const data = Buffer.alloc(setTransferFeeInstructionData.span);\n    setTransferFeeInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.SetTransferFee,\n            transferFeeBasisPoints: transferFeeBasisPoints,\n            maximumFee: maximumFee,\n        },\n        data,\n    );\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, signers);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid SetTransferFee instruction */\nexport interface DecodedSetTransferFeeInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.SetTransferFee;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an SetTransferFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSetTransferFeeInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedSetTransferFeeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== setTransferFeeInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, authority, signers },\n        data,\n    } = decodeSetTransferFeeInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.SetTransferFee\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid SetTransferFee instruction */\nexport interface DecodedSetTransferFeeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.SetTransferFee;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode a SetTransferFee instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSetTransferFeeInstructionUnchecked({\n    programId,\n    keys: [mint, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedSetTransferFeeInstructionUnchecked {\n    const { instruction, transferFeeInstruction, transferFeeBasisPoints, maximumFee } =\n        setTransferFeeInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            transferFeeBasisPoints,\n            maximumFee,\n        },\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface BurnCheckedInstructionData {\n    instruction: TokenInstruction.BurnChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const burnCheckedInstructionData = struct<BurnCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a BurnChecked instruction\n *\n * @param mint         Mint for the account\n * @param account      Account to burn tokens from\n * @param owner        Owner of the account\n * @param amount       Number of tokens to burn\n * @param decimals     Number of decimals in burn amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createBurnCheckedInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(burnCheckedInstructionData.span);\n    burnCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.BurnChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid BurnChecked instruction */\nexport interface DecodedBurnCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.BurnChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a BurnChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeBurnCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedBurnCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== burnCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, multiSigners },\n        data,\n    } = decodeBurnCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.BurnChecked) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated BurnChecked instruction */\nexport interface DecodedBurnCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a BurnChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeBurnCheckedInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedBurnCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data: burnCheckedInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface MintToCheckedInstructionData {\n    instruction: TokenInstruction.MintToChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const mintToCheckedInstructionData = struct<MintToCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a MintToChecked instruction\n *\n * @param mint         Public key of the mint\n * @param destination  Address of the token account to mint to\n * @param authority    The mint authority\n * @param amount       Amount to mint\n * @param decimals     Number of decimals in amount to mint\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createMintToCheckedInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(mintToCheckedInstructionData.span);\n    mintToCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.MintToChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid MintToChecked instruction */\nexport interface DecodedMintToCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.MintToChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a MintToChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeMintToCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedMintToCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== mintToCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, multiSigners },\n        data,\n    } = decodeMintToCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.MintToChecked) throw new TokenInvalidInstructionTypeError();\n    if (!mint || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated MintToChecked instruction */\nexport interface DecodedMintToCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a MintToChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeMintToCheckedInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedMintToCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: mintToCheckedInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface ApproveCheckedInstructionData {\n    instruction: TokenInstruction.ApproveChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const approveCheckedInstructionData = struct<ApproveCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct an ApproveChecked instruction\n *\n * @param account      Account to set the delegate for\n * @param mint         Mint account\n * @param delegate     Account authorized to transfer of tokens from the account\n * @param owner        Owner of the account\n * @param amount       Maximum number of tokens the delegate may transfer\n * @param decimals     Number of decimals in approve amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createApproveCheckedInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: delegate, isSigner: false, isWritable: false },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(approveCheckedInstructionData.span);\n    approveCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.ApproveChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid ApproveChecked instruction */\nexport interface DecodedApproveCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        delegate: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.ApproveChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode an ApproveChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeApproveCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedApproveCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== approveCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, delegate, owner, multiSigners },\n        data,\n    } = decodeApproveCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.ApproveChecked) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !delegate || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated ApproveChecked instruction */\nexport interface DecodedApproveCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        delegate: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode an ApproveChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeApproveCheckedInstructionUnchecked({\n    programId,\n    keys: [account, mint, delegate, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedApproveCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data: approveCheckedInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface BurnInstructionData {\n    instruction: TokenInstruction.Burn;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const burnInstructionData = struct<BurnInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct a Burn instruction\n *\n * @param account      Account to burn tokens from\n * @param mint         Mint for the account\n * @param owner        Owner of the account\n * @param amount       Number of tokens to burn\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createBurnInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(burnInstructionData.span);\n    burnInstructionData.encode(\n        {\n            instruction: TokenInstruction.Burn,\n            amount: BigInt(amount),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Burn instruction */\nexport interface DecodedBurnInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Burn;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Burn instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeBurnInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedBurnInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== burnInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, multiSigners },\n        data,\n    } = decodeBurnInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Burn) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Burn instruction */\nexport interface DecodedBurnInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Burn instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeBurnInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedBurnInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            multiSigners,\n        },\n        data: burnInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface AmountToUiAmountInstructionData {\n    instruction: TokenInstruction.AmountToUiAmount;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const amountToUiAmountInstructionData = struct<AmountToUiAmountInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n]);\n\n/**\n * Construct a AmountToUiAmount instruction\n *\n * @param mint         Public key of the mint\n * @param amount       Amount of tokens to be converted to UiAmount\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAmountToUiAmountInstruction(\n    mint: PublicKey,\n    amount: number | bigint,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];\n\n    const data = Buffer.alloc(amountToUiAmountInstructionData.span);\n    amountToUiAmountInstructionData.encode(\n        {\n            instruction: TokenInstruction.AmountToUiAmount,\n            amount: BigInt(amount),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid AmountToUiAmount instruction */\nexport interface DecodedAmountToUiAmountInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.AmountToUiAmount;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a AmountToUiAmount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeAmountToUiAmountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedAmountToUiAmountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== amountToUiAmountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeAmountToUiAmountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.AmountToUiAmount) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated AmountToUiAmount instruction */\nexport interface DecodedAmountToUiAmountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a AmountToUiAmount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeAmountToUiAmountInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedAmountToUiAmountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: amountToUiAmountInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface TransferCheckedInstructionData {\n    instruction: TokenInstruction.TransferChecked;\n    amount: bigint;\n    decimals: number;\n}\n\n/** TODO: docs */\nexport const transferCheckedInstructionData = struct<TransferCheckedInstructionData>([\n    u8('instruction'),\n    u64('amount'),\n    u8('decimals'),\n]);\n\n/**\n * Construct a TransferChecked instruction\n *\n * @param source       Source account\n * @param mint         Mint account\n * @param destination  Destination account\n * @param owner        Owner of the source account\n * @param amount       Number of tokens to transfer\n * @param decimals     Number of decimals in transfer amount\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedInstruction(\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(transferCheckedInstructionData.span);\n    transferCheckedInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferChecked,\n            amount: BigInt(amount),\n            decimals,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid TransferChecked instruction */\nexport interface DecodedTransferCheckedInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.TransferChecked;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a TransferChecked instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedTransferCheckedInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, mint, destination, owner, multiSigners },\n        data,\n    } = decodeTransferCheckedInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.TransferChecked) throw new TokenInvalidInstructionTypeError();\n    if (!source || !mint || !destination || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated TransferChecked instruction */\nexport interface DecodedTransferCheckedInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n        decimals: number;\n    };\n}\n\n/**\n * Decode a TransferChecked instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedInstructionUnchecked({\n    programId,\n    keys: [source, mint, destination, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedTransferCheckedInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data: transferCheckedInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface MintToInstructionData {\n    instruction: TokenInstruction.MintTo;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const mintToInstructionData = struct<MintToInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct a MintTo instruction\n *\n * @param mint         Public key of the mint\n * @param destination  Address of the token account to mint to\n * @param authority    The mint authority\n * @param amount       Amount to mint\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createMintToInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: number | bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(mintToInstructionData.span);\n    mintToInstructionData.encode(\n        {\n            instruction: TokenInstruction.MintTo,\n            amount: BigInt(amount),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid MintTo instruction */\nexport interface DecodedMintToInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.MintTo;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a MintTo instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeMintToInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedMintToInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== mintToInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, multiSigners },\n        data,\n    } = decodeMintToInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.MintTo) throw new TokenInvalidInstructionTypeError();\n    if (!mint || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated MintTo instruction */\nexport interface DecodedMintToInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a MintTo instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeMintToInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedMintToInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: mintToInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface ApproveInstructionData {\n    instruction: TokenInstruction.Approve;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const approveInstructionData = struct<ApproveInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct an Approve instruction\n *\n * @param account      Account to set the delegate for\n * @param delegate     Account authorized to transfer tokens from the account\n * @param owner        Owner of the account\n * @param amount       Maximum number of tokens the delegate may transfer\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createApproveInstruction(\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: delegate, isSigner: false, isWritable: false },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(approveInstructionData.span);\n    approveInstructionData.encode(\n        {\n            instruction: TokenInstruction.Approve,\n            amount: BigInt(amount),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Approve instruction */\nexport interface DecodedApproveInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        delegate: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Approve;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode an Approve instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeApproveInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedApproveInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== approveInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, delegate, owner, multiSigners },\n        data,\n    } = decodeApproveInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Approve) throw new TokenInvalidInstructionTypeError();\n    if (!account || !delegate || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Approve instruction */\nexport interface DecodedApproveInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        delegate: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode an Approve instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeApproveInstructionUnchecked({\n    programId,\n    keys: [account, delegate, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedApproveInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            delegate,\n            owner,\n            multiSigners,\n        },\n        data: approveInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface TransferInstructionData {\n    instruction: TokenInstruction.Transfer;\n    amount: bigint;\n}\n\n/** TODO: docs */\nexport const transferInstructionData = struct<TransferInstructionData>([u8('instruction'), u64('amount')]);\n\n/**\n * Construct a Transfer instruction\n *\n * @param source       Source account\n * @param destination  Destination account\n * @param owner        Owner of the source account\n * @param amount       Number of tokens to transfer\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferInstruction(\n    source: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: source, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        owner,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(transferInstructionData.span);\n    transferInstructionData.encode(\n        {\n            instruction: TokenInstruction.Transfer,\n            amount: BigInt(amount),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Transfer instruction */\nexport interface DecodedTransferInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        destination: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Transfer;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Transfer instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedTransferInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, destination, owner, multiSigners },\n        data,\n    } = decodeTransferInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Transfer) throw new TokenInvalidInstructionTypeError();\n    if (!source || !destination || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            source,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Transfer instruction */\nexport interface DecodedTransferInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        amount: bigint;\n    };\n}\n\n/**\n * Decode a Transfer instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferInstructionUnchecked({\n    programId,\n    keys: [source, destination, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedTransferInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            source,\n            destination,\n            owner,\n            multiSigners,\n        },\n        data: transferInstructionData.decode(data),\n    };\n}\n","/** Base class for errors */\nexport abstract class TokenError extends Error {\n    constructor(message?: string) {\n        super(message);\n    }\n}\n\n/** Thrown if an account is not found at the expected address */\nexport class TokenAccountNotFoundError extends TokenError {\n    name = 'TokenAccountNotFoundError';\n}\n\n/** Thrown if a program state account is not a valid Account */\nexport class TokenInvalidAccountError extends TokenError {\n    name = 'TokenInvalidAccountError';\n}\n\n/** Thrown if a program state account does not contain valid data */\nexport class TokenInvalidAccountDataError extends TokenError {\n    name = 'TokenInvalidAccountDataError';\n}\n\n/** Thrown if a program state account is not owned by the expected token program */\nexport class TokenInvalidAccountOwnerError extends TokenError {\n    name = 'TokenInvalidAccountOwnerError';\n}\n\n/** Thrown if the byte length of an program state account doesn't match the expected size */\nexport class TokenInvalidAccountSizeError extends TokenError {\n    name = 'TokenInvalidAccountSizeError';\n}\n\n/** Thrown if the mint of a token account doesn't match the expected mint */\nexport class TokenInvalidMintError extends TokenError {\n    name = 'TokenInvalidMintError';\n}\n\n/** Thrown if the owner of a token account doesn't match the expected owner */\nexport class TokenInvalidOwnerError extends TokenError {\n    name = 'TokenInvalidOwnerError';\n}\n\n/** Thrown if the owner of a token account is a PDA (Program Derived Address) */\nexport class TokenOwnerOffCurveError extends TokenError {\n    name = 'TokenOwnerOffCurveError';\n}\n\n/** Thrown if an instruction's program is invalid */\nexport class TokenInvalidInstructionProgramError extends TokenError {\n    name = 'TokenInvalidInstructionProgramError';\n}\n\n/** Thrown if an instruction's keys are invalid */\nexport class TokenInvalidInstructionKeysError extends TokenError {\n    name = 'TokenInvalidInstructionKeysError';\n}\n\n/** Thrown if an instruction's data is invalid */\nexport class TokenInvalidInstructionDataError extends TokenError {\n    name = 'TokenInvalidInstructionDataError';\n}\n\n/** Thrown if an instruction's type is invalid */\nexport class TokenInvalidInstructionTypeError extends TokenError {\n    name = 'TokenInvalidInstructionTypeError';\n}\n\n/** Thrown if the program does not support the desired instruction */\nexport class TokenUnsupportedInstructionError extends TokenError {\n    name = 'TokenUnsupportedInstructionError';\n}\n\n/** Thrown if the transfer hook extra accounts contains an invalid account index */\nexport class TokenTransferHookAccountNotFound extends TokenError {\n    name = 'TokenTransferHookAccountNotFound';\n}\n\n/** Thrown if the transfer hook extra accounts contains an invalid seed */\nexport class TokenTransferHookInvalidSeed extends TokenError {\n    name = 'TokenTransferHookInvalidSeed';\n}\n\n/** Thrown if account data required by an extra account meta seed config could not be fetched */\nexport class TokenTransferHookAccountDataNotFound extends TokenError {\n    name = 'TokenTransferHookAccountDataNotFound';\n}\n\n/** Thrown if pubkey data extra accounts config is invalid */\nexport class TokenTransferHookInvalidPubkeyData extends TokenError {\n    name = 'TokenTransferHookInvalidPubkeyData';\n}\n\n/** Thrown if pubkey data source is too small for a pubkey */\nexport class TokenTransferHookPubkeyDataTooSmall extends TokenError {\n    name = 'TokenTransferHookPubkeyDataTooSmall';\n}\n","export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n","export * from './instructions.js';\nexport * from './state.js';\n","export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n","export * from './actions.js';\nexport * from './state.js';\n","export * from './instructions.js';\nexport * from './state.js';\n","export * from './amountToUiAmount.js';\nexport * from './approve.js';\nexport * from './approveChecked.js';\nexport * from './burn.js';\nexport * from './burnChecked.js';\nexport * from './closeAccount.js';\nexport * from './createAccount.js';\nexport * from './createAssociatedTokenAccount.js';\nexport * from './createAssociatedTokenAccountIdempotent.js';\nexport * from './createMint.js';\nexport * from './createMultisig.js';\nexport * from './createNativeMint.js';\nexport * from './createWrappedNativeAccount.js';\nexport * from './freezeAccount.js';\nexport * from './getOrCreateAssociatedTokenAccount.js';\nexport * from './mintTo.js';\nexport * from './mintToChecked.js';\nexport * from './recoverNested.js';\nexport * from './revoke.js';\nexport * from './setAuthority.js';\nexport * from './syncNative.js';\nexport * from './thawAccount.js';\nexport * from './transfer.js';\nexport * from './transferChecked.js';\nexport * from './uiAmountToAmount.js';\n","export * from './accountType.js';\nexport * from './cpiGuard/index.js';\nexport * from './defaultAccountState/index.js';\nexport * from './extensionType.js';\nexport * from './groupMemberPointer/index.js';\nexport * from './groupPointer/index.js';\nexport * from './immutableOwner.js';\nexport * from './interestBearingMint/index.js';\nexport * from './memoTransfer/index.js';\nexport * from './metadataPointer/index.js';\nexport * from './scaledUiAmount/index.js';\nexport * from './tokenGroup/index.js';\nexport * from './tokenMetadata/index.js';\nexport * from './mintCloseAuthority.js';\nexport * from './nonTransferable.js';\nexport * from './transferFee/index.js';\nexport * from './permanentDelegate.js';\nexport * from './transferHook/index.js';\nexport * from './pausable/index.js';\n","export * from './actions.js';\nexport * from './state.js';\n","export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n","export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n","export * from './base';\nexport * from './bigint';\nexport * from './decimal';\nexport * from './native';\nexport * from './web3';\n","export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n","export * from './instructions.js';\nexport * from './state.js';\n","export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n","export * from './actions.js';\nexport * from './instructions.js';\nexport * from './state.js';\n","export * from './actions/index.js';\nexport * from './constants.js';\nexport * from './errors.js';\nexport * from './extensions/index.js';\nexport * from './instructions/index.js';\nexport * from './state/index.js';\n","export * from './actions.js';\nexport * from './instructions.js';\nexport * from './seeds.js';\nexport * from './state.js';\nexport * from './pubkeyData.js';\n","export * from './account.js';\nexport * from './mint.js';\nexport * from './multisig.js';\n","import { struct } from '@solana/buffer-layout';\nimport { bool } from '@solana/buffer-layout-utils';\nimport type { Account } from '../../state/account.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** CpiGuard as stored by the program */\nexport interface CpiGuard {\n    /** Lock certain token operations from taking place within CPI for this account */\n    lockCpi: boolean;\n}\n\n/** Buffer layout for de/serializing a CPI Guard extension */\nexport const CpiGuardLayout = struct<CpiGuard>([bool('lockCpi')]);\n\nexport const CPI_GUARD_SIZE = CpiGuardLayout.span;\n\nexport function getCpiGuard(account: Account): CpiGuard | null {\n    const extensionData = getExtensionData(ExtensionType.CpiGuard, account.tlvData);\n    if (extensionData !== null) {\n        return CpiGuardLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n","import { struct } from '@solana/buffer-layout';\nimport { bool } from '@solana/buffer-layout-utils';\nimport type { Account } from '../../state/account.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** MemoTransfer as stored by the program */\nexport interface MemoTransfer {\n    /** Require transfers into this account to be accompanied by a memo */\n    requireIncomingTransferMemos: boolean;\n}\n\n/** Buffer layout for de/serializing a memo transfer extension */\nexport const MemoTransferLayout = struct<MemoTransfer>([bool('requireIncomingTransferMemos')]);\n\nexport const MEMO_TRANSFER_SIZE = MemoTransferLayout.span;\n\nexport function getMemoTransfer(account: Account): MemoTransfer | null {\n    const extensionData = getExtensionData(ExtensionType.MemoTransfer, account.tlvData);\n    if (extensionData !== null) {\n        return MemoTransferLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n","import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { AccountInfo, Commitment, Connection } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidAccountSizeError,\n    TokenInvalidMintError,\n    TokenOwnerOffCurveError,\n} from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport type { ExtensionType } from '../extensions/extensionType.js';\nimport { getMintLen } from '../extensions/extensionType.js';\nimport { ACCOUNT_SIZE } from './account.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n\n/** Information about a mint */\nexport interface Mint {\n    /** Address of the mint */\n    address: PublicKey;\n    /**\n     * Optional authority used to mint new tokens. The mint authority may only be provided during mint creation.\n     * If no mint authority is present then the mint has a fixed supply and no further tokens may be minted.\n     */\n    mintAuthority: PublicKey | null;\n    /** Total supply of tokens */\n    supply: bigint;\n    /** Number of base 10 digits to the right of the decimal place */\n    decimals: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Optional authority to freeze token accounts */\n    freezeAuthority: PublicKey | null;\n    /** Additional data for extension */\n    tlvData: Buffer;\n}\n\n/** Mint as stored by the program */\nexport interface RawMint {\n    mintAuthorityOption: 1 | 0;\n    mintAuthority: PublicKey;\n    supply: bigint;\n    decimals: number;\n    isInitialized: boolean;\n    freezeAuthorityOption: 1 | 0;\n    freezeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a mint */\nexport const MintLayout = struct<RawMint>([\n    u32('mintAuthorityOption'),\n    publicKey('mintAuthority'),\n    u64('supply'),\n    u8('decimals'),\n    bool('isInitialized'),\n    u32('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n\n/** Byte length of a mint */\nexport const MINT_SIZE = MintLayout.span;\n\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nexport async function getMint(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<Mint> {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackMint(address, info, programId);\n}\n\n/**\n * Unpack a mint\n *\n * @param address   Mint account\n * @param info      Mint account data\n * @param programId SPL Token program account\n *\n * @return Unpacked mint\n */\nexport function unpackMint(address: PublicKey, info: AccountInfo<Buffer> | null, programId = TOKEN_PROGRAM_ID): Mint {\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < MINT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > MINT_SIZE) {\n        if (info.data.length <= ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n        if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Mint) throw new TokenInvalidMintError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n\n    return {\n        address,\n        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n        supply: rawMint.supply,\n        decimals: rawMint.decimals,\n        isInitialized: rawMint.isInitialized,\n        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n        tlvData,\n    };\n}\n\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMint(\n    connection: Connection,\n    commitment?: Commitment,\n): Promise<number> {\n    return await getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\n}\n\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\n *\n * @param connection Connection to use\n * @param extensions Extension types included in the mint\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMintWithExtensions(\n    connection: Connection,\n    extensions: ExtensionType[],\n    commitment?: Commitment,\n): Promise<number> {\n    const mintLen = getMintLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(mintLen, commitment);\n}\n\n/**\n * Async version of getAssociatedTokenAddressSync\n * For backwards compatibility\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Promise containing the address of the associated token account\n */\nexport async function getAssociatedTokenAddress(\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): Promise<PublicKey> {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n\n    const [address] = await PublicKey.findProgramAddress(\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\n        associatedTokenProgramId,\n    );\n\n    return address;\n}\n\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nexport function getAssociatedTokenAddressSync(\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): PublicKey {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n\n    const [address] = PublicKey.findProgramAddressSync(\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\n        associatedTokenProgramId,\n    );\n\n    return address;\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountInfo, Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors.js';\n\n/** Information about a multisig */\nexport interface Multisig {\n    /** Address of the multisig */\n    address: PublicKey;\n    /** Number of signers required */\n    m: number;\n    /** Number of possible signers, corresponds to the number of `signers` that are valid */\n    n: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Full set of signers, of which `n` are valid */\n    signer1: PublicKey;\n    signer2: PublicKey;\n    signer3: PublicKey;\n    signer4: PublicKey;\n    signer5: PublicKey;\n    signer6: PublicKey;\n    signer7: PublicKey;\n    signer8: PublicKey;\n    signer9: PublicKey;\n    signer10: PublicKey;\n    signer11: PublicKey;\n}\n\n/** Multisig as stored by the program */\nexport type RawMultisig = Omit<Multisig, 'address'>;\n\n/** Buffer layout for de/serializing a multisig */\nexport const MultisigLayout = struct<RawMultisig>([\n    u8('m'),\n    u8('n'),\n    bool('isInitialized'),\n    publicKey('signer1'),\n    publicKey('signer2'),\n    publicKey('signer3'),\n    publicKey('signer4'),\n    publicKey('signer5'),\n    publicKey('signer6'),\n    publicKey('signer7'),\n    publicKey('signer8'),\n    publicKey('signer9'),\n    publicKey('signer10'),\n    publicKey('signer11'),\n]);\n\n/** Byte length of a multisig */\nexport const MULTISIG_SIZE = MultisigLayout.span;\n\n/**\n * Retrieve information about a multisig\n *\n * @param connection Connection to use\n * @param address    Multisig account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Multisig information\n */\nexport async function getMultisig(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<Multisig> {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackMultisig(address, info, programId);\n}\n\n/**\n * Unpack a multisig\n *\n * @param address   Multisig account\n * @param info      Multisig account data\n * @param programId SPL Token program account\n *\n * @return Unpacked multisig\n */\nexport function unpackMultisig(\n    address: PublicKey,\n    info: AccountInfo<Buffer> | null,\n    programId = TOKEN_PROGRAM_ID,\n): Multisig {\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const multisig = MultisigLayout.decode(info.data);\n\n    return { address, ...multisig };\n}\n\n/** Get the minimum lamport balance for a multisig to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMultisig(\n    connection: Connection,\n    commitment?: Commitment,\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\n}\n","import type { Signer } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\n\n/** @internal */\nexport function getSigners(signerOrMultisig: Signer | PublicKey, multiSigners: Signer[]): [PublicKey, Signer[]] {\n    return signerOrMultisig instanceof PublicKey\n        ? [signerOrMultisig, multiSigners]\n        : [signerOrMultisig.publicKey, [signerOrMultisig]];\n}\n","import { Layout } from '@solana/buffer-layout';\n\nexport interface EncodeDecode<T> {\n    decode(buffer: Buffer, offset?: number): T;\n    encode(src: T, buffer: Buffer, offset?: number): number;\n}\n\nexport const encodeDecode = <T>(layout: Layout<T>): EncodeDecode<T> => {\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    return { decode, encode };\n};\n","import type { AccountMeta, Signer } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\n\n/** @internal */\nexport function addSigners(\n    keys: AccountMeta[],\n    ownerOrAuthority: PublicKey,\n    multiSigners: (Signer | PublicKey)[],\n): AccountMeta[] {\n    if (multiSigners.length) {\n        keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });\n        for (const signer of multiSigners) {\n            keys.push({\n                pubkey: signer instanceof PublicKey ? signer : signer.publicKey,\n                isSigner: true,\n                isWritable: false,\n            });\n        }\n    } else {\n        keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });\n    }\n    return keys;\n}\n","import { s16, struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum InterestBearingMintInstruction {\n    Initialize = 0,\n    UpdateRate = 1,\n}\n\nexport interface InterestBearingMintInitializeInstructionData {\n    instruction: TokenInstruction.InterestBearingMintExtension;\n    interestBearingMintInstruction: InterestBearingMintInstruction.Initialize;\n    rateAuthority: PublicKey;\n    rate: number;\n}\n\nexport interface InterestBearingMintUpdateRateInstructionData {\n    instruction: TokenInstruction.InterestBearingMintExtension;\n    interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate;\n    rate: number;\n}\n\nexport const interestBearingMintInitializeInstructionData = struct<InterestBearingMintInitializeInstructionData>([\n    u8('instruction'),\n    u8('interestBearingMintInstruction'),\n    // TODO: Make this an optional public key\n    publicKey('rateAuthority'),\n    s16('rate'),\n]);\n\nexport const interestBearingMintUpdateRateInstructionData = struct<InterestBearingMintUpdateRateInstructionData>([\n    u8('instruction'),\n    u8('interestBearingMintInstruction'),\n    s16('rate'),\n]);\n\n/**\n * Construct an InitializeInterestBearingMint instruction\n *\n * @param mint           Mint to initialize\n * @param rateAuthority  The public key for the account that can update the rate\n * @param rate           The initial interest rate\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeInterestBearingMintInstruction(\n    mint: PublicKey,\n    rateAuthority: PublicKey,\n    rate: number,\n    programId = TOKEN_2022_PROGRAM_ID,\n) {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(interestBearingMintInitializeInstructionData.span);\n    interestBearingMintInitializeInstructionData.encode(\n        {\n            instruction: TokenInstruction.InterestBearingMintExtension,\n            interestBearingMintInstruction: InterestBearingMintInstruction.Initialize,\n            rateAuthority,\n            rate,\n        },\n        data,\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/**\n * Construct an UpdateRateInterestBearingMint instruction\n *\n * @param mint           Mint to initialize\n * @param rateAuthority  The public key for the account that can update the rate\n * @param rate           The updated interest rate\n * @param multiSigners   Signing accounts if `rateAuthority` is a multisig\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateRateInterestBearingMintInstruction(\n    mint: PublicKey,\n    rateAuthority: PublicKey,\n    rate: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n) {\n    const keys = addSigners(\n        [\n            { pubkey: mint, isSigner: false, isWritable: true },\n            { pubkey: rateAuthority, isSigner: !multiSigners.length, isWritable: false },\n        ],\n        rateAuthority,\n        multiSigners,\n    );\n    const data = Buffer.alloc(interestBearingMintUpdateRateInstructionData.span);\n    interestBearingMintUpdateRateInstructionData.encode(\n        {\n            instruction: TokenInstruction.InterestBearingMintExtension,\n            interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate,\n            rate,\n        },\n        data,\n    );\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n\n/** TODO: docs */\nexport interface InitializeMintInstructionData {\n    instruction: TokenInstruction.InitializeMint;\n    decimals: number;\n    mintAuthority: PublicKey;\n    freezeAuthority: PublicKey | null;\n}\n\n/** TODO: docs */\nexport const initializeMintInstructionData = struct<InitializeMintInstructionData>([\n    u8('instruction'),\n    u8('decimals'),\n    publicKey('mintAuthority'),\n    new COptionPublicKeyLayout('freezeAuthority'),\n]);\n\n/**\n * Construct an InitializeMint instruction\n *\n * @param mint            Token mint account\n * @param decimals        Number of decimals in token account amounts\n * @param mintAuthority   Minting authority\n * @param freezeAuthority Optional authority that can freeze token accounts\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMintInstruction(\n    mint: PublicKey,\n    decimals: number,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n\n    const data = Buffer.alloc(67); // worst-case size\n    initializeMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMint,\n            decimals,\n            mintAuthority,\n            freezeAuthority,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeMintInstructionData.getSpan(data)),\n    });\n}\n\n/** A decoded, valid InitializeMint instruction */\nexport interface DecodedInitializeMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        rent: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMint;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMintInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMintInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, rent },\n        data,\n    } = decodeInitializeMintInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMint) throw new TokenInvalidInstructionTypeError();\n    if (!mint || !rent) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            mint,\n            rent,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMint instruction */\nexport interface DecodedInitializeMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMintInstructionUnchecked({\n    programId,\n    keys: [mint, rent],\n    data,\n}: TransactionInstruction): DecodedInitializeMintInstructionUnchecked {\n    const { instruction, decimals, mintAuthority, freezeAuthority } = initializeMintInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n            rent,\n        },\n        data: {\n            instruction,\n            decimals,\n            mintAuthority,\n            freezeAuthority,\n        },\n    };\n}\n","import { ns64, s16, struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\nexport interface InterestBearingMintConfigState {\n    rateAuthority: PublicKey;\n    initializationTimestamp: bigint;\n    preUpdateAverageRate: number;\n    lastUpdateTimestamp: bigint;\n    currentRate: number;\n}\n\nexport const InterestBearingMintConfigStateLayout = struct<InterestBearingMintConfigState>([\n    publicKey('rateAuthority'),\n    ns64('initializationTimestamp'),\n    s16('preUpdateAverageRate'),\n    ns64('lastUpdateTimestamp'),\n    s16('currentRate'),\n]);\n\nexport const INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = InterestBearingMintConfigStateLayout.span;\n\nexport function getInterestBearingMintConfigState(mint: Mint): InterestBearingMintConfigState | null {\n    const extensionData = getExtensionData(ExtensionType.InterestBearingConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return InterestBearingMintConfigStateLayout.decode(extensionData);\n    }\n    return null;\n}\n","import type { AccountInfo, PublicKey } from '@solana/web3.js';\n\nimport { ACCOUNT_SIZE } from '../state/account.js';\nimport type { Mint } from '../state/mint.js';\nimport { MINT_SIZE, unpackMint } from '../state/mint.js';\nimport { MULTISIG_SIZE } from '../state/multisig.js';\nimport { ACCOUNT_TYPE_SIZE } from './accountType.js';\nimport { CPI_GUARD_SIZE } from './cpiGuard/index.js';\nimport { DEFAULT_ACCOUNT_STATE_SIZE } from './defaultAccountState/index.js';\nimport { TOKEN_GROUP_SIZE, TOKEN_GROUP_MEMBER_SIZE } from './tokenGroup/index.js';\nimport { GROUP_MEMBER_POINTER_SIZE } from './groupMemberPointer/state.js';\nimport { GROUP_POINTER_SIZE } from './groupPointer/state.js';\nimport { IMMUTABLE_OWNER_SIZE } from './immutableOwner.js';\nimport { INTEREST_BEARING_MINT_CONFIG_STATE_SIZE } from './interestBearingMint/state.js';\nimport { MEMO_TRANSFER_SIZE } from './memoTransfer/index.js';\nimport { METADATA_POINTER_SIZE } from './metadataPointer/state.js';\nimport { MINT_CLOSE_AUTHORITY_SIZE } from './mintCloseAuthority.js';\nimport { NON_TRANSFERABLE_SIZE, NON_TRANSFERABLE_ACCOUNT_SIZE } from './nonTransferable.js';\nimport { PAUSABLE_CONFIG_SIZE, PAUSABLE_ACCOUNT_SIZE } from './pausable/index.js';\nimport { PERMANENT_DELEGATE_SIZE } from './permanentDelegate.js';\nimport { SCALED_UI_AMOUNT_CONFIG_SIZE } from './scaledUiAmount/index.js';\nimport { TRANSFER_FEE_AMOUNT_SIZE, TRANSFER_FEE_CONFIG_SIZE } from './transferFee/index.js';\nimport { TRANSFER_HOOK_ACCOUNT_SIZE, TRANSFER_HOOK_SIZE } from './transferHook/index.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../constants.js';\n\n// Sequence from https://github.com/solana-labs/solana-program-library/blob/master/token/program-2022/src/extension/mod.rs#L903\nexport enum ExtensionType {\n    Uninitialized,\n    TransferFeeConfig,\n    TransferFeeAmount,\n    MintCloseAuthority,\n    ConfidentialTransferMint,\n    ConfidentialTransferAccount,\n    DefaultAccountState,\n    ImmutableOwner,\n    MemoTransfer,\n    NonTransferable,\n    InterestBearingConfig,\n    CpiGuard,\n    PermanentDelegate,\n    NonTransferableAccount,\n    TransferHook,\n    TransferHookAccount,\n    // ConfidentialTransferFee, // Not implemented yet\n    // ConfidentialTransferFeeAmount, // Not implemented yet\n    MetadataPointer = 18, // Remove number once above extensions implemented\n    TokenMetadata = 19, // Remove number once above extensions implemented\n    GroupPointer = 20,\n    TokenGroup = 21,\n    GroupMemberPointer = 22,\n    TokenGroupMember = 23,\n    // ConfidentialMintBurn, // Not implemented yet\n    ScaledUiAmountConfig = 25,\n    PausableConfig = 26,\n    PausableAccount = 27,\n}\n\nexport const TYPE_SIZE = 2;\nexport const LENGTH_SIZE = 2;\n\nfunction addTypeAndLengthToLen(len: number): number {\n    return len + TYPE_SIZE + LENGTH_SIZE;\n}\n\nfunction isVariableLengthExtension(e: ExtensionType): boolean {\n    switch (e) {\n        case ExtensionType.TokenMetadata:\n            return true;\n        default:\n            return false;\n    }\n}\n\n// NOTE: All of these should eventually use their type's Span instead of these\n// constants.  This is provided for at least creation to work.\nexport function getTypeLen(e: ExtensionType): number {\n    switch (e) {\n        case ExtensionType.Uninitialized:\n            return 0;\n        case ExtensionType.TransferFeeConfig:\n            return TRANSFER_FEE_CONFIG_SIZE;\n        case ExtensionType.TransferFeeAmount:\n            return TRANSFER_FEE_AMOUNT_SIZE;\n        case ExtensionType.MintCloseAuthority:\n            return MINT_CLOSE_AUTHORITY_SIZE;\n        case ExtensionType.ConfidentialTransferMint:\n            return 65;\n        case ExtensionType.ConfidentialTransferAccount:\n            return 295;\n        case ExtensionType.CpiGuard:\n            return CPI_GUARD_SIZE;\n        case ExtensionType.DefaultAccountState:\n            return DEFAULT_ACCOUNT_STATE_SIZE;\n        case ExtensionType.ImmutableOwner:\n            return IMMUTABLE_OWNER_SIZE;\n        case ExtensionType.MemoTransfer:\n            return MEMO_TRANSFER_SIZE;\n        case ExtensionType.MetadataPointer:\n            return METADATA_POINTER_SIZE;\n        case ExtensionType.NonTransferable:\n            return NON_TRANSFERABLE_SIZE;\n        case ExtensionType.InterestBearingConfig:\n            return INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;\n        case ExtensionType.PermanentDelegate:\n            return PERMANENT_DELEGATE_SIZE;\n        case ExtensionType.NonTransferableAccount:\n            return NON_TRANSFERABLE_ACCOUNT_SIZE;\n        case ExtensionType.TransferHook:\n            return TRANSFER_HOOK_SIZE;\n        case ExtensionType.TransferHookAccount:\n            return TRANSFER_HOOK_ACCOUNT_SIZE;\n        case ExtensionType.GroupPointer:\n            return GROUP_POINTER_SIZE;\n        case ExtensionType.GroupMemberPointer:\n            return GROUP_MEMBER_POINTER_SIZE;\n        case ExtensionType.TokenGroup:\n            return TOKEN_GROUP_SIZE;\n        case ExtensionType.TokenGroupMember:\n            return TOKEN_GROUP_MEMBER_SIZE;\n        case ExtensionType.ScaledUiAmountConfig:\n            return SCALED_UI_AMOUNT_CONFIG_SIZE;\n        case ExtensionType.PausableConfig:\n            return PAUSABLE_CONFIG_SIZE;\n        case ExtensionType.PausableAccount:\n            return PAUSABLE_ACCOUNT_SIZE;\n        case ExtensionType.TokenMetadata:\n            throw Error(`Cannot get type length for variable extension type: ${e}`);\n        default:\n            throw Error(`Unknown extension type: ${e}`);\n    }\n}\n\nexport function isMintExtension(e: ExtensionType): boolean {\n    switch (e) {\n        case ExtensionType.TransferFeeConfig:\n        case ExtensionType.MintCloseAuthority:\n        case ExtensionType.ConfidentialTransferMint:\n        case ExtensionType.DefaultAccountState:\n        case ExtensionType.NonTransferable:\n        case ExtensionType.InterestBearingConfig:\n        case ExtensionType.PermanentDelegate:\n        case ExtensionType.TransferHook:\n        case ExtensionType.MetadataPointer:\n        case ExtensionType.TokenMetadata:\n        case ExtensionType.GroupPointer:\n        case ExtensionType.GroupMemberPointer:\n        case ExtensionType.TokenGroup:\n        case ExtensionType.TokenGroupMember:\n        case ExtensionType.ScaledUiAmountConfig:\n        case ExtensionType.PausableConfig:\n            return true;\n        case ExtensionType.Uninitialized:\n        case ExtensionType.TransferFeeAmount:\n        case ExtensionType.ConfidentialTransferAccount:\n        case ExtensionType.ImmutableOwner:\n        case ExtensionType.MemoTransfer:\n        case ExtensionType.CpiGuard:\n        case ExtensionType.NonTransferableAccount:\n        case ExtensionType.TransferHookAccount:\n        case ExtensionType.PausableAccount:\n            return false;\n        default:\n            throw Error(`Unknown extension type: ${e}`);\n    }\n}\n\nexport function isAccountExtension(e: ExtensionType): boolean {\n    switch (e) {\n        case ExtensionType.TransferFeeAmount:\n        case ExtensionType.ConfidentialTransferAccount:\n        case ExtensionType.ImmutableOwner:\n        case ExtensionType.MemoTransfer:\n        case ExtensionType.CpiGuard:\n        case ExtensionType.NonTransferableAccount:\n        case ExtensionType.TransferHookAccount:\n        case ExtensionType.PausableAccount:\n            return true;\n        case ExtensionType.Uninitialized:\n        case ExtensionType.TransferFeeConfig:\n        case ExtensionType.MintCloseAuthority:\n        case ExtensionType.ConfidentialTransferMint:\n        case ExtensionType.DefaultAccountState:\n        case ExtensionType.NonTransferable:\n        case ExtensionType.InterestBearingConfig:\n        case ExtensionType.PermanentDelegate:\n        case ExtensionType.TransferHook:\n        case ExtensionType.MetadataPointer:\n        case ExtensionType.TokenMetadata:\n        case ExtensionType.GroupPointer:\n        case ExtensionType.GroupMemberPointer:\n        case ExtensionType.TokenGroup:\n        case ExtensionType.TokenGroupMember:\n        case ExtensionType.ScaledUiAmountConfig:\n        case ExtensionType.PausableConfig:\n            return false;\n        default:\n            throw Error(`Unknown extension type: ${e}`);\n    }\n}\n\nexport function getAccountTypeOfMintType(e: ExtensionType): ExtensionType {\n    switch (e) {\n        case ExtensionType.TransferFeeConfig:\n            return ExtensionType.TransferFeeAmount;\n        case ExtensionType.ConfidentialTransferMint:\n            return ExtensionType.ConfidentialTransferAccount;\n        case ExtensionType.NonTransferable:\n            return ExtensionType.NonTransferableAccount;\n        case ExtensionType.TransferHook:\n            return ExtensionType.TransferHookAccount;\n        case ExtensionType.PausableConfig:\n            return ExtensionType.PausableAccount;\n        case ExtensionType.TransferFeeAmount:\n        case ExtensionType.ConfidentialTransferAccount:\n        case ExtensionType.CpiGuard:\n        case ExtensionType.DefaultAccountState:\n        case ExtensionType.ImmutableOwner:\n        case ExtensionType.MemoTransfer:\n        case ExtensionType.MintCloseAuthority:\n        case ExtensionType.MetadataPointer:\n        case ExtensionType.TokenMetadata:\n        case ExtensionType.Uninitialized:\n        case ExtensionType.InterestBearingConfig:\n        case ExtensionType.PermanentDelegate:\n        case ExtensionType.NonTransferableAccount:\n        case ExtensionType.TransferHookAccount:\n        case ExtensionType.GroupPointer:\n        case ExtensionType.GroupMemberPointer:\n        case ExtensionType.TokenGroup:\n        case ExtensionType.TokenGroupMember:\n        case ExtensionType.ScaledUiAmountConfig:\n        case ExtensionType.PausableAccount:\n            return ExtensionType.Uninitialized;\n    }\n}\n\nfunction getLen(\n    extensionTypes: ExtensionType[],\n    baseSize: number,\n    variableLengthExtensions: { [E in ExtensionType]?: number } = {},\n): number {\n    if (extensionTypes.length === 0 && Object.keys(variableLengthExtensions).length === 0) {\n        return baseSize;\n    } else {\n        const accountLength =\n            ACCOUNT_SIZE +\n            ACCOUNT_TYPE_SIZE +\n            extensionTypes\n                .filter((element, i) => i === extensionTypes.indexOf(element))\n                .map(element => addTypeAndLengthToLen(getTypeLen(element)))\n                .reduce((a, b) => a + b, 0) +\n            Object.entries(variableLengthExtensions)\n                .map(([extension, len]) => {\n                    if (!isVariableLengthExtension(Number(extension))) {\n                        throw Error(`Extension ${extension} is not variable length`);\n                    }\n                    return addTypeAndLengthToLen(len);\n                })\n                .reduce((a, b) => a + b, 0);\n        if (accountLength === MULTISIG_SIZE) {\n            return accountLength + TYPE_SIZE;\n        } else {\n            return accountLength;\n        }\n    }\n}\n\nexport function getMintLen(\n    extensionTypes: ExtensionType[],\n    variableLengthExtensions: { [E in ExtensionType]?: number } = {},\n): number {\n    return getLen(extensionTypes, MINT_SIZE, variableLengthExtensions);\n}\n\nexport function getAccountLen(extensionTypes: ExtensionType[]): number {\n    // There are currently no variable length extensions for accounts\n    return getLen(extensionTypes, ACCOUNT_SIZE);\n}\n\nexport function getExtensionData(extension: ExtensionType, tlvData: Buffer): Buffer | null {\n    let extensionTypeIndex = 0;\n    while (addTypeAndLengthToLen(extensionTypeIndex) <= tlvData.length) {\n        const entryType = tlvData.readUInt16LE(extensionTypeIndex);\n        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + TYPE_SIZE);\n        const typeIndex = addTypeAndLengthToLen(extensionTypeIndex);\n        if (entryType == extension) {\n            return tlvData.slice(typeIndex, typeIndex + entryLength);\n        }\n        extensionTypeIndex = typeIndex + entryLength;\n    }\n    return null;\n}\n\nexport function getExtensionTypes(tlvData: Buffer): ExtensionType[] {\n    const extensionTypes = [];\n    let extensionTypeIndex = 0;\n    while (extensionTypeIndex < tlvData.length) {\n        const entryType = tlvData.readUInt16LE(extensionTypeIndex);\n        extensionTypes.push(entryType);\n        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + TYPE_SIZE);\n        extensionTypeIndex += addTypeAndLengthToLen(entryLength);\n    }\n    return extensionTypes;\n}\n\nexport function getAccountLenForMint(mint: Mint): number {\n    const extensionTypes = getExtensionTypes(mint.tlvData);\n    const accountExtensions = extensionTypes.map(getAccountTypeOfMintType);\n    return getAccountLen(accountExtensions);\n}\n\nexport function getNewAccountLenForExtensionLen(\n    info: AccountInfo<Buffer>,\n    address: PublicKey,\n    extensionType: ExtensionType,\n    extensionLen: number,\n    programId = TOKEN_2022_PROGRAM_ID,\n): number {\n    const mint = unpackMint(address, info, programId);\n    const extensionData = getExtensionData(extensionType, mint.tlvData);\n\n    const currentExtensionLen = extensionData ? addTypeAndLengthToLen(extensionData.length) : 0;\n    const newExtensionLen = addTypeAndLengthToLen(extensionLen);\n\n    return info.data.length + newExtensionLen - currentExtensionLen;\n}\n","import { struct } from '@solana/buffer-layout';\nimport { publicKey, bool } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Account } from '../../state/account.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** PausableConfig as stored by the program */\nexport interface PausableConfig {\n    /** Authority that can pause or resume activity on the mint */\n    authority: PublicKey;\n    /** Whether minting / transferring / burning tokens is paused */\n    paused: boolean;\n}\n\n/** Buffer layout for de/serializing a pausable config */\nexport const PausableConfigLayout = struct<PausableConfig>([publicKey('authority'), bool('paused')]);\n\nexport const PAUSABLE_CONFIG_SIZE = PausableConfigLayout.span;\n\nexport function getPausableConfig(mint: Mint): PausableConfig | null {\n    const extensionData = getExtensionData(ExtensionType.PausableConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return PausableConfigLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n\n/** Pausable token account state as stored by the program */\nexport interface PausableAccount {} // eslint-disable-line\n\n/** Buffer layout for de/serializing a pausable account */\nexport const PausableAccountLayout = struct<PausableAccount>([]); // esline-disable-line\n\nexport const PAUSABLE_ACCOUNT_SIZE = PausableAccountLayout.span;\n\nexport function getPausableAccount(account: Account): PausableAccount | null {\n    const extensionData = getExtensionData(ExtensionType.PausableAccount, account.tlvData);\n    if (extensionData !== null) {\n        return PausableAccountLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n","import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { AccountInfo, Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidAccountSizeError,\n} from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport type { ExtensionType } from '../extensions/extensionType.js';\nimport { getAccountLen } from '../extensions/extensionType.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n\n/** Information about a token account */\nexport interface Account {\n    /** Address of the account */\n    address: PublicKey;\n    /** Mint associated with the account */\n    mint: PublicKey;\n    /** Owner of the account */\n    owner: PublicKey;\n    /** Number of tokens the account holds */\n    amount: bigint;\n    /** Authority that can transfer tokens from the account */\n    delegate: PublicKey | null;\n    /** Number of tokens the delegate is authorized to transfer */\n    delegatedAmount: bigint;\n    /** True if the account is initialized */\n    isInitialized: boolean;\n    /** True if the account is frozen */\n    isFrozen: boolean;\n    /** True if the account is a native token account */\n    isNative: boolean;\n    /**\n     * If the account is a native token account, it must be rent-exempt. The rent-exempt reserve is the amount that must\n     * remain in the balance until the account is closed.\n     */\n    rentExemptReserve: bigint | null;\n    /** Optional authority to close the account */\n    closeAuthority: PublicKey | null;\n    tlvData: Buffer;\n}\n\n/** Token account state as stored by the program */\nexport enum AccountState {\n    Uninitialized = 0,\n    Initialized = 1,\n    Frozen = 2,\n}\n\n/** Token account as stored by the program */\nexport interface RawAccount {\n    mint: PublicKey;\n    owner: PublicKey;\n    amount: bigint;\n    delegateOption: 1 | 0;\n    delegate: PublicKey;\n    state: AccountState;\n    isNativeOption: 1 | 0;\n    isNative: bigint;\n    delegatedAmount: bigint;\n    closeAuthorityOption: 1 | 0;\n    closeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a token account */\nexport const AccountLayout = struct<RawAccount>([\n    publicKey('mint'),\n    publicKey('owner'),\n    u64('amount'),\n    u32('delegateOption'),\n    publicKey('delegate'),\n    u8('state'),\n    u32('isNativeOption'),\n    u64('isNative'),\n    u64('delegatedAmount'),\n    u32('closeAuthorityOption'),\n    publicKey('closeAuthority'),\n]);\n\n/** Byte length of a token account */\nexport const ACCOUNT_SIZE = AccountLayout.span;\n\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getAccount(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<Account> {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackAccount(address, info, programId);\n}\n\n/**\n * Retrieve information about multiple token accounts in a single RPC call\n *\n * @param connection Connection to use\n * @param addresses  Token accounts\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getMultipleAccounts(\n    connection: Connection,\n    addresses: PublicKey[],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<Account[]> {\n    const infos = await connection.getMultipleAccountsInfo(addresses, commitment);\n    return addresses.map((address, i) => unpackAccount(address, infos[i], programId));\n}\n\n/** Get the minimum lamport balance for a base token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccount(\n    connection: Connection,\n    commitment?: Commitment,\n): Promise<number> {\n    return await getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);\n}\n\n/** Get the minimum lamport balance for a rent-exempt token account with extensions\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccountWithExtensions(\n    connection: Connection,\n    extensions: ExtensionType[],\n    commitment?: Commitment,\n): Promise<number> {\n    const accountLen = getAccountLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(accountLen, commitment);\n}\n\n/**\n * Unpack a token account\n *\n * @param address   Token account\n * @param info      Token account data\n * @param programId SPL Token program account\n *\n * @return Unpacked token account\n */\nexport function unpackAccount(\n    address: PublicKey,\n    info: AccountInfo<Buffer> | null,\n    programId = TOKEN_PROGRAM_ID,\n): Account {\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > ACCOUNT_SIZE) {\n        if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Account) throw new TokenInvalidAccountError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n\n    return {\n        address,\n        mint: rawAccount.mint,\n        owner: rawAccount.owner,\n        amount: rawAccount.amount,\n        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n        delegatedAmount: rawAccount.delegatedAmount,\n        isInitialized: rawAccount.state !== AccountState.Uninitialized,\n        isFrozen: rawAccount.state === AccountState.Frozen,\n        isNative: !!rawAccount.isNativeOption,\n        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n        tlvData,\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\n\nexport enum MetadataPointerInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\nexport const initializeMetadataPointerData = struct<{\n    instruction: TokenInstruction.MetadataPointerExtension;\n    metadataPointerInstruction: number;\n    authority: PublicKey;\n    metadataAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('metadataPointerInstruction'),\n    publicKey('authority'),\n    publicKey('metadataAddress'),\n]);\n\n/**\n * Construct an Initialize MetadataPointer instruction\n *\n * @param mint            Token mint account\n * @param authority       Optional Authority that can set the metadata address\n * @param metadataAddress Optional Account address that holds the metadata\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMetadataPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey | null,\n    metadataAddress: PublicKey | null,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeMetadataPointerData.span);\n    initializeMetadataPointerData.encode(\n        {\n            instruction: TokenInstruction.MetadataPointerExtension,\n            metadataPointerInstruction: MetadataPointerInstruction.Initialize,\n            authority: authority ?? PublicKey.default,\n            metadataAddress: metadataAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n\nexport const updateMetadataPointerData = struct<{\n    instruction: TokenInstruction.MetadataPointerExtension;\n    metadataPointerInstruction: number;\n    metadataAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('metadataPointerInstruction'),\n    publicKey('metadataAddress'),\n]);\n\nexport function createUpdateMetadataPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    metadataAddress: PublicKey | null,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(updateMetadataPointerData.span);\n    updateMetadataPointerData.encode(\n        {\n            instruction: TokenInstruction.MetadataPointerExtension,\n            metadataPointerInstruction: MetadataPointerInstruction.Update,\n            metadataAddress: metadataAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n","import { struct, u8, f64 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport type { Signer } from '@solana/web3.js';\nimport { TransactionInstruction, PublicKey } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\n\nexport enum ScaledUiAmountInstruction {\n    Initialize = 0,\n    UpdateMultiplier = 1,\n}\n\nexport interface InitializeScaledUiAmountConfigData {\n    instruction: TokenInstruction.ScaledUiAmountExtension;\n    scaledUiAmountInstruction: ScaledUiAmountInstruction.Initialize;\n    authority: PublicKey | null;\n    multiplier: number;\n}\n\nexport const initializeScaledUiAmountConfigInstructionData = struct<InitializeScaledUiAmountConfigData>([\n    u8('instruction'),\n    u8('scaledUiAmountInstruction'),\n    publicKey('authority'),\n    f64('multiplier'),\n]);\n\n/**\n * Construct an InitializeScaledUiAmountConfig instruction\n *\n * @param mint         Token mint account\n * @param authority    Optional authority that can update the multipliers\n * @param signers      The signer account(s)\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeScaledUiAmountConfigInstruction(\n    mint: PublicKey,\n    authority: PublicKey | null,\n    multiplier: number,\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeScaledUiAmountConfigInstructionData.span);\n    initializeScaledUiAmountConfigInstructionData.encode(\n        {\n            instruction: TokenInstruction.ScaledUiAmountExtension,\n            scaledUiAmountInstruction: ScaledUiAmountInstruction.Initialize,\n            authority: authority ?? PublicKey.default,\n            multiplier: multiplier,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\nexport interface UpdateMultiplierData {\n    instruction: TokenInstruction.ScaledUiAmountExtension;\n    scaledUiAmountInstruction: ScaledUiAmountInstruction.UpdateMultiplier;\n    multiplier: number;\n    effectiveTimestamp: bigint;\n}\n\nexport const updateMultiplierData = struct<UpdateMultiplierData>([\n    u8('instruction'),\n    u8('scaledUiAmountInstruction'),\n    f64('multiplier'),\n    u64('effectiveTimestamp'),\n]);\n\n/**\n * Construct an UpdateMultiplierData instruction\n *\n * @param mint                  Token mint account\n * @param authority             Optional authority that can update the multipliers\n * @param multiplier            New multiplier\n * @param effectiveTimestamp    Effective time stamp for the new multiplier\n * @param multiSigners          Signing accounts if `owner` is a multisig\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateMultiplierDataInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    multiplier: number,\n    effectiveTimestamp: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(updateMultiplierData.span);\n    updateMultiplierData.encode(\n        {\n            instruction: TokenInstruction.ScaledUiAmountExtension,\n            scaledUiAmountInstruction: ScaledUiAmountInstruction.UpdateMultiplier,\n            multiplier,\n            effectiveTimestamp,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import { Layout } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\n\nexport class COptionPublicKeyLayout extends Layout<PublicKey | null> {\n    private publicKeyLayout: Layout<PublicKey>;\n\n    constructor(property?: string | undefined) {\n        super(-1, property);\n        this.publicKeyLayout = publicKey();\n    }\n\n    decode(buffer: Uint8Array, offset: number = 0): PublicKey | null {\n        const option = buffer[offset];\n        if (option === 0) {\n            return null;\n        }\n        return this.publicKeyLayout.decode(buffer, offset + 1);\n    }\n\n    encode(src: PublicKey | null, buffer: Uint8Array, offset: number = 0): number {\n        if (src === null) {\n            buffer[offset] = 0;\n            return 1;\n        } else {\n            buffer[offset] = 1;\n            this.publicKeyLayout.encode(src, buffer, offset + 1);\n            return 33;\n        }\n    }\n\n    getSpan(buffer?: Uint8Array, offset: number = 0): number {\n        if (buffer) {\n            const option = buffer[offset];\n            return option === 0 ? 1 : 1 + this.publicKeyLayout.span;\n        }\n        throw new RangeError('Buffer must be provided');\n    }\n}\n","import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** GroupPointer as stored by the program */\nexport interface GroupPointer {\n    /** Optional authority that can set the group address */\n    authority: PublicKey | null;\n    /** Optional account address that holds the group */\n    groupAddress: PublicKey | null;\n}\n\n/** Buffer layout for de/serializing a GroupPointer extension */\nexport const GroupPointerLayout = struct<{ authority: PublicKey; groupAddress: PublicKey }>([\n    publicKey('authority'),\n    publicKey('groupAddress'),\n]);\n\nexport const GROUP_POINTER_SIZE = GroupPointerLayout.span;\n\nexport function getGroupPointerState(mint: Mint): Partial<GroupPointer> | null {\n    const extensionData = getExtensionData(ExtensionType.GroupPointer, mint.tlvData);\n    if (extensionData !== null) {\n        const { authority, groupAddress } = GroupPointerLayout.decode(extensionData);\n\n        // Explicitly set None/Zero keys to null\n        return {\n            authority: authority.equals(PublicKey.default) ? null : authority,\n            groupAddress: groupAddress.equals(PublicKey.default) ? null : groupAddress,\n        };\n    } else {\n        return null;\n    }\n}\n","import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../state/mint.js';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n\n/** PermanentDelegate as stored by the program */\nexport interface PermanentDelegate {\n    delegate: PublicKey;\n}\n\n/** Buffer layout for de/serializing a mint */\nexport const PermanentDelegateLayout = struct<PermanentDelegate>([publicKey('delegate')]);\n\nexport const PERMANENT_DELEGATE_SIZE = PermanentDelegateLayout.span;\n\nexport function getPermanentDelegate(mint: Mint): PermanentDelegate | null {\n    const extensionData = getExtensionData(ExtensionType.PermanentDelegate, mint.tlvData);\n    if (extensionData !== null) {\n        return PermanentDelegateLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n\n/** TODO: docs */\nexport interface InitializeMint2InstructionData {\n    instruction: TokenInstruction.InitializeMint2;\n    decimals: number;\n    mintAuthority: PublicKey;\n    freezeAuthority: PublicKey | null;\n}\n\n/** TODO: docs */\nexport const initializeMint2InstructionData = struct<InitializeMint2InstructionData>([\n    u8('instruction'),\n    u8('decimals'),\n    publicKey('mintAuthority'),\n    new COptionPublicKeyLayout('freezeAuthority'),\n]);\n\n/**\n * Construct an InitializeMint2 instruction\n *\n * @param mint            Token mint account\n * @param decimals        Number of decimals in token account amounts\n * @param mintAuthority   Minting authority\n * @param freezeAuthority Optional authority that can freeze token accounts\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMint2Instruction(\n    mint: PublicKey,\n    decimals: number,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(67); // worst-case size\n    initializeMint2InstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMint2,\n            decimals,\n            mintAuthority,\n            freezeAuthority,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeMint2InstructionData.getSpan(data)),\n    });\n}\n\n/** A decoded, valid InitializeMint2 instruction */\nexport interface DecodedInitializeMint2Instruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMint2;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint2 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMint2Instruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeMint2Instruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMint2InstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeMint2InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMint2) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMint2 instruction */\nexport interface DecodedInitializeMint2InstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        decimals: number;\n        mintAuthority: PublicKey;\n        freezeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMint2 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMint2InstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeMint2InstructionUnchecked {\n    const { instruction, decimals, mintAuthority, freezeAuthority } = initializeMint2InstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            decimals,\n            mintAuthority,\n            freezeAuthority,\n        },\n    };\n}\n","import { f64, struct } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\nexport interface ScaledUiAmountConfig {\n    authority: PublicKey;\n    multiplier: number;\n    newMultiplierEffectiveTimestamp: bigint;\n    newMultiplier: number;\n}\n\nexport const ScaledUiAmountConfigLayout = struct<ScaledUiAmountConfig>([\n    publicKey('authority'),\n    f64('multiplier'),\n    u64('newMultiplierEffectiveTimestamp'),\n    f64('newMultiplier'),\n]);\n\nexport const SCALED_UI_AMOUNT_CONFIG_SIZE = ScaledUiAmountConfigLayout.span;\n\nexport function getScaledUiAmountConfig(mint: Mint): ScaledUiAmountConfig | null {\n    const extensionData = getExtensionData(ExtensionType.ScaledUiAmountConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return ScaledUiAmountConfigLayout.decode(extensionData);\n    }\n    return null;\n}\n","import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** GroupMemberPointer as stored by the program */\nexport interface GroupMemberPointer {\n    /** Optional authority that can set the member address */\n    authority: PublicKey | null;\n    /** Optional account address that holds the member */\n    memberAddress: PublicKey | null;\n}\n\n/** Buffer layout for de/serializing a Group Pointer extension */\nexport const GroupMemberPointerLayout = struct<{ authority: PublicKey; memberAddress: PublicKey }>([\n    publicKey('authority'),\n    publicKey('memberAddress'),\n]);\n\nexport const GROUP_MEMBER_POINTER_SIZE = GroupMemberPointerLayout.span;\n\nexport function getGroupMemberPointerState(mint: Mint): Partial<GroupMemberPointer> | null {\n    const extensionData = getExtensionData(ExtensionType.GroupMemberPointer, mint.tlvData);\n    if (extensionData !== null) {\n        const { authority, memberAddress } = GroupMemberPointerLayout.decode(extensionData);\n\n        // Explicitly set None/Zero keys to null\n        return {\n            authority: authority.equals(PublicKey.default) ? null : authority,\n            memberAddress: memberAddress.equals(PublicKey.default) ? null : memberAddress,\n        };\n    } else {\n        return null;\n    }\n}\n","import { blob, Layout } from '@solana/buffer-layout';\nimport { PublicKey } from '@solana/web3.js';\nimport { encodeDecode } from './base';\n\nexport const publicKey = (property?: string): Layout<PublicKey> => {\n    const layout = blob(32, property);\n    const { encode, decode } = encodeDecode(layout);\n\n    const publicKeyLayout = layout as Layout<unknown> as Layout<PublicKey>;\n\n    publicKeyLayout.decode = (buffer: Buffer, offset: number) => {\n        const src = decode(buffer, offset);\n        return new PublicKey(src);\n    };\n\n    publicKeyLayout.encode = (publicKey: PublicKey, buffer: Buffer, offset: number) => {\n        const src = publicKey.toBuffer();\n        return encode(src, buffer, offset);\n    };\n\n    return publicKeyLayout;\n};\n","import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** MetadataPointer as stored by the program */\nexport interface MetadataPointer {\n    /** Optional authority that can set the metadata address */\n    authority: PublicKey | null;\n    /** Optional Account Address that holds the metadata */\n    metadataAddress: PublicKey | null;\n}\n\n/** Buffer layout for de/serializing a Metadata Pointer extension */\nexport const MetadataPointerLayout = struct<{ authority: PublicKey; metadataAddress: PublicKey }>([\n    publicKey('authority'),\n    publicKey('metadataAddress'),\n]);\n\nexport const METADATA_POINTER_SIZE = MetadataPointerLayout.span;\n\nexport function getMetadataPointerState(mint: Mint): Partial<MetadataPointer> | null {\n    const extensionData = getExtensionData(ExtensionType.MetadataPointer, mint.tlvData);\n    if (extensionData !== null) {\n        const { authority, metadataAddress } = MetadataPointerLayout.decode(extensionData);\n\n        // Explicitly set None/Zero keys to null\n        return {\n            authority: authority.equals(PublicKey.default) ? null : authority,\n            metadataAddress: metadataAddress.equals(PublicKey.default) ? null : metadataAddress,\n        };\n    } else {\n        return null;\n    }\n}\n","import type { Layout } from '@solana/buffer-layout';\nimport { struct, u16 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Account } from '../../state/account.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\nexport const MAX_FEE_BASIS_POINTS = 10000;\nexport const ONE_IN_BASIS_POINTS = BigInt(MAX_FEE_BASIS_POINTS);\n\n/** TransferFeeConfig as stored by the program */\nexport interface TransferFee {\n    /** First epoch where the transfer fee takes effect */\n    epoch: bigint;\n    /** Maximum fee assessed on transfers, expressed as an amount of tokens */\n    maximumFee: bigint;\n    /**\n     * Amount of transfer collected as fees, expressed as basis points of the\n     * transfer amount, ie. increments of 0.01%\n     */\n    transferFeeBasisPoints: number;\n}\n\n/** Transfer fee extension data for mints. */\nexport interface TransferFeeConfig {\n    /** Optional authority to set the fee */\n    transferFeeConfigAuthority: PublicKey;\n    /** Withdraw from mint instructions must be signed by this key */\n    withdrawWithheldAuthority: PublicKey;\n    /** Withheld transfer fee tokens that have been moved to the mint for withdrawal */\n    withheldAmount: bigint;\n    /** Older transfer fee, used if the current epoch < newerTransferFee.epoch */\n    olderTransferFee: TransferFee;\n    /** Newer transfer fee, used if the current epoch >= newerTransferFee.epoch */\n    newerTransferFee: TransferFee;\n}\n\n/** Buffer layout for de/serializing a transfer fee */\nexport function transferFeeLayout(property?: string): Layout<TransferFee> {\n    return struct<TransferFee>([u64('epoch'), u64('maximumFee'), u16('transferFeeBasisPoints')], property);\n}\n\n/** Calculate the transfer fee */\nexport function calculateFee(transferFee: TransferFee, preFeeAmount: bigint): bigint {\n    const transferFeeBasisPoints = transferFee.transferFeeBasisPoints;\n    if (transferFeeBasisPoints === 0 || preFeeAmount === BigInt(0)) {\n        return BigInt(0);\n    } else {\n        const numerator = preFeeAmount * BigInt(transferFeeBasisPoints);\n        const rawFee = (numerator + ONE_IN_BASIS_POINTS - BigInt(1)) / ONE_IN_BASIS_POINTS;\n        const fee = rawFee > transferFee.maximumFee ? transferFee.maximumFee : rawFee;\n        return BigInt(fee);\n    }\n}\n\n/** Buffer layout for de/serializing a transfer fee config extension */\nexport const TransferFeeConfigLayout = struct<TransferFeeConfig>([\n    publicKey('transferFeeConfigAuthority'),\n    publicKey('withdrawWithheldAuthority'),\n    u64('withheldAmount'),\n    transferFeeLayout('olderTransferFee'),\n    transferFeeLayout('newerTransferFee'),\n]);\n\nexport const TRANSFER_FEE_CONFIG_SIZE = TransferFeeConfigLayout.span;\n\n/** Get the fee for given epoch */\nexport function getEpochFee(transferFeeConfig: TransferFeeConfig, epoch: bigint): TransferFee {\n    if (epoch >= transferFeeConfig.newerTransferFee.epoch) {\n        return transferFeeConfig.newerTransferFee;\n    } else {\n        return transferFeeConfig.olderTransferFee;\n    }\n}\n\n/** Calculate the fee for the given epoch and input amount */\nexport function calculateEpochFee(transferFeeConfig: TransferFeeConfig, epoch: bigint, preFeeAmount: bigint): bigint {\n    const transferFee = getEpochFee(transferFeeConfig, epoch);\n    return calculateFee(transferFee, preFeeAmount);\n}\n\n/** Transfer fee amount data for accounts. */\nexport interface TransferFeeAmount {\n    /** Withheld transfer fee tokens that can be claimed by the fee authority */\n    withheldAmount: bigint;\n}\n/** Buffer layout for de/serializing */\nexport const TransferFeeAmountLayout = struct<TransferFeeAmount>([u64('withheldAmount')]);\nexport const TRANSFER_FEE_AMOUNT_SIZE = TransferFeeAmountLayout.span;\n\nexport function getTransferFeeConfig(mint: Mint): TransferFeeConfig | null {\n    const extensionData = getExtensionData(ExtensionType.TransferFeeConfig, mint.tlvData);\n    if (extensionData !== null) {\n        return TransferFeeConfigLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n\nexport function getTransferFeeAmount(account: Account): TransferFeeAmount | null {\n    const extensionData = getExtensionData(ExtensionType.TransferFeeAmount, account.tlvData);\n    if (extensionData !== null) {\n        return TransferFeeAmountLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, Signer } from '@solana/web3.js';\nimport { PublicKey, SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface InitializeMultisigInstructionData {\n    instruction: TokenInstruction.InitializeMultisig;\n    m: number;\n}\n\n/** TODO: docs */\nexport const initializeMultisigInstructionData = struct<InitializeMultisigInstructionData>([\n    u8('instruction'),\n    u8('m'),\n]);\n\n/**\n * Construct an InitializeMultisig instruction\n *\n * @param account   Multisig account\n * @param signers   Full set of signers\n * @param m         Number of required signatures\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMultisigInstruction(\n    account: PublicKey,\n    signers: (Signer | PublicKey)[],\n    m: number,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    for (const signer of signers) {\n        keys.push({\n            pubkey: signer instanceof PublicKey ? signer : signer.publicKey,\n            isSigner: false,\n            isWritable: false,\n        });\n    }\n\n    const data = Buffer.alloc(initializeMultisigInstructionData.span);\n    initializeMultisigInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMultisig,\n            m,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeMultisig instruction */\nexport interface DecodedInitializeMultisigInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        rent: AccountMeta;\n        signers: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMultisig;\n        m: number;\n    };\n}\n\n/**\n * Decode an InitializeMultisig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMultisigInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeMultisigInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMultisigInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, rent, signers },\n        data,\n    } = decodeInitializeMultisigInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMultisig) throw new TokenInvalidInstructionTypeError();\n    if (!account || !rent || !signers.length) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            rent,\n            signers,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMultisig instruction */\nexport interface DecodedInitializeMultisigInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n        signers: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        m: number;\n    };\n}\n\n/**\n * Decode an InitializeMultisig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMultisigInstructionUnchecked({\n    programId,\n    keys: [account, rent, ...signers],\n    data,\n}: TransactionInstruction): DecodedInitializeMultisigInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            rent,\n            signers,\n        },\n        data: initializeMultisigInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\n\nexport enum PausableInstruction {\n    Initialize = 0,\n    Pause = 1,\n    Resume = 2,\n}\n\nexport interface InitializePausableConfigInstructionData {\n    instruction: TokenInstruction.PausableExtension;\n    pausableInstruction: PausableInstruction.Initialize;\n    authority: PublicKey;\n}\n\nexport const initializePausableConfigInstructionData = struct<InitializePausableConfigInstructionData>([\n    u8('instruction'),\n    u8('pausableInstruction'),\n    publicKey('authority'),\n]);\n\n/**\n * Construct a InitializePausableConfig instruction\n *\n * @param mint          Token mint account\n * @param authority     Optional authority that can pause or resume mint\n * @param programId     SPL Token program account\n */\nexport function createInitializePausableConfigInstruction(\n    mint: PublicKey,\n    authority: PublicKey | null,\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializePausableConfigInstructionData.span);\n    initializePausableConfigInstructionData.encode(\n        {\n            instruction: TokenInstruction.PausableExtension,\n            pausableInstruction: PausableInstruction.Initialize,\n            authority: authority ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n\nexport interface PauseInstructionData {\n    instruction: TokenInstruction.PausableExtension;\n    pausableInstruction: PausableInstruction.Pause;\n}\n\nexport const pauseInstructionData = struct<PauseInstructionData>([u8('instruction'), u8('pausableInstruction')]);\n\n/**\n * Construct a Pause instruction\n *\n * @param mint          Token mint account\n * @param authority     The pausable mint's authority\n * @param multiSigners  Signing accounts if authority is a multisig\n * @param programId     SPL Token program account\n */\nexport function createPauseInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(pauseInstructionData.span);\n    pauseInstructionData.encode(\n        {\n            instruction: TokenInstruction.PausableExtension,\n            pausableInstruction: PausableInstruction.Pause,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n\nexport interface ResumeInstructionData {\n    instruction: TokenInstruction.PausableExtension;\n    pausableInstruction: PausableInstruction.Resume;\n}\n\nexport const resumeInstructionData = struct<ResumeInstructionData>([u8('instruction'), u8('pausableInstruction')]);\n\n/**\n * Construct a Resume instruction\n *\n * @param mint          Token mint account\n * @param authority     The pausable mint's authority\n * @param multiSigners  Signing accounts if authority is a multisig\n * @param programId     SPL Token program account\n */\nexport function createResumeInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(resumeInstructionData.span);\n    resumeInstructionData.encode(\n        {\n            instruction: TokenInstruction.PausableExtension,\n            pausableInstruction: PausableInstruction.Resume,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n","import { struct } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { Mint } from '../state/mint.js';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n\n/** MintCloseAuthority as stored by the program */\nexport interface MintCloseAuthority {\n    closeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a mint */\nexport const MintCloseAuthorityLayout = struct<MintCloseAuthority>([publicKey('closeAuthority')]);\n\nexport const MINT_CLOSE_AUTHORITY_SIZE = MintCloseAuthorityLayout.span;\n\nexport function getMintCloseAuthority(mint: Mint): MintCloseAuthority | null {\n    const extensionData = getExtensionData(ExtensionType.MintCloseAuthority, mint.tlvData);\n    if (extensionData !== null) {\n        return MintCloseAuthorityLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\nexport interface InitializeAccount2InstructionData {\n    instruction: TokenInstruction.InitializeAccount2;\n    owner: PublicKey;\n}\n\nexport const initializeAccount2InstructionData = struct<InitializeAccount2InstructionData>([\n    u8('instruction'),\n    publicKey('owner'),\n]);\n\n/**\n * Construct an InitializeAccount2 instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     New account's owner/multisignature\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccount2Instruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(initializeAccount2InstructionData.span);\n    initializeAccount2InstructionData.encode({ instruction: TokenInstruction.InitializeAccount2, owner }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeAccount2 instruction */\nexport interface DecodedInitializeAccount2Instruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        rent: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeAccount2;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount2 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccount2Instruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeAccount2Instruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccount2InstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, rent },\n        data,\n    } = decodeInitializeAccount2InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount2) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !rent) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            rent,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeAccount2 instruction */\nexport interface DecodedInitializeAccount2InstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount2 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccount2InstructionUnchecked({\n    programId,\n    keys: [account, mint, rent],\n    data,\n}: TransactionInstruction): DecodedInitializeAccount2InstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            rent,\n        },\n        data: initializeAccount2InstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\nexport interface InitializeAccount3InstructionData {\n    instruction: TokenInstruction.InitializeAccount3;\n    owner: PublicKey;\n}\n\nexport const initializeAccount3InstructionData = struct<InitializeAccount3InstructionData>([\n    u8('instruction'),\n    publicKey('owner'),\n]);\n\n/**\n * Construct an InitializeAccount3 instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     New account's owner/multisignature\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccount3Instruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n    ];\n    const data = Buffer.alloc(initializeAccount3InstructionData.span);\n    initializeAccount3InstructionData.encode({ instruction: TokenInstruction.InitializeAccount3, owner }, data);\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeAccount3 instruction */\nexport interface DecodedInitializeAccount3Instruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeAccount3;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount3 instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccount3Instruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeAccount3Instruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccount3InstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint },\n        data,\n    } = decodeInitializeAccount3InstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount3) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeAccount3 instruction */\nexport interface DecodedInitializeAccount3InstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        owner: PublicKey;\n    };\n}\n\n/**\n * Decode an InitializeAccount3 instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccount3InstructionUnchecked({\n    programId,\n    keys: [account, mint],\n    data,\n}: TransactionInstruction): DecodedInitializeAccount3InstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n        },\n        data: initializeAccount3InstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\n\nexport enum GroupMemberPointerInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\nexport const initializeGroupMemberPointerData = struct<{\n    instruction: TokenInstruction.GroupMemberPointerExtension;\n    groupMemberPointerInstruction: number;\n    authority: PublicKey;\n    memberAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupMemberPointerInstruction'),\n    publicKey('authority'),\n    publicKey('memberAddress'),\n]);\n\n/**\n * Construct an Initialize GroupMemberPointer instruction\n *\n * @param mint            Token mint account\n * @param authority       Optional Authority that can set the member address\n * @param memberAddress   Optional Account address that holds the member\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeGroupMemberPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey | null,\n    memberAddress: PublicKey | null,\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeGroupMemberPointerData.span);\n    initializeGroupMemberPointerData.encode(\n        {\n            instruction: TokenInstruction.GroupMemberPointerExtension,\n            groupMemberPointerInstruction: GroupMemberPointerInstruction.Initialize,\n            authority: authority ?? PublicKey.default,\n            memberAddress: memberAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n\nexport const updateGroupMemberPointerData = struct<{\n    instruction: TokenInstruction.GroupMemberPointerExtension;\n    groupMemberPointerInstruction: number;\n    memberAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupMemberPointerInstruction'),\n    publicKey('memberAddress'),\n]);\n\nexport function createUpdateGroupMemberPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    memberAddress: PublicKey | null,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(updateGroupMemberPointerData.span);\n    updateGroupMemberPointerData.encode(\n        {\n            instruction: TokenInstruction.GroupMemberPointerExtension,\n            groupMemberPointerInstruction: GroupMemberPointerInstruction.Update,\n            memberAddress: memberAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, programSupportsExtensions } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { addSigners } from '../../instructions/internal.js';\n\nexport enum GroupPointerInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\nexport const initializeGroupPointerData = struct<{\n    instruction: TokenInstruction.GroupPointerExtension;\n    groupPointerInstruction: number;\n    authority: PublicKey;\n    groupAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupPointerInstruction'),\n    publicKey('authority'),\n    publicKey('groupAddress'),\n]);\n\n/**\n * Construct an Initialize GroupPointer instruction\n *\n * @param mint            Token mint account\n * @param authority       Optional Authority that can set the group address\n * @param groupAddress    Optional Account address that holds the group\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeGroupPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey | null,\n    groupAddress: PublicKey | null,\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeGroupPointerData.span);\n    initializeGroupPointerData.encode(\n        {\n            instruction: TokenInstruction.GroupPointerExtension,\n            groupPointerInstruction: GroupPointerInstruction.Initialize,\n            authority: authority ?? PublicKey.default,\n            groupAddress: groupAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n\nexport const updateGroupPointerData = struct<{\n    instruction: TokenInstruction.GroupPointerExtension;\n    groupPointerInstruction: number;\n    groupAddress: PublicKey;\n}>([\n    // prettier-ignore\n    u8('instruction'),\n    u8('groupPointerInstruction'),\n    publicKey('groupAddress'),\n]);\n\nexport function createUpdateGroupPointerInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    groupAddress: PublicKey | null,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId: PublicKey = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(updateGroupPointerData.span);\n    updateGroupPointerData.encode(\n        {\n            instruction: TokenInstruction.GroupPointerExtension,\n            groupPointerInstruction: GroupPointerInstruction.Update,\n            groupAddress: groupAddress ?? PublicKey.default,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data: data });\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface InitializePermanentDelegateInstructionData {\n    instruction: TokenInstruction.InitializePermanentDelegate;\n    delegate: PublicKey;\n}\n\n/** TODO: docs */\nexport const initializePermanentDelegateInstructionData = struct<InitializePermanentDelegateInstructionData>([\n    u8('instruction'),\n    publicKey('delegate'),\n]);\n\n/**\n * Construct an InitializePermanentDelegate instruction\n *\n * @param mint               Token mint account\n * @param permanentDelegate  Authority that may sign for `Transfer`s and `Burn`s on any account\n * @param programId          SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializePermanentDelegateInstruction(\n    mint: PublicKey,\n    permanentDelegate: PublicKey | null,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializePermanentDelegateInstructionData.span);\n    initializePermanentDelegateInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializePermanentDelegate,\n            delegate: permanentDelegate || new PublicKey(0),\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializePermanentDelegate instruction */\nexport interface DecodedInitializePermanentDelegateInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializePermanentDelegate;\n        delegate: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializePermanentDelegate instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializePermanentDelegateInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedInitializePermanentDelegateInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializePermanentDelegateInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializePermanentDelegateInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializePermanentDelegate) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializePermanentDelegate instruction */\nexport interface DecodedInitializePermanentDelegateInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        delegate: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializePermanentDelegate instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializePermanentDelegateInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializePermanentDelegateInstructionUnchecked {\n    const { instruction, delegate } = initializePermanentDelegateInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            delegate,\n        },\n    };\n}\n","export enum AccountType {\n    Uninitialized,\n    Mint,\n    Account,\n}\nexport const ACCOUNT_TYPE_SIZE = 1;\n","import { u8 } from '@solana/buffer-layout';\nimport { encodeDecode } from './base.mjs';\nexport const bool = (property) => {\n    const layout = u8(property);\n    const { encode, decode } = encodeDecode(layout);\n    const boolLayout = layout;\n    boolLayout.decode = (buffer, offset) => {\n        const src = decode(buffer, offset);\n        return !!src;\n    };\n    boolLayout.encode = (bool, buffer, offset) => {\n        const src = Number(bool);\n        return encode(src, buffer, offset);\n    };\n    return boolLayout;\n};\n//# sourceMappingURL=native.js.map","import { PUBLIC_KEY_LENGTH, PublicKey } from '@solana/web3.js';\nimport type { AccountMeta, Connection } from '@solana/web3.js';\nimport {\n    TokenTransferHookAccountDataNotFound,\n    TokenTransferHookInvalidPubkeyData,\n    TokenTransferHookPubkeyDataTooSmall,\n    TokenTransferHookAccountNotFound,\n} from '../../errors.js';\n\nexport async function unpackPubkeyData(\n    keyDataConfig: Uint8Array,\n    previousMetas: AccountMeta[],\n    instructionData: Buffer,\n    connection: Connection,\n): Promise<PublicKey> {\n    const [discriminator, ...rest] = keyDataConfig;\n    const remaining = new Uint8Array(rest);\n    switch (discriminator) {\n        case 1:\n            return unpackPubkeyDataFromInstructionData(remaining, instructionData);\n        case 2:\n            return unpackPubkeyDataFromAccountData(remaining, previousMetas, connection);\n        default:\n            throw new TokenTransferHookInvalidPubkeyData();\n    }\n}\n\nfunction unpackPubkeyDataFromInstructionData(remaining: Uint8Array, instructionData: Buffer): PublicKey {\n    if (remaining.length < 1) {\n        throw new TokenTransferHookInvalidPubkeyData();\n    }\n    const dataIndex = remaining[0];\n    if (instructionData.length < dataIndex + PUBLIC_KEY_LENGTH) {\n        throw new TokenTransferHookPubkeyDataTooSmall();\n    }\n    return new PublicKey(instructionData.subarray(dataIndex, dataIndex + PUBLIC_KEY_LENGTH));\n}\n\nasync function unpackPubkeyDataFromAccountData(\n    remaining: Uint8Array,\n    previousMetas: AccountMeta[],\n    connection: Connection,\n): Promise<PublicKey> {\n    if (remaining.length < 2) {\n        throw new TokenTransferHookInvalidPubkeyData();\n    }\n    const [accountIndex, dataIndex] = remaining;\n    if (previousMetas.length <= accountIndex) {\n        throw new TokenTransferHookAccountDataNotFound();\n    }\n    const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);\n    if (accountInfo == null) {\n        throw new TokenTransferHookAccountNotFound();\n    }\n    if (accountInfo.data.length < dataIndex + PUBLIC_KEY_LENGTH) {\n        throw new TokenTransferHookPubkeyDataTooSmall();\n    }\n    return new PublicKey(accountInfo.data.subarray(dataIndex, dataIndex + PUBLIC_KEY_LENGTH));\n}\n","import { PublicKey } from '@solana/web3.js';\nimport type { ReadonlyUint8Array } from '@solana/codecs';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\n\nconst tokenGroupCodec = getStructCodec([\n    ['updateAuthority', fixCodecSize(getBytesCodec(), 32)],\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['size', getU64Codec()],\n    ['maxSize', getU64Codec()],\n]);\n\nexport const TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize;\n\nexport interface TokenGroup {\n    /** The authority that can sign to update the group */\n    updateAuthority?: PublicKey;\n    /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint */\n    mint: PublicKey;\n    /** The current number of group members */\n    size: bigint;\n    /** The maximum number of group members */\n    maxSize: bigint;\n}\n\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer: ReadonlyUint8Array): boolean {\n    for (let i = 0; i < buffer.length; i++) {\n        if (buffer[i] !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Pack TokenGroup into byte slab\nexport function packTokenGroup(group: TokenGroup): ReadonlyUint8Array {\n    // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n    const updateAuthority = group.updateAuthority ?? PublicKey.default;\n    return tokenGroupCodec.encode({\n        updateAuthority: updateAuthority.toBuffer(),\n        mint: group.mint.toBuffer(),\n        size: group.size,\n        maxSize: group.maxSize,\n    });\n}\n\n// unpack byte slab into TokenGroup\nexport function unpackTokenGroup(buffer: Buffer | Uint8Array | ReadonlyUint8Array): TokenGroup {\n    const data = tokenGroupCodec.decode(buffer);\n\n    return isNonePubkey(data.updateAuthority)\n        ? {\n              mint: new PublicKey(data.mint),\n              size: data.size,\n              maxSize: data.maxSize,\n          }\n        : {\n              updateAuthority: new PublicKey(data.updateAuthority),\n              mint: new PublicKey(data.mint),\n              size: data.size,\n              maxSize: data.maxSize,\n          };\n}\n","import { PublicKey } from '@solana/web3.js';\nimport {\n    addCodecSizePrefix,\n    fixCodecSize,\n    getArrayCodec,\n    getBytesCodec,\n    getUtf8Codec,\n    getU32Codec,\n    getStructCodec,\n    getTupleCodec,\n} from '@solana/codecs';\nimport type { ReadonlyUint8Array, VariableSizeCodec } from '@solana/codecs';\n\nexport const TOKEN_METADATA_DISCRIMINATOR = Buffer.from([112, 132, 90, 90, 11, 88, 157, 87]);\n\nfunction getStringCodec(): VariableSizeCodec<string> {\n    return addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n}\n\nconst tokenMetadataCodec = getStructCodec([\n    ['updateAuthority', fixCodecSize(getBytesCodec(), 32)],\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['name', getStringCodec()],\n    ['symbol', getStringCodec()],\n    ['uri', getStringCodec()],\n    ['additionalMetadata', getArrayCodec(getTupleCodec([getStringCodec(), getStringCodec()]))],\n]);\n\nexport interface TokenMetadata {\n    // The authority that can sign to update the metadata\n    updateAuthority?: PublicKey;\n    // The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint\n    mint: PublicKey;\n    // The longer name of the token\n    name: string;\n    // The shortened symbol for the token\n    symbol: string;\n    // The URI pointing to richer metadata\n    uri: string;\n    // Any additional metadata about the token as key-value pairs\n    additionalMetadata: (readonly [string, string])[];\n}\n\n// Checks if all elements in the array are 0\nfunction isNonePubkey(buffer: ReadonlyUint8Array): boolean {\n    for (let i = 0; i < buffer.length; i++) {\n        if (buffer[i] !== 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Pack TokenMetadata into byte slab\nexport function pack(meta: TokenMetadata): ReadonlyUint8Array {\n    // If no updateAuthority given, set it to the None/Zero PublicKey for encoding\n    const updateAuthority = meta.updateAuthority ?? PublicKey.default;\n    return tokenMetadataCodec.encode({\n        ...meta,\n        updateAuthority: updateAuthority.toBuffer(),\n        mint: meta.mint.toBuffer(),\n    });\n}\n\n// unpack byte slab into TokenMetadata\nexport function unpack(buffer: Buffer | Uint8Array | ReadonlyUint8Array): TokenMetadata {\n    const data = tokenMetadataCodec.decode(buffer);\n\n    return isNonePubkey(data.updateAuthority)\n        ? {\n              mint: new PublicKey(data.mint),\n              name: data.name,\n              symbol: data.symbol,\n              uri: data.uri,\n              additionalMetadata: data.additionalMetadata,\n          }\n        : {\n              updateAuthority: new PublicKey(data.updateAuthority),\n              mint: new PublicKey(data.mint),\n              name: data.name,\n              symbol: data.symbol,\n              uri: data.uri,\n              additionalMetadata: data.additionalMetadata,\n          };\n}\n","import type { PublicKey } from '@solana/web3.js';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Construct a CreateAssociatedTokenAccount instruction\n *\n * @param payer                    Payer of the initialization fees\n * @param associatedToken          New associated token account\n * @param owner                    Owner of the new account\n * @param mint                     Token mint account\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAssociatedTokenAccountInstruction(\n    payer: PublicKey,\n    associatedToken: PublicKey,\n    owner: PublicKey,\n    mint: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    return buildAssociatedTokenAccountInstruction(\n        payer,\n        associatedToken,\n        owner,\n        mint,\n        Buffer.alloc(0),\n        programId,\n        associatedTokenProgramId,\n    );\n}\n\n/**\n * Construct a CreateAssociatedTokenAccountIdempotent instruction\n *\n * @param payer                    Payer of the initialization fees\n * @param associatedToken          New associated token account\n * @param owner                    Owner of the new account\n * @param mint                     Token mint account\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAssociatedTokenAccountIdempotentInstruction(\n    payer: PublicKey,\n    associatedToken: PublicKey,\n    owner: PublicKey,\n    mint: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    return buildAssociatedTokenAccountInstruction(\n        payer,\n        associatedToken,\n        owner,\n        mint,\n        Buffer.from([1]),\n        programId,\n        associatedTokenProgramId,\n    );\n}\n\n/**\n * Derive the associated token account and construct a CreateAssociatedTokenAccountIdempotent instruction\n *\n * @param payer                    Payer of the initialization fees\n * @param owner                    Owner of the new account\n * @param mint                     Token mint account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createAssociatedTokenAccountIdempotentInstructionWithDerivation(\n    payer: PublicKey,\n    owner: PublicKey,\n    mint: PublicKey,\n    allowOwnerOffCurve = true,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n) {\n    const associatedToken = getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve);\n\n    return createAssociatedTokenAccountIdempotentInstruction(\n        payer,\n        associatedToken,\n        owner,\n        mint,\n        programId,\n        associatedTokenProgramId,\n    );\n}\n\nfunction buildAssociatedTokenAccountInstruction(\n    payer: PublicKey,\n    associatedToken: PublicKey,\n    owner: PublicKey,\n    mint: PublicKey,\n    instructionData: Buffer,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: associatedToken, isSigner: false, isWritable: true },\n        { pubkey: owner, isSigner: false, isWritable: false },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n        { pubkey: programId, isSigner: false, isWritable: false },\n    ];\n\n    return new TransactionInstruction({\n        keys,\n        programId: associatedTokenProgramId,\n        data: instructionData,\n    });\n}\n\n/**\n * Construct a RecoverNested instruction\n *\n * @param nestedAssociatedToken             Nested associated token account (must be owned by `ownerAssociatedToken`)\n * @param nestedMint                        Token mint for the nested associated token account\n * @param destinationAssociatedToken        Wallet's associated token account\n * @param ownerAssociatedToken              Owner associated token account address (must be owned by `owner`)\n * @param ownerMint                         Token mint for the owner associated token account\n * @param owner                             Wallet address for the owner associated token account\n * @param programId                         SPL Token program account\n * @param associatedTokenProgramId          SPL Associated Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createRecoverNestedInstruction(\n    nestedAssociatedToken: PublicKey,\n    nestedMint: PublicKey,\n    destinationAssociatedToken: PublicKey,\n    ownerAssociatedToken: PublicKey,\n    ownerMint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: nestedAssociatedToken, isSigner: false, isWritable: true },\n        { pubkey: nestedMint, isSigner: false, isWritable: false },\n        { pubkey: destinationAssociatedToken, isSigner: false, isWritable: true },\n        { pubkey: ownerAssociatedToken, isSigner: false, isWritable: true },\n        { pubkey: ownerMint, isSigner: false, isWritable: false },\n        { pubkey: owner, isSigner: true, isWritable: true },\n        { pubkey: programId, isSigner: false, isWritable: false },\n    ];\n\n    return new TransactionInstruction({\n        keys,\n        programId: associatedTokenProgramId,\n        data: Buffer.from([2]),\n    });\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createBurnInstruction } from '../instructions/burn.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Burn tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to burn tokens from\n * @param mint           Mint for the account\n * @param owner          Account owner\n * @param amount         Amount to burn\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function burn(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createBurnInstruction(account, mint, ownerPublicKey, amount, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { Commitment, ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidMintError,\n    TokenInvalidOwnerError,\n} from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport type { Account } from '../state/account.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    commitment?: Commitment,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): Promise<Account> {\n    const associatedToken = getAssociatedTokenAddressSync(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account: Account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    } catch (error: unknown) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(\n                    createAssociatedTokenAccountInstruction(\n                        payer.publicKey,\n                        associatedToken,\n                        owner,\n                        mint,\n                        programId,\n                        associatedTokenProgramId,\n                    ),\n                );\n\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            } catch (error: unknown) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        } else {\n            throw error;\n        }\n    }\n\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n\n    return account;\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport type { AccountState } from '../../state/account.js';\n\nexport enum DefaultAccountStateInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\n/** TODO: docs */\nexport interface DefaultAccountStateInstructionData {\n    instruction: TokenInstruction.DefaultAccountStateExtension;\n    defaultAccountStateInstruction: DefaultAccountStateInstruction;\n    accountState: AccountState;\n}\n\n/** TODO: docs */\nexport const defaultAccountStateInstructionData = struct<DefaultAccountStateInstructionData>([\n    u8('instruction'),\n    u8('defaultAccountStateInstruction'),\n    u8('accountState'),\n]);\n\n/**\n * Construct an InitializeDefaultAccountState instruction\n *\n * @param mint         Mint to initialize\n * @param accountState Default account state to set on all new accounts\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeDefaultAccountStateInstruction(\n    mint: PublicKey,\n    accountState: AccountState,\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n    const data = Buffer.alloc(defaultAccountStateInstructionData.span);\n    defaultAccountStateInstructionData.encode(\n        {\n            instruction: TokenInstruction.DefaultAccountStateExtension,\n            defaultAccountStateInstruction: DefaultAccountStateInstruction.Initialize,\n            accountState,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/**\n * Construct an UpdateDefaultAccountState instruction\n *\n * @param mint         Mint to update\n * @param accountState    Default account state to set on all accounts\n * @param freezeAuthority       The mint's freeze authority\n * @param signers         The signer account(s) for a multisig\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateDefaultAccountStateInstruction(\n    mint: PublicKey,\n    accountState: AccountState,\n    freezeAuthority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], freezeAuthority, multiSigners);\n    const data = Buffer.alloc(defaultAccountStateInstructionData.span);\n    defaultAccountStateInstructionData.encode(\n        {\n            instruction: TokenInstruction.DefaultAccountStateExtension,\n            defaultAccountStateInstruction: DefaultAccountStateInstruction.Update,\n            accountState,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum CpiGuardInstruction {\n    Enable = 0,\n    Disable = 1,\n}\n\n/** TODO: docs */\nexport interface CpiGuardInstructionData {\n    instruction: TokenInstruction.CpiGuardExtension;\n    cpiGuardInstruction: CpiGuardInstruction;\n}\n\n/** TODO: docs */\nexport const cpiGuardInstructionData = struct<CpiGuardInstructionData>([u8('instruction'), u8('cpiGuardInstruction')]);\n\n/**\n * Construct an EnableCpiGuard instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createEnableCpiGuardInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    return createCpiGuardInstruction(CpiGuardInstruction.Enable, account, authority, multiSigners, programId);\n}\n\n/**\n * Construct a DisableCpiGuard instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createDisableCpiGuardInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    return createCpiGuardInstruction(CpiGuardInstruction.Disable, account, authority, multiSigners, programId);\n}\n\nfunction createCpiGuardInstruction(\n    cpiGuardInstruction: CpiGuardInstruction,\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[],\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);\n\n    const data = Buffer.alloc(cpiGuardInstructionData.span);\n    cpiGuardInstructionData.encode(\n        {\n            instruction: TokenInstruction.CpiGuardExtension,\n            cpiGuardInstruction,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum MemoTransferInstruction {\n    Enable = 0,\n    Disable = 1,\n}\n\n/** TODO: docs */\nexport interface MemoTransferInstructionData {\n    instruction: TokenInstruction.MemoTransferExtension;\n    memoTransferInstruction: MemoTransferInstruction;\n}\n\n/** TODO: docs */\nexport const memoTransferInstructionData = struct<MemoTransferInstructionData>([\n    u8('instruction'),\n    u8('memoTransferInstruction'),\n]);\n\n/**\n * Construct an EnableRequiredMemoTransfers instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createEnableRequiredMemoTransfersInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    return createMemoTransferInstruction(MemoTransferInstruction.Enable, account, authority, multiSigners, programId);\n}\n\n/**\n * Construct a DisableMemoTransfer instruction\n *\n * @param account         Token account to update\n * @param authority       The account's owner/delegate\n * @param signers         The signer account(s)\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createDisableRequiredMemoTransfersInstruction(\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    return createMemoTransferInstruction(MemoTransferInstruction.Disable, account, authority, multiSigners, programId);\n}\n\nfunction createMemoTransferInstruction(\n    memoTransferInstruction: MemoTransferInstruction,\n    account: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[],\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(memoTransferInstructionData.span);\n    memoTransferInstructionData.encode(\n        {\n            instruction: TokenInstruction.MemoTransferExtension,\n            memoTransferInstruction,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import { seq, struct, u16, u8 } from '@solana/buffer-layout';\nimport type { PublicKey, Signer } from '@solana/web3.js';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport type { ExtensionType } from '../extensions/extensionType.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface ReallocateInstructionData {\n    instruction: TokenInstruction.Reallocate;\n    extensionTypes: ExtensionType[];\n}\n\n/**\n * Construct a Reallocate instruction\n *\n * @param account        Address of the token account\n * @param payer          Address paying for the reallocation\n * @param extensionTypes Extensions to reallocate for\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param programId      SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createReallocateInstruction(\n    account: PublicKey,\n    payer: PublicKey,\n    extensionTypes: ExtensionType[],\n    owner: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const baseKeys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ];\n    const keys = addSigners(baseKeys, owner, multiSigners);\n\n    const reallocateInstructionData = struct<ReallocateInstructionData>([\n        u8('instruction'),\n        seq(u16(), extensionTypes.length, 'extensionTypes'),\n    ]);\n    const data = Buffer.alloc(reallocateInstructionData.span);\n    reallocateInstructionData.encode({ instruction: TokenInstruction.Reallocate, extensionTypes }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountIdempotentInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Create and initialize a new associated token account\n * The instruction will succeed even if the associated token account already exists\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint for the account\n * @param owner                    Owner of the new account\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n *\n * @return Address of the new or existing associated token account\n */\nexport async function createAssociatedTokenAccountIdempotent(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n    allowOwnerOffCurve = false,\n): Promise<PublicKey> {\n    const associatedToken = getAssociatedTokenAddressSync(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    const transaction = new Transaction().add(\n        createAssociatedTokenAccountIdempotentInstruction(\n            payer.publicKey,\n            associatedToken,\n            owner,\n            mint,\n            programId,\n            associatedTokenProgramId,\n        ),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n    return associatedToken;\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createTransferInstruction } from '../instructions/transfer.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Transfer tokens from one account to another\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transfer(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferInstruction(source, destination, ownerPublicKey, amount, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport type { AuthorityType } from '../instructions/setAuthority.js';\nimport { createSetAuthorityInstruction } from '../instructions/setAuthority.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Assign a new authority to the account\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param account          Address of the account\n * @param currentAuthority Current authority of the specified type\n * @param authorityType    Type of authority to set\n * @param newAuthority     New authority of the account\n * @param multiSigners     Signing accounts if `currentAuthority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function setAuthority(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    currentAuthority: Signer | PublicKey,\n    authorityType: AuthorityType,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [currentAuthorityPublicKey, signers] = getSigners(currentAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createSetAuthorityInstruction(\n            account,\n            currentAuthorityPublicKey,\n            authorityType,\n            newAuthority,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createCloseAccountInstruction } from '../instructions/closeAccount.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Close a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to close\n * @param destination    Account to receive the remaining balance of the closed account\n * @param authority      Authority which is allowed to close the account\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function closeAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createCloseAccountInstruction(account, destination, authorityPublicKey, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createMintToCheckedInstruction } from '../instructions/mintToChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Mint tokens to an account, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param destination    Address of the account to mint to\n * @param authority      Minting authority\n * @param amount         Amount to mint\n * @param decimals       Number of decimals in amount to mint\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintToChecked(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createMintToCheckedInstruction(\n            mint,\n            destination,\n            authorityPublicKey,\n            amount,\n            decimals,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createFreezeAccountInstruction } from '../instructions/freezeAccount.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Freeze a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to freeze\n * @param mint           Mint for the account\n * @param authority      Mint freeze authority\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function freezeAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createFreezeAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createInitializeMint2Instruction } from '../instructions/initializeMint2.js';\nimport { getMinimumBalanceForRentExemptMint, MINT_SIZE } from '../state/mint.js';\n\n/**\n * Create and initialize a new mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction and initialization fees\n * @param mintAuthority   Account or multisig that will control minting\n * @param freezeAuthority Optional account or multisig that can freeze token accounts\n * @param decimals        Location of the decimal place\n * @param keypair         Optional keypair, defaulting to a new random one\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Address of the new mint\n */\nexport async function createMint(\n    connection: Connection,\n    payer: Signer,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey | null,\n    decimals: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<PublicKey> {\n    const lamports = await getMinimumBalanceForRentExemptMint(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: MINT_SIZE,\n            lamports,\n            programId,\n        }),\n        createInitializeMint2Instruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createTransferCheckedInstruction } from '../instructions/transferChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Transfer tokens from one account to another, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferChecked(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferCheckedInstruction(\n            source,\n            mint,\n            destination,\n            ownerPublicKey,\n            amount,\n            decimals,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { u8 } from '@solana/buffer-layout';\nimport type { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenInvalidInstructionDataError, TokenInvalidInstructionTypeError } from '../errors.js';\nimport type { DecodedAmountToUiAmountInstruction } from './amountToUiAmount.js';\nimport { decodeAmountToUiAmountInstruction } from './amountToUiAmount.js';\nimport type { DecodedApproveInstruction } from './approve.js';\nimport { decodeApproveInstruction } from './approve.js';\nimport type { DecodedApproveCheckedInstruction } from './approveChecked.js';\nimport { decodeApproveCheckedInstruction } from './approveChecked.js';\nimport type { DecodedBurnInstruction } from './burn.js';\nimport { decodeBurnInstruction } from './burn.js';\nimport type { DecodedBurnCheckedInstruction } from './burnChecked.js';\nimport { decodeBurnCheckedInstruction } from './burnChecked.js';\nimport type { DecodedCloseAccountInstruction } from './closeAccount.js';\nimport { decodeCloseAccountInstruction } from './closeAccount.js';\nimport type { DecodedFreezeAccountInstruction } from './freezeAccount.js';\nimport { decodeFreezeAccountInstruction } from './freezeAccount.js';\nimport type { DecodedInitializeAccountInstruction } from './initializeAccount.js';\nimport { decodeInitializeAccountInstruction } from './initializeAccount.js';\nimport type { DecodedInitializeAccount2Instruction } from './initializeAccount2.js';\nimport { decodeInitializeAccount2Instruction } from './initializeAccount2.js';\nimport type { DecodedInitializeAccount3Instruction } from './initializeAccount3.js';\nimport { decodeInitializeAccount3Instruction } from './initializeAccount3.js';\nimport type { DecodedInitializeMintInstruction } from './initializeMint.js';\nimport { decodeInitializeMintInstruction } from './initializeMint.js';\nimport type { DecodedInitializeMint2Instruction } from './initializeMint2.js';\nimport { decodeInitializeMint2Instruction } from './initializeMint2.js';\nimport type { DecodedInitializeMultisigInstruction } from './initializeMultisig.js';\nimport { decodeInitializeMultisigInstruction } from './initializeMultisig.js';\nimport type { DecodedMintToInstruction } from './mintTo.js';\nimport { decodeMintToInstruction } from './mintTo.js';\nimport type { DecodedMintToCheckedInstruction } from './mintToChecked.js';\nimport { decodeMintToCheckedInstruction } from './mintToChecked.js';\nimport type { DecodedRevokeInstruction } from './revoke.js';\nimport { decodeRevokeInstruction } from './revoke.js';\nimport type { DecodedSetAuthorityInstruction } from './setAuthority.js';\nimport { decodeSetAuthorityInstruction } from './setAuthority.js';\nimport type { DecodedSyncNativeInstruction } from './syncNative.js';\nimport { decodeSyncNativeInstruction } from './syncNative.js';\nimport type { DecodedThawAccountInstruction } from './thawAccount.js';\nimport { decodeThawAccountInstruction } from './thawAccount.js';\nimport type { DecodedTransferInstruction } from './transfer.js';\nimport { decodeTransferInstruction } from './transfer.js';\nimport type { DecodedTransferCheckedInstruction } from './transferChecked.js';\nimport { decodeTransferCheckedInstruction } from './transferChecked.js';\nimport { TokenInstruction } from './types.js';\nimport type { DecodedUiAmountToAmountInstruction } from './uiAmountToAmount.js';\nimport { decodeUiAmountToAmountInstruction } from './uiAmountToAmount.js';\n\n/** TODO: docs */\nexport type DecodedInstruction =\n    | DecodedInitializeMintInstruction\n    | DecodedInitializeAccountInstruction\n    | DecodedInitializeMultisigInstruction\n    | DecodedTransferInstruction\n    | DecodedApproveInstruction\n    | DecodedRevokeInstruction\n    | DecodedSetAuthorityInstruction\n    | DecodedMintToInstruction\n    | DecodedBurnInstruction\n    | DecodedCloseAccountInstruction\n    | DecodedFreezeAccountInstruction\n    | DecodedThawAccountInstruction\n    | DecodedTransferCheckedInstruction\n    | DecodedApproveCheckedInstruction\n    | DecodedMintToCheckedInstruction\n    | DecodedBurnCheckedInstruction\n    | DecodedInitializeAccount2Instruction\n    | DecodedSyncNativeInstruction\n    | DecodedInitializeAccount3Instruction\n    | DecodedInitializeMint2Instruction\n    | DecodedAmountToUiAmountInstruction\n    | DecodedUiAmountToAmountInstruction\n    // | DecodedInitializeMultisig2Instruction\n    // TODO: implement ^ and remove `never`\n    | never;\n\n/** TODO: docs */\nexport function decodeInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInstruction {\n    if (!instruction.data.length) throw new TokenInvalidInstructionDataError();\n\n    const type = u8().decode(instruction.data);\n    if (type === TokenInstruction.InitializeMint) return decodeInitializeMintInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount) return decodeInitializeAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeMultisig)\n        return decodeInitializeMultisigInstruction(instruction, programId);\n    if (type === TokenInstruction.Transfer) return decodeTransferInstruction(instruction, programId);\n    if (type === TokenInstruction.Approve) return decodeApproveInstruction(instruction, programId);\n    if (type === TokenInstruction.Revoke) return decodeRevokeInstruction(instruction, programId);\n    if (type === TokenInstruction.SetAuthority) return decodeSetAuthorityInstruction(instruction, programId);\n    if (type === TokenInstruction.MintTo) return decodeMintToInstruction(instruction, programId);\n    if (type === TokenInstruction.Burn) return decodeBurnInstruction(instruction, programId);\n    if (type === TokenInstruction.CloseAccount) return decodeCloseAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.FreezeAccount) return decodeFreezeAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.ThawAccount) return decodeThawAccountInstruction(instruction, programId);\n    if (type === TokenInstruction.TransferChecked) return decodeTransferCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.ApproveChecked) return decodeApproveCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.MintToChecked) return decodeMintToCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.BurnChecked) return decodeBurnCheckedInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount2)\n        return decodeInitializeAccount2Instruction(instruction, programId);\n    if (type === TokenInstruction.SyncNative) return decodeSyncNativeInstruction(instruction, programId);\n    if (type === TokenInstruction.InitializeAccount3)\n        return decodeInitializeAccount3Instruction(instruction, programId);\n    if (type === TokenInstruction.InitializeMint2) return decodeInitializeMint2Instruction(instruction, programId);\n    if (type === TokenInstruction.AmountToUiAmount) return decodeAmountToUiAmountInstruction(instruction, programId);\n    if (type === TokenInstruction.UiAmountToAmount) return decodeUiAmountToAmountInstruction(instruction, programId);\n    // TODO: implement\n    if (type === TokenInstruction.InitializeMultisig2) throw new TokenInvalidInstructionTypeError();\n\n    throw new TokenInvalidInstructionTypeError();\n}\n\n/** TODO: docs */\nexport function isInitializeMintInstruction(decoded: DecodedInstruction): decoded is DecodedInitializeMintInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMint;\n}\n\n/** TODO: docs */\nexport function isInitializeAccountInstruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedInitializeAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount;\n}\n\n/** TODO: docs */\nexport function isInitializeMultisigInstruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedInitializeMultisigInstruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMultisig;\n}\n\n/** TODO: docs */\nexport function isTransferInstruction(decoded: DecodedInstruction): decoded is DecodedTransferInstruction {\n    return decoded.data.instruction === TokenInstruction.Transfer;\n}\n\n/** TODO: docs */\nexport function isApproveInstruction(decoded: DecodedInstruction): decoded is DecodedApproveInstruction {\n    return decoded.data.instruction === TokenInstruction.Approve;\n}\n\n/** TODO: docs */\nexport function isRevokeInstruction(decoded: DecodedInstruction): decoded is DecodedRevokeInstruction {\n    return decoded.data.instruction === TokenInstruction.Revoke;\n}\n\n/** TODO: docs */\nexport function isSetAuthorityInstruction(decoded: DecodedInstruction): decoded is DecodedSetAuthorityInstruction {\n    return decoded.data.instruction === TokenInstruction.SetAuthority;\n}\n\n/** TODO: docs */\nexport function isMintToInstruction(decoded: DecodedInstruction): decoded is DecodedMintToInstruction {\n    return decoded.data.instruction === TokenInstruction.MintTo;\n}\n\n/** TODO: docs */\nexport function isBurnInstruction(decoded: DecodedInstruction): decoded is DecodedBurnInstruction {\n    return decoded.data.instruction === TokenInstruction.Burn;\n}\n\n/** TODO: docs */\nexport function isCloseAccountInstruction(decoded: DecodedInstruction): decoded is DecodedCloseAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.CloseAccount;\n}\n\n/** TODO: docs */\nexport function isFreezeAccountInstruction(decoded: DecodedInstruction): decoded is DecodedFreezeAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.FreezeAccount;\n}\n\n/** TODO: docs */\nexport function isThawAccountInstruction(decoded: DecodedInstruction): decoded is DecodedThawAccountInstruction {\n    return decoded.data.instruction === TokenInstruction.ThawAccount;\n}\n\n/** TODO: docs */\nexport function isTransferCheckedInstruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedTransferCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.TransferChecked;\n}\n\n/** TODO: docs */\nexport function isApproveCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedApproveCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.ApproveChecked;\n}\n\n/** TODO: docs */\nexport function isMintToCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedMintToCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.MintToChecked;\n}\n\n/** TODO: docs */\nexport function isBurnCheckedInstruction(decoded: DecodedInstruction): decoded is DecodedBurnCheckedInstruction {\n    return decoded.data.instruction === TokenInstruction.BurnChecked;\n}\n\n/** TODO: docs */\nexport function isInitializeAccount2Instruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedInitializeAccount2Instruction {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount2;\n}\n\n/** TODO: docs */\nexport function isSyncNativeInstruction(decoded: DecodedInstruction): decoded is DecodedSyncNativeInstruction {\n    return decoded.data.instruction === TokenInstruction.SyncNative;\n}\n\n/** TODO: docs */\nexport function isInitializeAccount3Instruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedInitializeAccount3Instruction {\n    return decoded.data.instruction === TokenInstruction.InitializeAccount3;\n}\n\n/** TODO: docs, implement */\n// export function isInitializeMultisig2Instruction(\n//     decoded: DecodedInstruction\n// ): decoded is DecodedInitializeMultisig2Instruction {\n//     return decoded.data.instruction === TokenInstruction.InitializeMultisig2;\n// }\n\n/** TODO: docs */\nexport function isInitializeMint2Instruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedInitializeMint2Instruction {\n    return decoded.data.instruction === TokenInstruction.InitializeMint2;\n}\n\n/** TODO: docs */\nexport function isAmountToUiAmountInstruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedAmountToUiAmountInstruction {\n    return decoded.data.instruction === TokenInstruction.AmountToUiAmount;\n}\n\n/** TODO: docs */\nexport function isUiamountToAmountInstruction(\n    decoded: DecodedInstruction,\n): decoded is DecodedUiAmountToAmountInstruction {\n    return decoded.data.instruction === TokenInstruction.UiAmountToAmount;\n}\n","import type { ConfirmOptions, Connection, Keypair, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { createInitializeAccountInstruction } from '../instructions/initializeAccount.js';\nimport { createSyncNativeInstruction } from '../instructions/syncNative.js';\nimport { ACCOUNT_SIZE, getMinimumBalanceForRentExemptAccount } from '../state/account.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\nimport { createAccount } from './createAccount.js';\n\n/**\n * Create, initialize, and fund a new wrapped native SOL account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param owner          Owner of the new token account\n * @param amount         Number of lamports to wrap\n * @param keypair        Optional keypair, defaulting to the associated token account for the native mint and `owner`\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new wrapped native SOL account\n */\nexport async function createWrappedNativeAccount(\n    connection: Connection,\n    payer: Signer,\n    owner: PublicKey,\n    amount: number,\n    keypair?: Keypair,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    nativeMint = NATIVE_MINT,\n): Promise<PublicKey> {\n    // If the amount provided is explicitly 0 or NaN, just create the account without funding it\n    if (!amount) return await createAccount(connection, payer, nativeMint, owner, keypair, confirmOptions, programId);\n\n    // If a keypair isn't provided, create the account at the owner's ATA for the native mint and return its address\n    if (!keypair) {\n        const associatedToken = getAssociatedTokenAddressSync(\n            nativeMint,\n            owner,\n            false,\n            programId,\n            ASSOCIATED_TOKEN_PROGRAM_ID,\n        );\n\n        const transaction = new Transaction().add(\n            createAssociatedTokenAccountInstruction(\n                payer.publicKey,\n                associatedToken,\n                owner,\n                nativeMint,\n                programId,\n                ASSOCIATED_TOKEN_PROGRAM_ID,\n            ),\n            SystemProgram.transfer({\n                fromPubkey: payer.publicKey,\n                toPubkey: associatedToken,\n                lamports: amount,\n            }),\n            createSyncNativeInstruction(associatedToken, programId),\n        );\n\n        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n        return associatedToken;\n    }\n\n    // Otherwise, create the account with the provided keypair and return its public key\n    const lamports = await getMinimumBalanceForRentExemptAccount(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: ACCOUNT_SIZE,\n            lamports,\n            programId,\n        }),\n        SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: keypair.publicKey,\n            lamports: amount,\n        }),\n        createInitializeAccountInstruction(keypair.publicKey, nativeMint, owner, programId),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Create and initialize a new associated token account\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint for the account\n * @param owner                    Owner of the new account\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n *\n * @return Address of the new associated token account\n */\nexport async function createAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n    allowOwnerOffCurve = false,\n): Promise<PublicKey> {\n    const associatedToken = getAssociatedTokenAddressSync(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    const transaction = new Transaction().add(\n        createAssociatedTokenAccountInstruction(\n            payer.publicKey,\n            associatedToken,\n            owner,\n            mint,\n            programId,\n            associatedTokenProgramId,\n        ),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n\n    return associatedToken;\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey } from '@solana/web3.js';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\nimport { NATIVE_MINT_2022, programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface CreateNativeMintInstructionData {\n    instruction: TokenInstruction.CreateNativeMint;\n}\n\n/** TODO: docs */\nexport const createNativeMintInstructionData = struct<CreateNativeMintInstructionData>([u8('instruction')]);\n\n/**\n * Construct a CreateNativeMint instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     Owner of the new account\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createCreateNativeMintInstruction(\n    payer: PublicKey,\n    nativeMintId = NATIVE_MINT_2022,\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [\n        { pubkey: payer, isSigner: true, isWritable: true },\n        { pubkey: nativeMintId, isSigner: false, isWritable: true },\n        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },\n    ];\n\n    const data = Buffer.alloc(createNativeMintInstructionData.span);\n    createNativeMintInstructionData.encode({ instruction: TokenInstruction.CreateNativeMint }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, Commitment, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { createTransferCheckedInstruction } from '../../instructions/transferChecked.js';\nimport { createTransferCheckedWithFeeInstruction } from '../transferFee/instructions.js';\nimport { getMint } from '../../state/mint.js';\nimport { getExtraAccountMetaAddress, getExtraAccountMetas, getTransferHook, resolveExtraAccountMeta } from './state.js';\n\nexport enum TransferHookInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\n/** Deserialized instruction for the initiation of an transfer hook */\nexport interface InitializeTransferHookInstructionData {\n    instruction: TokenInstruction.TransferHookExtension;\n    transferHookInstruction: TransferHookInstruction.Initialize;\n    authority: PublicKey;\n    transferHookProgramId: PublicKey;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeTransferHookInstructionData = struct<InitializeTransferHookInstructionData>([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('authority'),\n    publicKey('transferHookProgramId'),\n]);\n\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferHookInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeTransferHookInstructionData.span);\n    initializeTransferHookInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferHookExtension,\n            transferHookInstruction: TransferHookInstruction.Initialize,\n            authority,\n            transferHookProgramId,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** Deserialized instruction for the initiation of an transfer hook */\nexport interface UpdateTransferHookInstructionData {\n    instruction: TokenInstruction.TransferHookExtension;\n    transferHookInstruction: TransferHookInstruction.Update;\n    transferHookProgramId: PublicKey;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const updateTransferHookInstructionData = struct<UpdateTransferHookInstructionData>([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('transferHookProgramId'),\n]);\n\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateTransferHookInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(updateTransferHookInstructionData.span);\n    updateTransferHookInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferHookExtension,\n            transferHookInstruction: TransferHookInstruction.Update,\n            transferHookProgramId,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\nfunction deEscalateAccountMeta(accountMeta: AccountMeta, accountMetas: AccountMeta[]): AccountMeta {\n    const maybeHighestPrivileges = accountMetas\n        .filter(x => x.pubkey.equals(accountMeta.pubkey))\n        .reduce<{ isSigner: boolean; isWritable: boolean } | undefined>((acc, x) => {\n            if (!acc) return { isSigner: x.isSigner, isWritable: x.isWritable };\n            return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };\n        }, undefined);\n    if (maybeHighestPrivileges) {\n        const { isSigner, isWritable } = maybeHighestPrivileges;\n        if (!isSigner && isSigner !== accountMeta.isSigner) {\n            accountMeta.isSigner = false;\n        }\n        if (!isWritable && isWritable !== accountMeta.isWritable) {\n            accountMeta.isWritable = false;\n        }\n    }\n    return accountMeta;\n}\n\n/**\n * Construct an `ExecuteInstruction` for a transfer hook program, without the\n * additional accounts\n *\n * @param programId             The program ID of the transfer hook program\n * @param source                The source account\n * @param mint                  The mint account\n * @param destination           The destination account\n * @param owner                 Owner of the source account\n * @param validateStatePubkey   The validate state pubkey\n * @param amount                The amount of tokens to transfer\n * @returns Instruction to add to a transaction\n */\nexport function createExecuteInstruction(\n    programId: PublicKey,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    validateStatePubkey: PublicKey,\n    amount: bigint,\n): TransactionInstruction {\n    const keys = [source, mint, destination, owner, validateStatePubkey].map(pubkey => ({\n        pubkey,\n        isSigner: false,\n        isWritable: false,\n    }));\n\n    const data = Buffer.alloc(16);\n    data.set(Buffer.from([105, 37, 101, 197, 75, 251, 102, 26]), 0); // `ExecuteInstruction` discriminator\n    data.writeBigUInt64LE(BigInt(amount), 8);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/**\n * Adds all the extra accounts needed for a transfer hook to an instruction.\n *\n * Note this will modify the instruction passed in.\n *\n * @param connection            Connection to use\n * @param instruction           The instruction to add accounts to\n * @param programId             Transfer hook program ID\n * @param source                The source account\n * @param mint                  The mint account\n * @param destination           The destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param commitment            Commitment to use\n */\nexport async function addExtraAccountMetasForExecute(\n    connection: Connection,\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: number | bigint,\n    commitment?: Commitment,\n) {\n    const validateStatePubkey = getExtraAccountMetaAddress(mint, programId);\n    const validateStateAccount = await connection.getAccountInfo(validateStatePubkey, commitment);\n    if (validateStateAccount == null) {\n        return instruction;\n    }\n    const validateStateData = getExtraAccountMetas(validateStateAccount);\n\n    // Check to make sure the provided keys are in the instruction\n    if (![source, mint, destination, owner].every(key => instruction.keys.some(meta => meta.pubkey.equals(key)))) {\n        throw new Error('Missing required account in instruction');\n    }\n\n    const executeInstruction = createExecuteInstruction(\n        programId,\n        source,\n        mint,\n        destination,\n        owner,\n        validateStatePubkey,\n        BigInt(amount),\n    );\n\n    for (const extraAccountMeta of validateStateData) {\n        executeInstruction.keys.push(\n            deEscalateAccountMeta(\n                await resolveExtraAccountMeta(\n                    connection,\n                    extraAccountMeta,\n                    executeInstruction.keys,\n                    executeInstruction.data,\n                    executeInstruction.programId,\n                ),\n                executeInstruction.keys,\n            ),\n        );\n    }\n\n    // Add only the extra accounts resolved from the validation state\n    instruction.keys.push(...executeInstruction.keys.slice(5));\n\n    // Add the transfer hook program ID and the validation state account\n    instruction.keys.push({ pubkey: programId, isSigner: false, isWritable: false });\n    instruction.keys.push({ pubkey: validateStatePubkey, isSigner: false, isWritable: false });\n}\n\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithTransferHookInstruction(\n    connection: Connection,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n) {\n    const instruction = createTransferCheckedInstruction(\n        source,\n        mint,\n        destination,\n        owner,\n        amount,\n        decimals,\n        multiSigners,\n        programId,\n    );\n\n    const mintInfo = await getMint(connection, mint, commitment, programId);\n    const transferHook = getTransferHook(mintInfo);\n\n    if (transferHook) {\n        await addExtraAccountMetasForExecute(\n            connection,\n            instruction,\n            transferHook.programId,\n            source,\n            mint,\n            destination,\n            owner,\n            amount,\n            commitment,\n        );\n    }\n\n    return instruction;\n}\n\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param owner                 Owner of the source account\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithFeeAndTransferHookInstruction(\n    connection: Connection,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID,\n) {\n    const instruction = createTransferCheckedWithFeeInstruction(\n        source,\n        mint,\n        destination,\n        owner,\n        amount,\n        decimals,\n        fee,\n        multiSigners,\n        programId,\n    );\n\n    const mintInfo = await getMint(connection, mint, commitment, programId);\n    const transferHook = getTransferHook(mintInfo);\n\n    if (transferHook) {\n        await addExtraAccountMetasForExecute(\n            connection,\n            instruction,\n            transferHook.programId,\n            source,\n            mint,\n            destination,\n            owner,\n            amount,\n            commitment,\n        );\n    }\n\n    return instruction;\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** Deserialized instruction for the initiation of an immutable owner account */\nexport interface InitializeImmutableOwnerInstructionData {\n    instruction: TokenInstruction.InitializeImmutableOwner;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeImmutableOwnerInstructionData = struct<InitializeImmutableOwnerInstructionData>([\n    u8('instruction'),\n]);\n\n/**\n * Construct an InitializeImmutableOwner instruction\n *\n * @param account           Immutable Owner Account\n * @param programId         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeImmutableOwnerInstruction(\n    account: PublicKey,\n    programId: PublicKey,\n): TransactionInstruction {\n    const keys = [{ pubkey: account, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeImmutableOwnerInstructionData.span);\n    initializeImmutableOwnerInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeImmutableOwner,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeImmutableOwner instruction */\nexport interface DecodedInitializeImmutableOwnerInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeImmutableOwner;\n    };\n}\n\n/**\n * Decode an InitializeImmutableOwner instruction and validate it\n *\n * @param instruction InitializeImmutableOwner instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeImmutableOwnerInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedInitializeImmutableOwnerInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeImmutableOwnerInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account },\n        data,\n    } = decodeInitializeImmutableOwnerInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeImmutableOwner) throw new TokenInvalidInstructionTypeError();\n    if (!account) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeImmutableOwner instruction */\nexport interface DecodedInitializeImmutableOwnerInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode an InitializeImmutableOwner instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeImmutableOwnerInstructionUnchecked({\n    programId,\n    keys: [account],\n    data,\n}: TransactionInstruction): DecodedInitializeImmutableOwnerInstructionUnchecked {\n    const { instruction } = initializeImmutableOwnerInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            account: account,\n        },\n        data: {\n            instruction,\n        },\n    };\n}\n","import { blob } from '@solana/buffer-layout';\nimport { PublicKey } from '@solana/web3.js';\nimport { encodeDecode } from './base.mjs';\nexport const publicKey = (property) => {\n    const layout = blob(32, property);\n    const { encode, decode } = encodeDecode(layout);\n    const publicKeyLayout = layout;\n    publicKeyLayout.decode = (buffer, offset) => {\n        const src = decode(buffer, offset);\n        return new PublicKey(src);\n    };\n    publicKeyLayout.encode = (publicKey, buffer, offset) => {\n        const src = publicKey.toBuffer();\n        return encode(src, buffer, offset);\n    };\n    return publicKeyLayout;\n};\n//# sourceMappingURL=web3.js.map","import BigNumber from 'bignumber.js';\nimport { encodeDecode } from './base.mjs';\nimport { u128 } from './bigint.mjs';\nexport const WAD = new BigNumber('1e+18');\nexport const decimal = (property) => {\n    const layout = u128(property);\n    const { encode, decode } = encodeDecode(layout);\n    const decimalLayout = layout;\n    decimalLayout.decode = (buffer, offset) => {\n        const src = decode(buffer, offset).toString();\n        return new BigNumber(src).div(WAD);\n    };\n    decimalLayout.encode = (decimal, buffer, offset) => {\n        const src = BigInt(decimal.times(WAD).integerValue().toString());\n        return encode(src, buffer, offset);\n    };\n    return decimalLayout;\n};\n//# sourceMappingURL=decimal.js.map","import type { Commitment, Connection } from '@solana/web3.js';\nimport type { PublicKey } from '@solana/web3.js';\nimport type { TokenMetadata } from '@solana/spl-token-metadata';\nimport { Field, unpack } from '@solana/spl-token-metadata';\n\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nimport { getMint } from '../../state/mint.js';\n\nconst getNormalizedTokenMetadataField = (field: Field | string): string => {\n    if (field === Field.Name || field === 'Name' || field === 'name') {\n        return 'name';\n    }\n\n    if (field === Field.Symbol || field === 'Symbol' || field === 'symbol') {\n        return 'symbol';\n    }\n\n    if (field === Field.Uri || field === 'Uri' || field === 'uri') {\n        return 'uri';\n    }\n\n    return field;\n};\n\nexport function updateTokenMetadata(current: TokenMetadata, key: Field | string, value: string): TokenMetadata {\n    const field = getNormalizedTokenMetadataField(key);\n\n    if (field === 'mint' || field === 'updateAuthority') {\n        throw new Error(`Cannot update ${field} via this instruction`);\n    }\n\n    // Handle updates to default keys\n    if (['name', 'symbol', 'uri'].includes(field)) {\n        return {\n            ...current,\n            [field]: value,\n        };\n    }\n\n    // Avoid mutating input, make a shallow copy\n    const additionalMetadata = [...current.additionalMetadata];\n\n    const i = current.additionalMetadata.findIndex(x => x[0] === field);\n\n    if (i === -1) {\n        // Key was not found, add it\n        additionalMetadata.push([field, value]);\n    } else {\n        // Key was found, change value\n        additionalMetadata[i] = [field, value];\n    }\n\n    return {\n        ...current,\n        additionalMetadata,\n    };\n}\n\n/**\n * Retrieve Token Metadata Information\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token Metadata information\n */\nexport async function getTokenMetadata(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TokenMetadata | null> {\n    const mintInfo = await getMint(connection, address, commitment, programId);\n    const data = getExtensionData(ExtensionType.TokenMetadata, mintInfo.tlvData);\n\n    if (data === null) {\n        return null;\n    }\n\n    return unpack(data);\n}\n","import { struct } from '@solana/buffer-layout';\nimport type { Account } from '../state/account.js';\nimport type { Mint } from '../state/mint.js';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n\n/** Non-transferable mint state as stored by the program */\nexport interface NonTransferable {} // eslint-disable-line\n\n/** Non-transferable token account state as stored by the program */\nexport interface NonTransferableAccount {} // eslint-disable-line\n\n/** Buffer layout for de/serializing an account */\nexport const NonTransferableLayout = struct<NonTransferable>([]);\n\nexport const NON_TRANSFERABLE_SIZE = NonTransferableLayout.span;\nexport const NON_TRANSFERABLE_ACCOUNT_SIZE = NonTransferableLayout.span;\n\nexport function getNonTransferable(mint: Mint): NonTransferable | null {\n    const extensionData = getExtensionData(ExtensionType.NonTransferable, mint.tlvData);\n    if (extensionData !== null) {\n        return NonTransferableLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n\nexport function getNonTransferableAccount(account: Account): NonTransferableAccount | null {\n    const extensionData = getExtensionData(ExtensionType.NonTransferableAccount, account.tlvData);\n    if (extensionData !== null) {\n        return NonTransferableLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n","import type { ConfirmOptions, Connection, Signer, TransactionSignature } from '@solana/web3.js';\nimport type { PublicKey } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport {\n    createInitializeTransferHookInstruction,\n    createTransferCheckedWithFeeAndTransferHookInstruction,\n    createTransferCheckedWithTransferHookInstruction,\n    createUpdateTransferHookInstruction,\n} from './instructions.js';\n\n/**\n * Initialize a transfer hook on a mint\n *\n * @param connection            Connection to use\n * @param payer                 Payer of the transaction fees\n * @param mint                  Mint to initialize with extension\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId The transfer hook program account\n * @param confirmOptions        Options for confirming the transaction\n * @param programId             SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function initializeTransferHook(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(\n        createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n\n/**\n * Update the transfer hook program on a mint\n *\n * @param connection            Connection to use\n * @param payer                 Payer of the transaction fees\n * @param mint                  Mint to modify\n * @param transferHookProgramId New transfer hook program account\n * @param authority             Transfer hook update authority\n * @param multiSigners          Signing accounts if `freezeAuthority` is a multisig\n * @param confirmOptions        Options for confirming the transaction\n * @param programId             SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateTransferHook(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    transferHookProgramId: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateTransferHookInstruction(mint, authorityPublicKey, transferHookProgramId, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Transfer tokens from one account to another, asserting the token mint, and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param authority      Authority of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferCheckedWithTransferHook(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        await createTransferCheckedWithTransferHookInstruction(\n            connection,\n            source,\n            mint,\n            destination,\n            authorityPublicKey,\n            amount,\n            decimals,\n            signers,\n            confirmOptions?.commitment,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Transfer tokens from one account to another, asserting the transfer fee, token mint, and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param authority      Authority of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param fee            The calculated fee for the transfer fee extension\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferCheckedWithFeeAndTransferHook(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        await createTransferCheckedWithFeeAndTransferHookInstruction(\n            connection,\n            source,\n            mint,\n            destination,\n            authorityPublicKey,\n            amount,\n            decimals,\n            fee,\n            signers,\n            confirmOptions?.commitment,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u32 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport {\n    unpackTokenGroup,\n    unpackTokenGroupMember,\n    type TokenGroup,\n    type TokenGroupMember,\n} from '@solana/spl-token-group';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\nexport { TOKEN_GROUP_SIZE, TOKEN_GROUP_MEMBER_SIZE } from '@solana/spl-token-group';\n\nexport function getTokenGroupState(mint: Mint): Partial<TokenGroup> | null {\n    const extensionData = getExtensionData(ExtensionType.TokenGroup, mint.tlvData);\n    if (extensionData !== null) {\n        const { updateAuthority, mint, size, maxSize } = unpackTokenGroup(extensionData);\n\n        // Explicitly set None/Zero keys to null\n        return {\n            updateAuthority: updateAuthority?.equals(PublicKey.default) ? undefined : updateAuthority,\n            mint,\n            size,\n            maxSize,\n        };\n    } else {\n        return null;\n    }\n}\n\nexport function getTokenGroupMemberState(mint: Mint): Partial<TokenGroupMember> | null {\n    const extensionData = getExtensionData(ExtensionType.TokenGroupMember, mint.tlvData);\n    if (extensionData !== null) {\n        const { mint, group, memberNumber } = unpackTokenGroupMember(extensionData);\n\n        return {\n            mint,\n            group,\n            memberNumber,\n        };\n    } else {\n        return null;\n    }\n}\n","import { u64 } from '@solana/buffer-layout-utils';\nimport type { Connection, PublicKey, Signer, TransactionError } from '@solana/web3.js';\nimport { Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createUiAmountToAmountInstruction } from '../instructions/uiAmountToAmount.js';\n\n/**\n * Amount as a string using mint-prescribed decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param amount         Ui Amount of tokens to be converted to Amount\n * @param programId      SPL Token program account\n *\n * @return Ui Amount generated\n */\nexport async function uiAmountToAmount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    amount: string,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<bigint | TransactionError | null> {\n    const transaction = new Transaction().add(createUiAmountToAmountInstruction(mint, amount, programId));\n    const { returnData, err } = (await connection.simulateTransaction(transaction, [payer], false)).value;\n    if (returnData) {\n        const data = Buffer.from(returnData.data[0], returnData.data[1]);\n        return u64().decode(data);\n    }\n    return err;\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountState } from '../../state/account.js';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\n\n/** DefaultAccountState as stored by the program */\nexport interface DefaultAccountState {\n    /** Default AccountState in which new accounts are initialized */\n    state: AccountState;\n}\n\n/** Buffer layout for de/serializing a transfer fee config extension */\nexport const DefaultAccountStateLayout = struct<DefaultAccountState>([u8('state')]);\n\nexport const DEFAULT_ACCOUNT_STATE_SIZE = DefaultAccountStateLayout.span;\n\nexport function getDefaultAccountState(mint: Mint): DefaultAccountState | null {\n    const extensionData = getExtensionData(ExtensionType.DefaultAccountState, mint.tlvData);\n    if (extensionData !== null) {\n        return DefaultAccountStateLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createInitializeMultisigInstruction } from '../instructions/initializeMultisig.js';\nimport { getMinimumBalanceForRentExemptMultisig, MULTISIG_SIZE } from '../state/multisig.js';\n\n/**\n * Create and initialize a new multisig\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param signers        Full set of signers\n * @param m              Number of required signatures\n * @param keypair        Optional keypair, defaulting to a new random one\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new multisig\n */\nexport async function createMultisig(\n    connection: Connection,\n    payer: Signer,\n    signers: PublicKey[],\n    m: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<PublicKey> {\n    const lamports = await getMinimumBalanceForRentExemptMultisig(connection);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: MULTISIG_SIZE,\n            lamports,\n            programId,\n        }),\n        createInitializeMultisigInstruction(keypair.publicKey, signers, m, programId),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n","import type { Encoder } from '@solana/codecs';\nimport type { PublicKey } from '@solana/web3.js';\nimport {\n    fixEncoderSize,\n    getBytesEncoder,\n    getStructEncoder,\n    getTupleEncoder,\n    getU64Encoder,\n    transformEncoder,\n} from '@solana/codecs';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\n\nfunction getInstructionEncoder<T extends object>(discriminator: Uint8Array, dataEncoder: Encoder<T>): Encoder<T> {\n    return transformEncoder(getTupleEncoder([getBytesEncoder(), dataEncoder]), (data: T): [Uint8Array, T] => [\n        discriminator,\n        data,\n    ]);\n}\n\nfunction getPublicKeyEncoder(): Encoder<PublicKey> {\n    return transformEncoder(fixEncoderSize(getBytesEncoder(), 32), (publicKey: PublicKey) => publicKey.toBytes());\n}\n\nexport interface InitializeGroupInstruction {\n    programId: PublicKey;\n    group: PublicKey;\n    mint: PublicKey;\n    mintAuthority: PublicKey;\n    updateAuthority: PublicKey | null;\n    maxSize: bigint;\n}\n\nexport function createInitializeGroupInstruction(args: InitializeGroupInstruction): TransactionInstruction {\n    const { programId, group, mint, mintAuthority, updateAuthority, maxSize } = args;\n\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: false, isWritable: false, pubkey: mint },\n            { isSigner: true, isWritable: false, pubkey: mintAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_group_interface:initialize_token_group') */\n                    121, 113, 108, 39, 54, 51, 0, 4,\n                ]),\n                getStructEncoder([\n                    ['updateAuthority', getPublicKeyEncoder()],\n                    ['maxSize', getU64Encoder()],\n                ]),\n            ).encode({ updateAuthority: updateAuthority ?? SystemProgram.programId, maxSize }),\n        ),\n    });\n}\n\nexport interface UpdateGroupMaxSize {\n    programId: PublicKey;\n    group: PublicKey;\n    updateAuthority: PublicKey;\n    maxSize: bigint;\n}\n\nexport function createUpdateGroupMaxSizeInstruction(args: UpdateGroupMaxSize): TransactionInstruction {\n    const { programId, group, updateAuthority, maxSize } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: true, isWritable: false, pubkey: updateAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_group_interface:update_group_max_size') */\n                    108, 37, 171, 143, 248, 30, 18, 110,\n                ]),\n                getStructEncoder([['maxSize', getU64Encoder()]]),\n            ).encode({ maxSize }),\n        ),\n    });\n}\n\nexport interface UpdateGroupAuthority {\n    programId: PublicKey;\n    group: PublicKey;\n    currentAuthority: PublicKey;\n    newAuthority: PublicKey | null;\n}\n\nexport function createUpdateGroupAuthorityInstruction(args: UpdateGroupAuthority): TransactionInstruction {\n    const { programId, group, currentAuthority, newAuthority } = args;\n\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: true, isWritable: false, pubkey: currentAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_group_interface:update_authority') */\n                    161, 105, 88, 1, 237, 221, 216, 203,\n                ]),\n                getStructEncoder([['newAuthority', getPublicKeyEncoder()]]),\n            ).encode({ newAuthority: newAuthority ?? SystemProgram.programId }),\n        ),\n    });\n}\n\nexport interface InitializeMember {\n    programId: PublicKey;\n    member: PublicKey;\n    memberMint: PublicKey;\n    memberMintAuthority: PublicKey;\n    group: PublicKey;\n    groupUpdateAuthority: PublicKey;\n}\n\nexport function createInitializeMemberInstruction(args: InitializeMember): TransactionInstruction {\n    const { programId, member, memberMint, memberMintAuthority, group, groupUpdateAuthority } = args;\n\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: member },\n            { isSigner: false, isWritable: false, pubkey: memberMint },\n            { isSigner: true, isWritable: false, pubkey: memberMintAuthority },\n            { isSigner: false, isWritable: true, pubkey: group },\n            { isSigner: true, isWritable: false, pubkey: groupUpdateAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_group_interface:initialize_member') */\n                    152, 32, 222, 176, 223, 237, 116, 134,\n                ]),\n                getStructEncoder([]),\n            ).encode({}),\n        ),\n    });\n}\n","import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given number is between a given range.\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import type { Encoder } from '@solana/codecs';\nimport {\n    addEncoderSizePrefix,\n    fixEncoderSize,\n    getBooleanEncoder,\n    getBytesEncoder,\n    getDataEnumCodec,\n    getOptionEncoder,\n    getUtf8Encoder,\n    getStructEncoder,\n    getTupleEncoder,\n    getU32Encoder,\n    getU64Encoder,\n    transformEncoder,\n} from '@solana/codecs';\nimport type { VariableSizeEncoder } from '@solana/codecs';\nimport type { PublicKey } from '@solana/web3.js';\nimport { SystemProgram, TransactionInstruction } from '@solana/web3.js';\n\nimport type { Field } from './field.js';\nimport { getFieldCodec, getFieldConfig } from './field.js';\n\nfunction getInstructionEncoder<T extends object>(discriminator: Uint8Array, dataEncoder: Encoder<T>): Encoder<T> {\n    return transformEncoder(getTupleEncoder([getBytesEncoder(), dataEncoder]), (data: T): [Uint8Array, T] => [\n        discriminator,\n        data,\n    ]);\n}\n\nfunction getPublicKeyEncoder(): Encoder<PublicKey> {\n    return transformEncoder(fixEncoderSize(getBytesEncoder(), 32), (publicKey: PublicKey) => publicKey.toBytes());\n}\n\nfunction getStringEncoder(): VariableSizeEncoder<string> {\n    return addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n}\n\n/**\n * Initializes a TLV entry with the basic token-metadata fields.\n *\n * Assumes that the provided mint is an SPL token mint, that the metadata\n * account is allocated and assigned to the program, and that the metadata\n * account has enough lamports to cover the rent-exempt reserve.\n */\nexport interface InitializeInstructionArgs {\n    programId: PublicKey;\n    metadata: PublicKey;\n    updateAuthority: PublicKey;\n    mint: PublicKey;\n    mintAuthority: PublicKey;\n    name: string;\n    symbol: string;\n    uri: string;\n}\n\nexport function createInitializeInstruction(args: InitializeInstructionArgs): TransactionInstruction {\n    const { programId, metadata, updateAuthority, mint, mintAuthority, name, symbol, uri } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: metadata },\n            { isSigner: false, isWritable: false, pubkey: updateAuthority },\n            { isSigner: false, isWritable: false, pubkey: mint },\n            { isSigner: true, isWritable: false, pubkey: mintAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_metadata_interface:initialize_account') */\n                    210, 225, 30, 162, 88, 184, 77, 141,\n                ]),\n                getStructEncoder([\n                    ['name', getStringEncoder()],\n                    ['symbol', getStringEncoder()],\n                    ['uri', getStringEncoder()],\n                ]),\n            ).encode({ name, symbol, uri }),\n        ),\n    });\n}\n\n/**\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n */\nexport interface UpdateFieldInstruction {\n    programId: PublicKey;\n    metadata: PublicKey;\n    updateAuthority: PublicKey;\n    field: Field | string;\n    value: string;\n}\n\nexport function createUpdateFieldInstruction(args: UpdateFieldInstruction): TransactionInstruction {\n    const { programId, metadata, updateAuthority, field, value } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: metadata },\n            { isSigner: true, isWritable: false, pubkey: updateAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_metadata_interface:updating_field') */\n                    221, 233, 49, 45, 181, 202, 220, 200,\n                ]),\n                getStructEncoder([\n                    ['field', getDataEnumCodec(getFieldCodec())],\n                    ['value', getStringEncoder()],\n                ]),\n            ).encode({ field: getFieldConfig(field), value }),\n        ),\n    });\n}\n\nexport interface RemoveKeyInstructionArgs {\n    programId: PublicKey;\n    metadata: PublicKey;\n    updateAuthority: PublicKey;\n    key: string;\n    idempotent: boolean;\n}\n\nexport function createRemoveKeyInstruction(args: RemoveKeyInstructionArgs) {\n    const { programId, metadata, updateAuthority, key, idempotent } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: metadata },\n            { isSigner: true, isWritable: false, pubkey: updateAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_metadata_interface:remove_key_ix') */\n                    234, 18, 32, 56, 89, 141, 37, 181,\n                ]),\n                getStructEncoder([\n                    ['idempotent', getBooleanEncoder()],\n                    ['key', getStringEncoder()],\n                ]),\n            ).encode({ idempotent, key }),\n        ),\n    });\n}\n\nexport interface UpdateAuthorityInstructionArgs {\n    programId: PublicKey;\n    metadata: PublicKey;\n    oldAuthority: PublicKey;\n    newAuthority: PublicKey | null;\n}\n\nexport function createUpdateAuthorityInstruction(args: UpdateAuthorityInstructionArgs): TransactionInstruction {\n    const { programId, metadata, oldAuthority, newAuthority } = args;\n\n    return new TransactionInstruction({\n        programId,\n        keys: [\n            { isSigner: false, isWritable: true, pubkey: metadata },\n            { isSigner: true, isWritable: false, pubkey: oldAuthority },\n        ],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_metadata_interface:update_the_authority') */\n                    215, 228, 166, 228, 84, 100, 86, 123,\n                ]),\n                getStructEncoder([['newAuthority', getPublicKeyEncoder()]]),\n            ).encode({ newAuthority: newAuthority ?? SystemProgram.programId }),\n        ),\n    });\n}\n\nexport interface EmitInstructionArgs {\n    programId: PublicKey;\n    metadata: PublicKey;\n    start?: bigint;\n    end?: bigint;\n}\n\nexport function createEmitInstruction(args: EmitInstructionArgs): TransactionInstruction {\n    const { programId, metadata, start, end } = args;\n    return new TransactionInstruction({\n        programId,\n        keys: [{ isSigner: false, isWritable: false, pubkey: metadata }],\n        data: Buffer.from(\n            getInstructionEncoder(\n                new Uint8Array([\n                    /* await splDiscriminate('spl_token_metadata_interface:emitter') */\n                    250, 166, 180, 250, 13, 12, 184, 70,\n                ]),\n                getStructEncoder([\n                    ['start', getOptionEncoder(getU64Encoder())],\n                    ['end', getOptionEncoder(getU64Encoder())],\n                ]),\n            ).encode({ start: start ?? null, end: end ?? null }),\n        ),\n    });\n}\n","/** Instructions defined by the program */\nexport enum TokenInstruction {\n    InitializeMint = 0,\n    InitializeAccount = 1,\n    InitializeMultisig = 2,\n    Transfer = 3,\n    Approve = 4,\n    Revoke = 5,\n    SetAuthority = 6,\n    MintTo = 7,\n    Burn = 8,\n    CloseAccount = 9,\n    FreezeAccount = 10,\n    ThawAccount = 11,\n    TransferChecked = 12,\n    ApproveChecked = 13,\n    MintToChecked = 14,\n    BurnChecked = 15,\n    InitializeAccount2 = 16,\n    SyncNative = 17,\n    InitializeAccount3 = 18,\n    InitializeMultisig2 = 19,\n    InitializeMint2 = 20,\n    GetAccountDataSize = 21,\n    InitializeImmutableOwner = 22,\n    AmountToUiAmount = 23,\n    UiAmountToAmount = 24,\n    InitializeMintCloseAuthority = 25,\n    TransferFeeExtension = 26,\n    ConfidentialTransferExtension = 27,\n    DefaultAccountStateExtension = 28,\n    Reallocate = 29,\n    MemoTransferExtension = 30,\n    CreateNativeMint = 31,\n    InitializeNonTransferableMint = 32,\n    InterestBearingMintExtension = 33,\n    CpiGuardExtension = 34,\n    InitializePermanentDelegate = 35,\n    TransferHookExtension = 36,\n    // ConfidentialTransferFeeExtension = 37,\n    // WithdrawalExcessLamports = 38,\n    MetadataPointerExtension = 39,\n    GroupPointerExtension = 40,\n    GroupMemberPointerExtension = 41,\n    // ConfidentialMintBurnExtension = 42,\n    ScaledUiAmountExtension = 43,\n    PausableExtension = 44,\n}\n","import type { Connection, Signer, TransactionError } from '@solana/web3.js';\nimport { PublicKey, Transaction } from '@solana/web3.js';\nimport { TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createAmountToUiAmountInstruction } from '../instructions/amountToUiAmount.js';\nimport { unpackMint } from '../state/mint.js';\nimport { getInterestBearingMintConfigState } from '../extensions/interestBearingMint/state.js';\nimport { getScaledUiAmountConfig } from '../extensions/scaledUiAmount/state.js';\n\n// Constants for interest calculations\nconst ONE_IN_BASIS_POINTS = 10000;\nconst SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\n\n/**\n * Amount as a string using mint-prescribed decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param amount         Amount of tokens to be converted to Ui Amount\n * @param programId      SPL Token program account\n *\n * @return Ui Amount generated or error\n */\nexport async function amountToUiAmount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    amount: number | bigint,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<string | TransactionError | null> {\n    const transaction = new Transaction().add(createAmountToUiAmountInstruction(mint, amount, programId));\n    const { returnData, err } = (await connection.simulateTransaction(transaction, [payer], false)).value;\n\n    if (returnData?.data) {\n        return Buffer.from(returnData.data[0], returnData.data[1]).toString('utf-8');\n    }\n    return err;\n}\n\n/**\n * Calculates the exponent for the interest rate formula.\n * @param t1 - The start time in seconds.\n * @param t2 - The end time in seconds.\n * @param r - The interest rate in basis points.\n * @returns The calculated exponent.\n */\nfunction calculateExponentForTimesAndRate(t1: number, t2: number, r: number): number {\n    const timespan = t2 - t1;\n    const numerator = r * timespan;\n    const exponent = numerator / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS);\n    return Math.exp(exponent);\n}\n\n/**\n * Retrieves the current timestamp from the Solana clock sysvar.\n * @param connection - The Solana connection object.\n * @returns A promise that resolves to the current timestamp in seconds.\n * @throws An error if the sysvar clock cannot be fetched or parsed.\n */\nasync function getSysvarClockTimestamp(connection: Connection): Promise<number> {\n    const info = await connection.getParsedAccountInfo(SYSVAR_CLOCK_PUBKEY);\n\n    if (!info?.value) {\n        throw new Error('Failed to fetch sysvar clock');\n    }\n\n    if (typeof info.value === 'object' && 'data' in info.value && 'parsed' in info.value.data) {\n        return info.value.data.parsed.info.unixTimestamp;\n    }\n\n    throw new Error('Failed to parse sysvar clock');\n}\n\n/**\n * Calculates the decimal factor for a given number of decimals\n * @param decimals - Number of decimals\n * @returns The decimal factor (e.g., 100 for 2 decimals)\n */\nfunction getDecimalFactor(decimals: number): number {\n    return Math.pow(10, decimals);\n}\n\n/**\n * Convert a UI amount to an atomic amount by removing decimal scaling\n * For example, converts \"1.234\" with 3 decimals to 1234 (atomic units)\n *\n * @param uiAmount       UI Amount to be converted to atomic UI amount\n * @param decimals       Number of decimals for the mint\n *\n * @return Atomic UI amount\n */\nfunction uiAmountToAtomicUiAmount(uiAmount: string, decimals: number): number {\n    const uiAmountNumber = parseFloat(uiAmount);\n    const decimalFactor = getDecimalFactor(decimals);\n    return uiAmountNumber * decimalFactor;\n}\n\n/**\n * Convert amount to UiAmount for a mint with interest bearing extension without simulating a transaction\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n *\n * Formula: A = P * e^(r * t) where\n * A = final amount after interest\n * P = principal amount (initial investment)\n * r = annual interest rate (as a decimal)\n * t = time in years\n * e = mathematical constant (~2.718)\n *\n * In this case, we are calculating the total scale factor for the interest bearing extension which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 and r2 are the interest rates before and after the last update, and t1 and t2 are the times in years between\n * the initialization timestamp and the last update timestamp, and between the last update timestamp and the current timestamp.\n *\n * @param amount                   Amount of tokens to be converted\n * @param decimals                 Number of decimals of the mint\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points (1 basis point = 0.01%) before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @return Amount scaled by accrued interest as a string with appropriate decimal places\n */\nexport function amountToUiAmountForInterestBearingMintWithoutSimulation(\n    amount: bigint,\n    decimals: number,\n    currentTimestamp: number, // in seconds\n    lastUpdateTimestamp: number,\n    initializationTimestamp: number,\n    preUpdateAverageRate: number,\n    currentRate: number,\n): string {\n    // Calculate pre-update exponent (interest accrued from initialization to last update)\n    const preUpdateExp = calculateExponentForTimesAndRate(\n        initializationTimestamp,\n        lastUpdateTimestamp,\n        preUpdateAverageRate,\n    );\n\n    // Calculate post-update exponent (interest accrued from last update to current time)\n    const postUpdateExp = calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);\n\n    // Calculate total scale factor\n    const totalScale = preUpdateExp * postUpdateExp;\n\n    // Scale the amount by the total interest factor\n    const scaledAmount = Number(amount) * totalScale;\n\n    // Calculate the decimal factor (e.g. 100 for 2 decimals)\n    const decimalFactor = getDecimalFactor(decimals);\n\n    // Convert to UI amount by truncating and dividing by decimal factor\n    return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n\n/**\n * Convert amount to UiAmount for a mint with scaled UI amount extension\n * @param amount     Amount of tokens to be converted\n * @param decimals   Number of decimals of the mint\n * @param multiplier Multiplier to scale the amount\n * @return Scaled UI amount as a string\n */\nexport function amountToUiAmountForScaledUiAmountMintWithoutSimulation(\n    amount: bigint,\n    decimals: number,\n    multiplier: number,\n): string {\n    const scaledAmount = Number(amount) * multiplier;\n    const decimalFactor = getDecimalFactor(decimals);\n    return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n\n/**\n * Convert amount to UiAmount for a mint without simulating a transaction\n * This implements the same logic as `process_amount_to_ui_amount` in /token/program-2022/src/processor.rs\n * and `process_amount_to_ui_amount` in /token/program/src/processor.rs\n *\n * @param connection     Connection to use\n * @param mint           Mint to use for calculations\n * @param amount         Amount of tokens to be converted to Ui Amount\n *\n * @return Ui Amount generated\n */\nexport async function amountToUiAmountForMintWithoutSimulation(\n    connection: Connection,\n    mint: PublicKey,\n    amount: bigint,\n): Promise<string> {\n    const accountInfo = await connection.getAccountInfo(mint);\n    const programId = accountInfo?.owner;\n\n    if (!programId?.equals(TOKEN_PROGRAM_ID) && !programId?.equals(TOKEN_2022_PROGRAM_ID)) {\n        throw new Error('Invalid program ID');\n    }\n\n    const mintInfo = unpackMint(mint, accountInfo, programId);\n\n    // Check for interest bearing mint extension\n    const interestBearingMintConfigState = getInterestBearingMintConfigState(mintInfo);\n    // Check for scaled UI amount extension\n    const scaledUiAmountConfig = getScaledUiAmountConfig(mintInfo);\n\n    // Standard conversion for regular mints\n    if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n        const decimalFactor = getDecimalFactor(mintInfo.decimals);\n        return (Number(amount) / decimalFactor).toString();\n    }\n\n    // Get timestamp only if needed for special mint types\n    const timestamp = await getSysvarClockTimestamp(connection);\n\n    // Handle interest bearing mint\n    if (interestBearingMintConfigState) {\n        return amountToUiAmountForInterestBearingMintWithoutSimulation(\n            amount,\n            mintInfo.decimals,\n            timestamp,\n            Number(interestBearingMintConfigState.lastUpdateTimestamp),\n            Number(interestBearingMintConfigState.initializationTimestamp),\n            interestBearingMintConfigState.preUpdateAverageRate,\n            interestBearingMintConfigState.currentRate,\n        );\n    }\n\n    // At this point, we know it must be a scaled UI amount mint\n    let multiplier = scaledUiAmountConfig!.multiplier;\n    if (timestamp >= Number(scaledUiAmountConfig!.newMultiplierEffectiveTimestamp)) {\n        multiplier = scaledUiAmountConfig!.newMultiplier;\n    }\n    return amountToUiAmountForScaledUiAmountMintWithoutSimulation(amount, mintInfo.decimals, multiplier);\n}\n\n/**\n * Convert an amount with interest back to the original amount without interest\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n *\n * Formula: P = A / (e^(r * t)) where\n * P = principal\n * A = UI amount\n * r = annual interest rate (as a decimal)\n * t = time in years\n *\n * @param uiAmount                  UI Amount (principal plus continuously compounding interest) to be converted back to original principal\n * @param decimals                  Number of decimals for the mint\n * @param currentTimestamp          Current timestamp in seconds\n * @param lastUpdateTimestamp       Last time the interest rate was updated in seconds\n * @param initializationTimestamp   Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate      Interest rate in basis points (hundredths of a percent) before the last update\n * @param currentRate               Current interest rate in basis points\n *\n * @return Original amount (principal) without interest\n */\nexport function uiAmountToAmountForInterestBearingMintWithoutSimulation(\n    uiAmount: string,\n    decimals: number,\n    currentTimestamp: number, // in seconds\n    lastUpdateTimestamp: number,\n    initializationTimestamp: number,\n    preUpdateAverageRate: number,\n    currentRate: number,\n): bigint {\n    const uiAmountScaled = uiAmountToAtomicUiAmount(uiAmount, decimals);\n\n    // Calculate pre-update exponent\n    const preUpdateExp = calculateExponentForTimesAndRate(\n        initializationTimestamp,\n        lastUpdateTimestamp,\n        preUpdateAverageRate,\n    );\n\n    // Calculate post-update exponent\n    const postUpdateExp = calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);\n\n    // Calculate total scale\n    const totalScale = preUpdateExp * postUpdateExp;\n\n    // Calculate original principal by dividing the UI amount (principal + interest) by the total scale\n    const originalPrincipal = uiAmountScaled / totalScale;\n    return BigInt(Math.trunc(originalPrincipal));\n}\n\n/**\n * Convert a UI amount back to the raw amount for a mint with a scaled UI amount extension\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/scaled_ui_amount/mod.rs\n *\n * @param uiAmount       UI Amount to be converted back to raw amount\n * @param decimals       Number of decimals for the mint\n * @param multiplier     Multiplier for the scaled UI amount\n *\n * @return Raw amount\n */\nexport function uiAmountToAmountForScaledUiAmountMintWithoutSimulation(\n    uiAmount: string,\n    decimals: number,\n    multiplier: number,\n): bigint {\n    const uiAmountScaled = uiAmountToAtomicUiAmount(uiAmount, decimals);\n    const rawAmount = uiAmountScaled / multiplier;\n    return BigInt(Math.trunc(rawAmount));\n}\n\n/**\n * Convert a UI amount back to the raw amount\n *\n * @param connection     Connection to use\n * @param mint           Mint to use for calculations\n * @param uiAmount       UI Amount to be converted back to raw amount\n *\n * @return Raw amount\n */\nexport async function uiAmountToAmountForMintWithoutSimulation(\n    connection: Connection,\n    mint: PublicKey,\n    uiAmount: string,\n): Promise<bigint> {\n    const accountInfo = await connection.getAccountInfo(mint);\n    const programId = accountInfo?.owner;\n\n    if (!programId?.equals(TOKEN_PROGRAM_ID) && !programId?.equals(TOKEN_2022_PROGRAM_ID)) {\n        throw new Error('Invalid program ID');\n    }\n\n    const mintInfo = unpackMint(mint, accountInfo, programId);\n\n    // Check for interest bearing mint extension\n    const interestBearingMintConfigState = getInterestBearingMintConfigState(mintInfo);\n    // Check for scaled UI amount extension\n    const scaledUiAmountConfig = getScaledUiAmountConfig(mintInfo);\n\n    if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n        // Standard conversion for regular mints\n        return BigInt(Math.trunc(uiAmountToAtomicUiAmount(uiAmount, mintInfo.decimals)));\n    }\n\n    const timestamp = await getSysvarClockTimestamp(connection);\n\n    if (interestBearingMintConfigState) {\n        return uiAmountToAmountForInterestBearingMintWithoutSimulation(\n            uiAmount,\n            mintInfo.decimals,\n            timestamp,\n            Number(interestBearingMintConfigState.lastUpdateTimestamp),\n            Number(interestBearingMintConfigState.initializationTimestamp),\n            interestBearingMintConfigState.preUpdateAverageRate,\n            interestBearingMintConfigState.currentRate,\n        );\n    }\n\n    // At this point, we know it must be a scaled UI amount mint\n    let multiplier = scaledUiAmountConfig!.multiplier;\n    if (timestamp >= Number(scaledUiAmountConfig!.newMultiplierEffectiveTimestamp)) {\n        multiplier = scaledUiAmountConfig!.newMultiplier;\n    }\n\n    return uiAmountToAmountForScaledUiAmountMintWithoutSimulation(uiAmount, mintInfo.decimals, multiplier);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport type { Field, TokenMetadata } from '@solana/spl-token-metadata';\nimport {\n    createInitializeInstruction,\n    createRemoveKeyInstruction,\n    createUpdateAuthorityInstruction,\n    createUpdateFieldInstruction,\n    pack,\n    unpack,\n} from '@solana/spl-token-metadata';\n\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { ExtensionType, getExtensionData, getNewAccountLenForExtensionLen } from '../extensionType.js';\nimport { updateTokenMetadata } from './state.js';\nimport { TokenAccountNotFoundError } from '../../errors.js';\nimport { unpackMint } from '../../state/index.js';\n\nasync function getAdditionalRentForNewMetadata(\n    connection: Connection,\n    address: PublicKey,\n    tokenMetadata: TokenMetadata,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<number> {\n    const info = await connection.getAccountInfo(address);\n    if (!info) {\n        throw new TokenAccountNotFoundError();\n    }\n\n    const extensionLen = pack(tokenMetadata).length;\n    const newAccountLen = getNewAccountLenForExtensionLen(\n        info,\n        address,\n        ExtensionType.TokenMetadata,\n        extensionLen,\n        programId,\n    );\n\n    if (newAccountLen <= info.data.length) {\n        return 0;\n    }\n\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n\n    return newRentExemptMinimum - info.lamports;\n}\n\nasync function getAdditionalRentForUpdatedMetadata(\n    connection: Connection,\n    address: PublicKey,\n    field: string | Field,\n    value: string,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<number> {\n    const info = await connection.getAccountInfo(address);\n    if (!info) {\n        throw new TokenAccountNotFoundError();\n    }\n\n    const mint = unpackMint(address, info, programId);\n    const extensionData = getExtensionData(ExtensionType.TokenMetadata, mint.tlvData);\n    if (extensionData === null) {\n        throw new Error('TokenMetadata extension not initialized');\n    }\n\n    const updatedTokenMetadata = updateTokenMetadata(unpack(extensionData), field, value);\n    const extensionLen = pack(updatedTokenMetadata).length;\n\n    const newAccountLen = getNewAccountLenForExtensionLen(\n        info,\n        address,\n        ExtensionType.TokenMetadata,\n        extensionLen,\n        programId,\n    );\n\n    if (newAccountLen <= info.data.length) {\n        return 0;\n    }\n\n    const newRentExemptMinimum = await connection.getMinimumBalanceForRentExemption(newAccountLen);\n\n    return newRentExemptMinimum - info.lamports;\n}\n\n/**\n * Initializes a TLV entry with the basic token-metadata fields.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitialize(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    name: string,\n    symbol: string,\n    uri: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createInitializeInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            name,\n            symbol,\n            uri,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Initializes a TLV entry with the basic token-metadata fields,\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param mintAuthority    Mint Authority\n * @param name             Longer name of token\n * @param symbol           Shortened symbol of token\n * @param uri              URI pointing to more metadata (image, video, etc)\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataInitializeWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    name: string,\n    symbol: string,\n    uri: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction();\n\n    const lamports = await getAdditionalRentForNewMetadata(\n        connection,\n        mint,\n        {\n            updateAuthority,\n            mint,\n            name,\n            symbol,\n            uri,\n            additionalMetadata: [],\n        },\n        programId,\n    );\n\n    if (lamports > 0) {\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\n    }\n\n    transaction.add(\n        createInitializeInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            name,\n            symbol,\n            uri,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateField(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    field: string | Field,\n    value: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateFieldInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            field,\n            value,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Updates a field in a token-metadata account.\n * If the field does not exist on the account, it will be created.\n * If the field does exist, it will be overwritten.\n * Includes a transfer for any additional rent-exempt SOL if required.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param field            Field to update in the metadata\n * @param value            Value to write for the field\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateFieldWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    field: string | Field,\n    value: string,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction();\n\n    const lamports = await getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);\n\n    if (lamports > 0) {\n        transaction.add(SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports: lamports }));\n    }\n\n    transaction.add(\n        createUpdateFieldInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            field,\n            value,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Remove a field in a token-metadata account.\n *\n * The field can be one of the required fields (name, symbol, URI), or a\n * totally new field denoted by a \"key\" string.\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param key              Key to remove in the additional metadata portion\n * @param idempotent       When true, instruction will not error if the key does not exist\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataRemoveKey(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    key: string,\n    idempotent: boolean,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createRemoveKeyInstruction({\n            programId,\n            metadata: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            key,\n            idempotent,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n *  Update authority\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fees\n * @param mint             Mint Account\n * @param updateAuthority  Update Authority\n * @param newAuthority     New authority for the token metadata, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenMetadataUpdateAuthority(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateAuthorityInstruction({\n            programId,\n            metadata: mint,\n            oldAuthority: updateAuthorityPublicKey,\n            newAuthority,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { PublicKey } from '@solana/web3.js';\nimport type { ReadonlyUint8Array } from '@solana/codecs';\nimport { fixCodecSize, getBytesCodec, getStructCodec, getU64Codec } from '@solana/codecs';\n\nconst tokenGroupMemberCodec = getStructCodec([\n    ['mint', fixCodecSize(getBytesCodec(), 32)],\n    ['group', fixCodecSize(getBytesCodec(), 32)],\n    ['memberNumber', getU64Codec()],\n]);\n\nexport const TOKEN_GROUP_MEMBER_SIZE = tokenGroupMemberCodec.fixedSize;\n\nexport interface TokenGroupMember {\n    /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint */\n    mint: PublicKey;\n    /** The pubkey of the `TokenGroup` */\n    group: PublicKey;\n    /** The member number */\n    memberNumber: bigint;\n}\n\n// Pack TokenGroupMember into byte slab\nexport function packTokenGroupMember(member: TokenGroupMember): ReadonlyUint8Array {\n    return tokenGroupMemberCodec.encode({\n        mint: member.mint.toBuffer(),\n        group: member.group.toBuffer(),\n        memberNumber: member.memberNumber,\n    });\n}\n\n// unpack byte slab into TokenGroupMember\nexport function unpackTokenGroupMember(buffer: Buffer | Uint8Array | ReadonlyUint8Array): TokenGroupMember {\n    const data = tokenGroupMemberCodec.decode(buffer);\n    return {\n        mint: new PublicKey(data.mint),\n        group: new PublicKey(data.group),\n        memberNumber: data.memberNumber,\n    };\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport { TokenUnsupportedInstructionError } from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** Deserialized instruction for the initiation of an immutable owner account */\nexport interface InitializeNonTransferableMintInstructionData {\n    instruction: TokenInstruction.InitializeNonTransferableMint;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeNonTransferableMintInstructionData = struct<InitializeNonTransferableMintInstructionData>([\n    u8('instruction'),\n]);\n\n/**\n * Construct an InitializeNonTransferableMint instruction\n *\n * @param mint           Mint Account to make non-transferable\n * @param programId         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeNonTransferableMintInstruction(\n    mint: PublicKey,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeNonTransferableMintInstructionData.span);\n    initializeNonTransferableMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeNonTransferableMint,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { Keypair, sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createInitializeMintInstruction } from '../../instructions/initializeMint.js';\nimport { ExtensionType, getMintLen } from '../extensionType.js';\nimport {\n    createInitializeInterestBearingMintInstruction,\n    createUpdateRateInterestBearingMintInstruction,\n} from './instructions.js';\n\n/**\n * Initialize an interest bearing account on a mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mintAuthority   Account or multisig that will control minting\n * @param freezeAuthority Optional account or multisig that can freeze token accounts\n * @param rateAuthority   The public key for the account that can update the rate\n * @param rate            The initial interest rate\n * @param decimals        Location of the decimal place\n * @param keypair         Optional keypair, defaulting to a new random one\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Public key of the mint\n */\nexport async function createInterestBearingMint(\n    connection: Connection,\n    payer: Signer,\n    mintAuthority: PublicKey,\n    freezeAuthority: PublicKey,\n    rateAuthority: PublicKey,\n    rate: number,\n    decimals: number,\n    keypair = Keypair.generate(),\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<PublicKey> {\n    const mintLen = getMintLen([ExtensionType.InterestBearingConfig]);\n    const lamports = await connection.getMinimumBalanceForRentExemption(mintLen);\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space: mintLen,\n            lamports,\n            programId,\n        }),\n        createInitializeInterestBearingMintInstruction(keypair.publicKey, rateAuthority, rate, programId),\n        createInitializeMintInstruction(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId),\n    );\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n    return keypair.publicKey;\n}\n\n/**\n * Update the interest rate of an interest bearing account\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mint            Public key of the mint\n * @param rateAuthority   The public key for the account that can update the rate\n * @param rate            The initial interest rate\n * @param multiSigners    Signing accounts if `owner` is a multisig\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateRateInterestBearingMint(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    rateAuthority: Signer,\n    rate: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<string> {\n    const [rateAuthorityPublicKey, signers] = getSigners(rateAuthority, multiSigners);\n    const transaction = new Transaction().add(\n        createUpdateRateInterestBearingMintInstruction(mint, rateAuthorityPublicKey, rate, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, rateAuthority, ...signers], confirmOptions);\n}\n","import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","/**\n * An implementation of the Rust Option type in JavaScript.\n * It can be one of the following:\n * - <code>{@link Some}<T></code>: Meaning there is a value of type T.\n * - <code>{@link None}</code>: Meaning there is no value.\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * Defines a looser type that can be used when serializing an {@link Option}.\n * This allows us to pass null or the Option value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an option of type `T` that has a value.\n *\n * @see {@link Option}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an option of type `T` that has no value.\n *\n * @see {@link Option}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} of type `T` that has a value.\n *\n * @see {@link Option}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} of type `T` that has no value.\n *\n * @see {@link Option}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Whether the given data is an {@link Option}.\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Whether the given {@link Option} is a {@link Some}.\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Whether the given {@link Option} is a {@link None}.\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n","import { struct } from '@solana/buffer-layout';\nimport type { Account } from '../state/account.js';\nimport { ExtensionType, getExtensionData } from './extensionType.js';\n\n/** ImmutableOwner as stored by the program */\nexport interface ImmutableOwner {} // eslint-disable-line\n\n/** Buffer layout for de/serializing an account */\nexport const ImmutableOwnerLayout = struct<ImmutableOwner>([]);\n\nexport const IMMUTABLE_OWNER_SIZE = ImmutableOwnerLayout.span;\n\nexport function getImmutableOwner(account: Account): ImmutableOwner | null {\n    const extensionData = getExtensionData(ExtensionType.ImmutableOwner, account.tlvData);\n    if (extensionData !== null) {\n        return ImmutableOwnerLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { SYSVAR_RENT_PUBKEY, TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface InitializeAccountInstructionData {\n    instruction: TokenInstruction.InitializeAccount;\n}\n\n/** TODO: docs */\nexport const initializeAccountInstructionData = struct<InitializeAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct an InitializeAccount instruction\n *\n * @param account   New token account\n * @param mint      Mint account\n * @param owner     Owner of the new account\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeAccountInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    owner: PublicKey,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [\n        { pubkey: account, isSigner: false, isWritable: true },\n        { pubkey: mint, isSigner: false, isWritable: false },\n        { pubkey: owner, isSigner: false, isWritable: false },\n        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },\n    ];\n\n    const data = Buffer.alloc(initializeAccountInstructionData.span);\n    initializeAccountInstructionData.encode({ instruction: TokenInstruction.InitializeAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeAccount instruction */\nexport interface DecodedInitializeAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        owner: AccountMeta;\n        rent: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeAccount;\n    };\n}\n\n/**\n * Decode an InitializeAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedInitializeAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, owner, rent },\n        data,\n    } = decodeInitializeAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !owner || !rent) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            rent,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeAccount instruction */\nexport interface DecodedInitializeAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        rent: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode an InitializeAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeAccountInstructionUnchecked({\n    programId,\n    keys: [account, mint, owner, rent],\n    data,\n}: TransactionInstruction): DecodedInitializeAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            owner,\n            rent,\n        },\n        data: initializeAccountInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface CloseAccountInstructionData {\n    instruction: TokenInstruction.CloseAccount;\n}\n\n/** TODO: docs */\nexport const closeAccountInstructionData = struct<CloseAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct a CloseAccount instruction\n *\n * @param account      Account to close\n * @param destination  Account to receive the remaining balance of the closed account\n * @param authority    Account close authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createCloseAccountInstruction(\n    account: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: destination, isSigner: false, isWritable: true },\n        ],\n        authority,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(closeAccountInstructionData.span);\n    closeAccountInstructionData.encode({ instruction: TokenInstruction.CloseAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid CloseAccount instruction */\nexport interface DecodedCloseAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.CloseAccount;\n    };\n}\n\n/**\n * Decode a CloseAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeCloseAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedCloseAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== closeAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, destination, authority, multiSigners },\n        data,\n    } = decodeCloseAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.CloseAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !destination || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated CloseAccount instruction */\nexport interface DecodedCloseAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        destination: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a CloseAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeCloseAccountInstructionUnchecked({\n    programId,\n    keys: [account, destination, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedCloseAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            destination,\n            authority,\n            multiSigners,\n        },\n        data: closeAccountInstructionData.decode(data),\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n\n/** TODO: docs */\nexport interface InitializeMintCloseAuthorityInstructionData {\n    instruction: TokenInstruction.InitializeMintCloseAuthority;\n    closeAuthority: PublicKey | null;\n}\n\n/** TODO: docs */\nexport const initializeMintCloseAuthorityInstructionData = struct<InitializeMintCloseAuthorityInstructionData>([\n    u8('instruction'),\n    new COptionPublicKeyLayout('closeAuthority'),\n]);\n\n/**\n * Construct an InitializeMintCloseAuthority instruction\n *\n * @param mint            Token mint account\n * @param closeAuthority  Optional authority that can close the mint\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeMintCloseAuthorityInstruction(\n    mint: PublicKey,\n    closeAuthority: PublicKey | null,\n    programId: PublicKey,\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(34); // worst-case size\n    initializeMintCloseAuthorityInstructionData.encode(\n        {\n            instruction: TokenInstruction.InitializeMintCloseAuthority,\n            closeAuthority,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, initializeMintCloseAuthorityInstructionData.getSpan(data)),\n    });\n}\n\n/** A decoded, valid InitializeMintCloseAuthority instruction */\nexport interface DecodedInitializeMintCloseAuthorityInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.InitializeMintCloseAuthority;\n        closeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMintCloseAuthority instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeMintCloseAuthorityInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey,\n): DecodedInitializeMintCloseAuthorityInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeMintCloseAuthorityInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeMintCloseAuthorityInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.InitializeMintCloseAuthority)\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeMintCloseAuthority instruction */\nexport interface DecodedInitializeMintCloseAuthorityInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        closeAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode an InitializeMintCloseAuthority instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeMintCloseAuthorityInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeMintCloseAuthorityInstructionUnchecked {\n    const { instruction, closeAuthority } = initializeMintCloseAuthorityInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            closeAuthority,\n        },\n    };\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface ThawAccountInstructionData {\n    instruction: TokenInstruction.ThawAccount;\n}\n\n/** TODO: docs */\nexport const thawAccountInstructionData = struct<ThawAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct a ThawAccount instruction\n *\n * @param account      Account to thaw\n * @param mint         Mint account\n * @param authority    Mint freeze authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createThawAccountInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n        ],\n        authority,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(thawAccountInstructionData.span);\n    thawAccountInstructionData.encode({ instruction: TokenInstruction.ThawAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid ThawAccount instruction */\nexport interface DecodedThawAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.ThawAccount;\n    };\n}\n\n/**\n * Decode a ThawAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeThawAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedThawAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== thawAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, authority, multiSigners },\n        data,\n    } = decodeThawAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.ThawAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated ThawAccount instruction */\nexport interface DecodedThawAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a ThawAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeThawAccountInstructionUnchecked({\n    programId,\n    keys: [account, mint, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedThawAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data: thawAccountInstructionData.decode(data),\n    };\n}\n","import { blob, greedy, seq, struct, u32, u8 } from '@solana/buffer-layout';\nimport type { Mint } from '../../state/mint.js';\nimport { ExtensionType, getExtensionData } from '../extensionType.js';\nimport type { AccountInfo, AccountMeta, Connection } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { Account } from '../../state/account.js';\nimport { TokenTransferHookAccountNotFound } from '../../errors.js';\nimport { unpackSeeds } from './seeds.js';\nimport { unpackPubkeyData } from './pubkeyData.js';\n\n/** TransferHook as stored by the program */\nexport interface TransferHook {\n    /** The transfer hook update authority */\n    authority: PublicKey;\n    /** The transfer hook program account */\n    programId: PublicKey;\n}\n\n/** Buffer layout for de/serializing a transfer hook extension */\nexport const TransferHookLayout = struct<TransferHook>([publicKey('authority'), publicKey('programId')]);\n\nexport const TRANSFER_HOOK_SIZE = TransferHookLayout.span;\n\nexport function getTransferHook(mint: Mint): TransferHook | null {\n    const extensionData = getExtensionData(ExtensionType.TransferHook, mint.tlvData);\n    if (extensionData !== null) {\n        return TransferHookLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n\n/** TransferHookAccount as stored by the program */\nexport interface TransferHookAccount {\n    /**\n     * Whether or not this account is currently transferring tokens\n     * True during the transfer hook cpi, otherwise false\n     */\n    transferring: boolean;\n}\n\n/** Buffer layout for de/serializing a transfer hook account extension */\nexport const TransferHookAccountLayout = struct<TransferHookAccount>([bool('transferring')]);\n\nexport const TRANSFER_HOOK_ACCOUNT_SIZE = TransferHookAccountLayout.span;\n\nexport function getTransferHookAccount(account: Account): TransferHookAccount | null {\n    const extensionData = getExtensionData(ExtensionType.TransferHookAccount, account.tlvData);\n    if (extensionData !== null) {\n        return TransferHookAccountLayout.decode(extensionData);\n    } else {\n        return null;\n    }\n}\n\nexport function getExtraAccountMetaAddress(mint: PublicKey, programId: PublicKey): PublicKey {\n    const seeds = [Buffer.from('extra-account-metas'), mint.toBuffer()];\n    return PublicKey.findProgramAddressSync(seeds, programId)[0];\n}\n\n/** ExtraAccountMeta as stored by the transfer hook program */\nexport interface ExtraAccountMeta {\n    discriminator: number;\n    addressConfig: Uint8Array;\n    isSigner: boolean;\n    isWritable: boolean;\n}\n\n/** Buffer layout for de/serializing an ExtraAccountMeta */\nexport const ExtraAccountMetaLayout = struct<ExtraAccountMeta>([\n    u8('discriminator'),\n    blob(32, 'addressConfig'),\n    bool('isSigner'),\n    bool('isWritable'),\n]);\n\nexport interface ExtraAccountMetaList {\n    count: number;\n    extraAccounts: ExtraAccountMeta[];\n}\n\n/** Buffer layout for de/serializing a list of ExtraAccountMeta prefixed by a u32 length */\nexport const ExtraAccountMetaListLayout = struct<ExtraAccountMetaList>([\n    u32('count'),\n    seq<ExtraAccountMeta>(ExtraAccountMetaLayout, greedy(ExtraAccountMetaLayout.span), 'extraAccounts'),\n]);\n\n/** Buffer layout for de/serializing a list of ExtraAccountMetaAccountData prefixed by a u32 length */\nexport interface ExtraAccountMetaAccountData {\n    instructionDiscriminator: bigint;\n    length: number;\n    extraAccountsList: ExtraAccountMetaList;\n}\n\n/** Buffer layout for de/serializing an ExtraAccountMetaAccountData */\nexport const ExtraAccountMetaAccountDataLayout = struct<ExtraAccountMetaAccountData>([\n    u64('instructionDiscriminator'),\n    u32('length'),\n    ExtraAccountMetaListLayout.replicate('extraAccountsList'),\n]);\n\n/** Unpack an extra account metas account and parse the data into a list of ExtraAccountMetas */\nexport function getExtraAccountMetas(account: AccountInfo<Buffer>): ExtraAccountMeta[] {\n    const extraAccountsList = ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;\n    return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);\n}\n\n/** Take an ExtraAccountMeta and construct that into an actual AccountMeta */\nexport async function resolveExtraAccountMeta(\n    connection: Connection,\n    extraMeta: ExtraAccountMeta,\n    previousMetas: AccountMeta[],\n    instructionData: Buffer,\n    transferHookProgramId: PublicKey,\n): Promise<AccountMeta> {\n    if (extraMeta.discriminator === 0) {\n        return {\n            pubkey: new PublicKey(extraMeta.addressConfig),\n            isSigner: extraMeta.isSigner,\n            isWritable: extraMeta.isWritable,\n        };\n    } else if (extraMeta.discriminator === 2) {\n        const pubkey = await unpackPubkeyData(extraMeta.addressConfig, previousMetas, instructionData, connection);\n        return {\n            pubkey,\n            isSigner: extraMeta.isSigner,\n            isWritable: extraMeta.isWritable,\n        };\n    }\n\n    let programId = PublicKey.default;\n\n    if (extraMeta.discriminator === 1) {\n        programId = transferHookProgramId;\n    } else {\n        const accountIndex = extraMeta.discriminator - (1 << 7);\n        if (previousMetas.length <= accountIndex) {\n            throw new TokenTransferHookAccountNotFound();\n        }\n        programId = previousMetas[accountIndex].pubkey;\n    }\n\n    const seeds = await unpackSeeds(extraMeta.addressConfig, previousMetas, instructionData, connection);\n    const pubkey = PublicKey.findProgramAddressSync(seeds, programId)[0];\n\n    return { pubkey, isSigner: extraMeta.isSigner, isWritable: extraMeta.isWritable };\n}\n","import type { AccountMeta, Connection } from '@solana/web3.js';\nimport { TokenTransferHookAccountDataNotFound, TokenTransferHookInvalidSeed } from '../../errors.js';\n\ninterface Seed {\n    data: Buffer;\n    packedLength: number;\n}\n\nconst DISCRIMINATOR_SPAN = 1;\nconst LITERAL_LENGTH_SPAN = 1;\nconst INSTRUCTION_ARG_OFFSET_SPAN = 1;\nconst INSTRUCTION_ARG_LENGTH_SPAN = 1;\nconst ACCOUNT_KEY_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;\nconst ACCOUNT_DATA_OFFSET_SPAN = 1;\nconst ACCOUNT_DATA_LENGTH_SPAN = 1;\n\nfunction unpackSeedLiteral(seeds: Uint8Array): Seed {\n    if (seeds.length < 1) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [length, ...rest] = seeds;\n    if (rest.length < length) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: Buffer.from(rest.slice(0, length)),\n        packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length,\n    };\n}\n\nfunction unpackSeedInstructionArg(seeds: Uint8Array, instructionData: Buffer): Seed {\n    if (seeds.length < 2) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [index, length] = seeds;\n    if (instructionData.length < length + index) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: instructionData.subarray(index, index + length),\n        packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN,\n    };\n}\n\nfunction unpackSeedAccountKey(seeds: Uint8Array, previousMetas: AccountMeta[]): Seed {\n    if (seeds.length < 1) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [index] = seeds;\n    if (previousMetas.length <= index) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: previousMetas[index].pubkey.toBuffer(),\n        packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN,\n    };\n}\n\nasync function unpackSeedAccountData(\n    seeds: Uint8Array,\n    previousMetas: AccountMeta[],\n    connection: Connection,\n): Promise<Seed> {\n    if (seeds.length < 3) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const [accountIndex, dataIndex, length] = seeds;\n    if (previousMetas.length <= accountIndex) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    const accountInfo = await connection.getAccountInfo(previousMetas[accountIndex].pubkey);\n    if (accountInfo == null) {\n        throw new TokenTransferHookAccountDataNotFound();\n    }\n    if (accountInfo.data.length < dataIndex + length) {\n        throw new TokenTransferHookInvalidSeed();\n    }\n    return {\n        data: accountInfo.data.subarray(dataIndex, dataIndex + length),\n        packedLength:\n            DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN,\n    };\n}\n\nasync function unpackFirstSeed(\n    seeds: Uint8Array,\n    previousMetas: AccountMeta[],\n    instructionData: Buffer,\n    connection: Connection,\n): Promise<Seed | null> {\n    const [discriminator, ...rest] = seeds;\n    const remaining = new Uint8Array(rest);\n    switch (discriminator) {\n        case 0:\n            return null;\n        case 1:\n            return unpackSeedLiteral(remaining);\n        case 2:\n            return unpackSeedInstructionArg(remaining, instructionData);\n        case 3:\n            return unpackSeedAccountKey(remaining, previousMetas);\n        case 4:\n            return unpackSeedAccountData(remaining, previousMetas, connection);\n        default:\n            throw new TokenTransferHookInvalidSeed();\n    }\n}\n\nexport async function unpackSeeds(\n    seeds: Uint8Array,\n    previousMetas: AccountMeta[],\n    instructionData: Buffer,\n    connection: Connection,\n): Promise<Buffer[]> {\n    const unpackedSeeds: Buffer[] = [];\n    let i = 0;\n    while (i < 32) {\n        const seed = await unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);\n        if (seed == null) {\n            break;\n        }\n        unpackedSeeds.push(seed.data);\n        i += seed.packedLength;\n    }\n    return unpackedSeeds;\n}\n","/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors/#adding-a-new-error\n *\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors — e.g. under the same package — can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names — e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1 as const;\nexport const SOLANA_ERROR__INVALID_NONCE = 2 as const;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3 as const;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4 as const;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5 as const;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6 as const;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7 as const;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8 as const;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9 as const;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700 as const;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603 as const;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602 as const;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601 as const;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013 as const;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002 as const;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001 as const;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000 as const;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001 as const;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002 as const;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003 as const;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004 as const;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005 as const;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006 as const;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007 as const;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008 as const;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009 as const;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010 as const;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000 as const;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001 as const;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002 as const;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003 as const;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004 as const;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006 as const;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007 as const;\n\n// Crypto-related errors.\n// Reserve error codes in the range [3611000-3611050].\nexport const SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000 as const;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000 as const;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001 as const;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002 as const;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003 as const;\nexport const SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004 as const;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000 as const;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001 as const;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002 as const;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053 as const;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054 as const;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007 as const;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008 as const;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009 as const;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010 as const;\nexport const SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011 as const;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000 as const;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001 as const;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002 as const;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003 as const;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004 as const;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005 as const;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006 as const;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007 as const;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008 as const;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009 as const;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010 as const;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011 as const;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012 as const;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013 as const;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE =\n    5663014 as const;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015 as const;\nexport const SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016 as const;\nexport const SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017 as const;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018 as const;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008 as const;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035 as const;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036 as const;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001 as const;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002 as const;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003 as const;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004 as const;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005 as const;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007 as const;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010 as const;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012 as const;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013 as const;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015 as const;\nexport const SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016 as const;\nexport const SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017 as const;\nexport const SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018 as const;\nexport const SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019 as const;\nexport const SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020 as const;\nexport const SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021 as const;\nexport const SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022 as const;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000 as const;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001 as const;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002 as const;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST = 8190000 as const;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001 as const;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002 as const;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED = 8190003 as const;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT = 8190004 as const;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING = 9900000 as const;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE =\n    9900001 as const;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002 as const;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003 as const;\n\n/**\n * A union of every Solana error code\n *\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS\n    | typeof SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_CONSTANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES\n    | typeof SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n\n/**\n * Errors of this type are understood to have an optional `SolanaError` nested inside as `cause`.\n */\nexport type SolanaErrorCodeWithCause = typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;\n","import type { ConfirmOptions, Connection, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { NATIVE_MINT_2022, TOKEN_2022_PROGRAM_ID } from '../constants.js';\nimport { createCreateNativeMintInstruction } from '../instructions/createNativeMint.js';\n\n/**\n * Create native mint\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param nativeMint               Native mint id associated with program\n */\nexport async function createNativeMint(\n    connection: Connection,\n    payer: Signer,\n    confirmOptions?: ConfirmOptions,\n    nativeMint = NATIVE_MINT_2022,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<void> {\n    const transaction = new Transaction().add(\n        createCreateNativeMintInstruction(payer.publicKey, nativeMint, programId),\n    );\n    await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Decodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * A string codec that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create codecs such as base10 or base58.\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface SyncNativeInstructionData {\n    instruction: TokenInstruction.SyncNative;\n}\n\n/** TODO: docs */\nexport const syncNativeInstructionData = struct<SyncNativeInstructionData>([u8('instruction')]);\n\n/**\n * Construct a SyncNative instruction\n *\n * @param account   Native account to sync lamports from\n * @param programId SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSyncNativeInstruction(account: PublicKey, programId = TOKEN_PROGRAM_ID): TransactionInstruction {\n    const keys = [{ pubkey: account, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(syncNativeInstructionData.span);\n    syncNativeInstructionData.encode({ instruction: TokenInstruction.SyncNative }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid SyncNative instruction */\nexport interface DecodedSyncNativeInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.SyncNative;\n    };\n}\n\n/**\n * Decode a SyncNative instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSyncNativeInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedSyncNativeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== syncNativeInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account },\n        data,\n    } = decodeSyncNativeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.SyncNative) throw new TokenInvalidInstructionTypeError();\n    if (!account) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated SyncNative instruction */\nexport interface DecodedSyncNativeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a SyncNative instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSyncNativeInstructionUnchecked({\n    programId,\n    keys: [account],\n    data,\n}: TransactionInstruction): DecodedSyncNativeInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n        },\n        data: syncNativeInstructionData.decode(data),\n    };\n}\n","import { blob, struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface UiAmountToAmountInstructionData {\n    instruction: TokenInstruction.UiAmountToAmount;\n    amount: Uint8Array;\n}\n\n/** TODO: docs */\n\n/**\n * Construct a UiAmountToAmount instruction\n *\n * @param mint         Public key of the mint\n * @param amount       UiAmount of tokens to be converted to Amount\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUiAmountToAmountInstruction(\n    mint: PublicKey,\n    amount: string,\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];\n    const buf = Buffer.from(amount, 'utf8');\n    const uiAmountToAmountInstructionData = struct<UiAmountToAmountInstructionData>([\n        u8('instruction'),\n        blob(buf.length, 'amount'),\n    ]);\n\n    const data = Buffer.alloc(uiAmountToAmountInstructionData.span);\n    uiAmountToAmountInstructionData.encode(\n        {\n            instruction: TokenInstruction.UiAmountToAmount,\n            amount: buf,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid UiAmountToAmount instruction */\nexport interface DecodedUiAmountToAmountInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.UiAmountToAmount;\n        amount: Uint8Array;\n    };\n}\n\n/**\n * Decode a UiAmountToAmount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeUiAmountToAmountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedUiAmountToAmountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    const uiAmountToAmountInstructionData = struct<UiAmountToAmountInstructionData>([\n        u8('instruction'),\n        blob(instruction.data.length - 1, 'amount'),\n    ]);\n    if (instruction.data.length !== uiAmountToAmountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeUiAmountToAmountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.UiAmountToAmount) throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated UiAmountToAmount instruction */\nexport interface DecodedUiAmountToAmountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: number;\n        amount: Uint8Array;\n    };\n}\n\n/**\n * Decode a UiAmountToAmount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeUiAmountToAmountInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedUiAmountToAmountInstructionUnchecked {\n    const uiAmountToAmountInstructionData = struct<UiAmountToAmountInstructionData>([\n        u8('instruction'),\n        blob(data.length - 1, 'amount'),\n    ]);\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: uiAmountToAmountInstructionData.decode(data),\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createSyncNativeInstruction } from '../instructions/syncNative.js';\n\n/**\n * Sync the balance of a native SPL token account to the underlying system account's lamports\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Native account to sync\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function syncNative(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(createSyncNativeInstruction(account, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, Signer, PublicKey } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\nimport { COptionPublicKeyLayout } from '../serialization.js';\n\n/** Authority types defined by the program */\nexport enum AuthorityType {\n    MintTokens = 0,\n    FreezeAccount = 1,\n    AccountOwner = 2,\n    CloseAccount = 3,\n    TransferFeeConfig = 4,\n    WithheldWithdraw = 5,\n    CloseMint = 6,\n    InterestRate = 7,\n    PermanentDelegate = 8,\n    ConfidentialTransferMint = 9,\n    TransferHookProgramId = 10,\n    ConfidentialTransferFeeConfig = 11,\n    MetadataPointer = 12,\n    GroupPointer = 13,\n    GroupMemberPointer = 14,\n    ScaledUiAmountConfig = 15,\n    PausableConfig = 16,\n}\n\n/** TODO: docs */\nexport interface SetAuthorityInstructionData {\n    instruction: TokenInstruction.SetAuthority;\n    authorityType: AuthorityType;\n    newAuthority: PublicKey | null;\n}\n\n/** TODO: docs */\nexport const setAuthorityInstructionData = struct<SetAuthorityInstructionData>([\n    u8('instruction'),\n    u8('authorityType'),\n    new COptionPublicKeyLayout('newAuthority'),\n]);\n\n/**\n * Construct a SetAuthority instruction\n *\n * @param account          Address of the token account\n * @param currentAuthority Current authority of the specified type\n * @param authorityType    Type of authority to set\n * @param newAuthority     New authority of the account\n * @param multiSigners     Signing accounts if `currentAuthority` is a multisig\n * @param programId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createSetAuthorityInstruction(\n    account: PublicKey,\n    currentAuthority: PublicKey,\n    authorityType: AuthorityType,\n    newAuthority: PublicKey | null,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);\n\n    const data = Buffer.alloc(35); // worst-case\n    setAuthorityInstructionData.encode(\n        {\n            instruction: TokenInstruction.SetAuthority,\n            authorityType,\n            newAuthority,\n        },\n        data,\n    );\n\n    return new TransactionInstruction({\n        keys,\n        programId,\n        data: data.subarray(0, setAuthorityInstructionData.getSpan(data)),\n    });\n}\n\n/** A decoded, valid SetAuthority instruction */\nexport interface DecodedSetAuthorityInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        currentAuthority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.SetAuthority;\n        authorityType: AuthorityType;\n        newAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode a SetAuthority instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeSetAuthorityInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedSetAuthorityInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== setAuthorityInstructionData.getSpan(instruction.data))\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, currentAuthority, multiSigners },\n        data,\n    } = decodeSetAuthorityInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.SetAuthority) throw new TokenInvalidInstructionTypeError();\n    if (!account || !currentAuthority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            currentAuthority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated SetAuthority instruction */\nexport interface DecodedSetAuthorityInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        currentAuthority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n        authorityType: AuthorityType;\n        newAuthority: PublicKey | null;\n    };\n}\n\n/**\n * Decode a SetAuthority instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeSetAuthorityInstructionUnchecked({\n    programId,\n    keys: [account, currentAuthority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedSetAuthorityInstructionUnchecked {\n    const { instruction, authorityType, newAuthority } = setAuthorityInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            account,\n            currentAuthority,\n            multiSigners,\n        },\n        data: {\n            instruction,\n            authorityType,\n            newAuthority,\n        },\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport type { AccountState } from '../../state/account.js';\nimport {\n    createInitializeDefaultAccountStateInstruction,\n    createUpdateDefaultAccountStateInstruction,\n} from './instructions.js';\n\n/**\n * Initialize a default account state on a mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint        Mint to initialize with extension\n * @param state        Account state with which to initialize new accounts\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function initializeDefaultAccountState(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    state: AccountState,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(createInitializeDefaultAccountStateInstruction(mint, state, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n\n/**\n * Update the default account state on a mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint        Mint to modify\n * @param state        New account state to set on created accounts\n * @param freezeAuthority          Freeze authority of the mint\n * @param multiSigners   Signing accounts if `freezeAuthority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateDefaultAccountState(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    state: AccountState,\n    freezeAuthority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [freezeAuthorityPublicKey, signers] = getSigners(freezeAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateDefaultAccountStateInstruction(mint, state, freezeAuthorityPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type — i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","import { isSome, none, Option, some } from './option';\n\n/**\n * Unwraps the value of an {@link Option} of type `T`\n * or returns a fallback value that defaults to `null`.\n */\nexport function unwrapOption<T>(option: Option<T>): T | null;\nexport function unwrapOption<T, U>(option: Option<T>, fallback: () => U): T | U;\nexport function unwrapOption<T, U = null>(option: Option<T>, fallback?: () => U): T | U {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : (null as U);\n}\n\n/**\n * Wraps a nullable value into an {@link Option}.\n */\nexport const wrapNullable = <T>(nullable: T | null): Option<T> => (nullable !== null ? some(nullable) : none<T>());\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createPauseInstruction, createResumeInstruction } from './instructions.js';\n\n/**\n * Pause a pausable mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mint            Public key of the mint\n * @param owner           The pausable config authority\n * @param multiSigners    Signing accounts if `owner` is a multisig\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Public key of the mint\n */\nexport async function pause(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(createPauseInstruction(mint, ownerPublicKey, multiSigners, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Resume a pausable mint\n *\n * @param connection      Connection to use\n * @param payer           Payer of the transaction fees\n * @param mint            Public key of the mint\n * @param owner           The pausable config authority\n * @param multiSigners    Signing accounts if `owner` is a multisig\n * @param confirmOptions  Options for confirming the transaction\n * @param programId       SPL Token program account\n *\n * @return Public key of the mint\n */\nexport async function resume(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(createResumeInstruction(mint, ownerPublicKey, multiSigners, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createRevokeInstruction } from '../instructions/revoke.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Revoke approval for the transfer of tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the token account\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function revoke(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createRevokeInstruction(account, ownerPublicKey, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createDisableCpiGuardInstruction, createEnableCpiGuardInstruction } from './instructions.js';\n\n/**\n * Enable CPI Guard on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function enableCpiGuard(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createEnableCpiGuardInstruction(account, ownerPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Disable CPI Guard on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function disableCpiGuard(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createDisableCpiGuardInstruction(account, ownerPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    createDisableRequiredMemoTransfersInstruction,\n    createEnableRequiredMemoTransfersInstruction,\n} from './instructions.js';\n\n/**\n * Enable memo transfers on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function enableRequiredMemoTransfers(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createEnableRequiredMemoTransfersInstruction(account, ownerPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Disable memo transfers on the given account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to modify\n * @param owner          Owner of the account\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function disableRequiredMemoTransfers(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    owner: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createDisableRequiredMemoTransfersInstruction(account, ownerPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface RevokeInstructionData {\n    instruction: TokenInstruction.Revoke;\n}\n\n/** TODO: docs */\nexport const revokeInstructionData = struct<RevokeInstructionData>([u8('instruction')]);\n\n/**\n * Construct a Revoke instruction\n *\n * @param account      Address of the token account\n * @param owner        Owner of the account\n * @param multiSigners Signing accounts if `owner` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createRevokeInstruction(\n    account: PublicKey,\n    owner: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners([{ pubkey: account, isSigner: false, isWritable: true }], owner, multiSigners);\n\n    const data = Buffer.alloc(revokeInstructionData.span);\n    revokeInstructionData.encode({ instruction: TokenInstruction.Revoke }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid Revoke instruction */\nexport interface DecodedRevokeInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        owner: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.Revoke;\n    };\n}\n\n/**\n * Decode a Revoke instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeRevokeInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedRevokeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== revokeInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, owner, multiSigners },\n        data,\n    } = decodeRevokeInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.Revoke) throw new TokenInvalidInstructionTypeError();\n    if (!account || !owner) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            owner,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated Revoke instruction */\nexport interface DecodedRevokeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        owner: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a Revoke instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeRevokeInstructionUnchecked({\n    programId,\n    keys: [account, owner, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedRevokeInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            owner,\n            multiSigners,\n        },\n        data: revokeInstructionData.decode(data),\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createRecoverNestedInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAssociatedTokenAddressSync } from '../state/mint.js';\n\n/**\n * Recover funds funds in an associated token account which is owned by an associated token account\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param owner                    Owner of original ATA\n * @param mint                     Mint for the original ATA\n * @param nestedMint               Mint for the nested ATA\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function recoverNested(\n    connection: Connection,\n    payer: Signer,\n    owner: Signer,\n    mint: PublicKey,\n    nestedMint: PublicKey,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const ownerAssociatedToken = getAssociatedTokenAddressSync(\n        mint,\n        owner.publicKey,\n        false,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    const destinationAssociatedToken = getAssociatedTokenAddressSync(\n        nestedMint,\n        owner.publicKey,\n        false,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    const nestedAssociatedToken = getAssociatedTokenAddressSync(\n        nestedMint,\n        ownerAssociatedToken,\n        true,\n        programId,\n        associatedTokenProgramId,\n    );\n\n    const transaction = new Transaction().add(\n        createRecoverNestedInstruction(\n            nestedAssociatedToken,\n            nestedMint,\n            destinationAssociatedToken,\n            ownerAssociatedToken,\n            mint,\n            owner.publicKey,\n            programId,\n            associatedTokenProgramId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, owner], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createThawAccountInstruction } from '../instructions/thawAccount.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Thaw (unfreeze) a token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to thaw\n * @param mint           Mint for the account\n * @param authority      Mint freeze authority\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function thawAccount(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createThawAccountInstruction(account, mint, authorityPublicKey, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\n/** Defines a encoder for numbers and bigints. */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/** Defines a fixed-size encoder for numbers and bigints. */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/** Defines a decoder for numbers and bigints. */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/** Defines a fixed-size decoder for numbers and bigints. */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/** Defines a codec for numbers and bigints. */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/** Defines a fixed-size codec for numbers and bigints. */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/** Defines the config for number codecs that use more than one byte. */\nexport type NumberCodecConfig = {\n    /**\n     * Whether the serializer should use little-endian or big-endian encoding.\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/** Defines the endianness of a number serializer. */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createBurnCheckedInstruction } from '../instructions/burnChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Burn tokens from an account, asserting the token mint and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Account to burn tokens from\n * @param mint           Mint for the account\n * @param owner          Account owner\n * @param amount         Amount to burn\n * @param decimals       Number of decimals in amount to burn\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function burnChecked(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createBurnCheckedInstruction(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, Keypair, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { getAccountLenForMint } from '../extensions/extensionType.js';\nimport { createInitializeAccountInstruction } from '../instructions/initializeAccount.js';\nimport { getMint } from '../state/mint.js';\nimport { createAssociatedTokenAccount } from './createAssociatedTokenAccount.js';\n\n/**\n * Create and initialize a new token account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction and initialization fees\n * @param mint           Mint for the account\n * @param owner          Owner of the new account\n * @param keypair        Optional keypair, defaulting to the associated token account for the `mint` and `owner`\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Address of the new token account\n */\nexport async function createAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    keypair?: Keypair,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<PublicKey> {\n    // If a keypair isn't provided, create the associated token account and return its address\n    if (!keypair) return await createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId);\n\n    // Otherwise, create the account with the provided keypair and return its public key\n    const mintState = await getMint(connection, mint, confirmOptions?.commitment, programId);\n    const space = getAccountLenForMint(mintState);\n    const lamports = await connection.getMinimumBalanceForRentExemption(space);\n\n    const transaction = new Transaction().add(\n        SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: keypair.publicKey,\n            space,\n            lamports,\n            programId,\n        }),\n        createInitializeAccountInstruction(keypair.publicKey, mint, owner, programId),\n    );\n\n    await sendAndConfirmTransaction(connection, transaction, [payer, keypair], confirmOptions);\n\n    return keypair.publicKey;\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createApproveInstruction } from '../instructions/approve.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Approve a delegate to transfer up to a maximum number of tokens from an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param account        Address of the token account\n * @param delegate       Account authorized to transfer tokens from the account\n * @param owner          Owner of the account\n * @param amount         Maximum number of tokens the delegate may transfer\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approve(\n    connection: Connection,\n    payer: Signer,\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createApproveInstruction(account, delegate, ownerPublicKey, amount, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n} from '../errors.js';\nimport { addSigners } from './internal.js';\nimport { TokenInstruction } from './types.js';\n\n/** TODO: docs */\nexport interface FreezeAccountInstructionData {\n    instruction: TokenInstruction.FreezeAccount;\n}\n\n/** TODO: docs */\nexport const freezeAccountInstructionData = struct<FreezeAccountInstructionData>([u8('instruction')]);\n\n/**\n * Construct a FreezeAccount instruction\n *\n * @param account      Account to freeze\n * @param mint         Mint account\n * @param authority    Mint freeze authority\n * @param multiSigners Signing accounts if `authority` is a multisig\n * @param programId    SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createFreezeAccountInstruction(\n    account: PublicKey,\n    mint: PublicKey,\n    authority: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_PROGRAM_ID,\n): TransactionInstruction {\n    const keys = addSigners(\n        [\n            { pubkey: account, isSigner: false, isWritable: true },\n            { pubkey: mint, isSigner: false, isWritable: false },\n        ],\n        authority,\n        multiSigners,\n    );\n\n    const data = Buffer.alloc(freezeAccountInstructionData.span);\n    freezeAccountInstructionData.encode({ instruction: TokenInstruction.FreezeAccount }, data);\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid FreezeAccount instruction */\nexport interface DecodedFreezeAccountInstruction {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta;\n        mint: AccountMeta;\n        authority: AccountMeta;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: TokenInstruction.FreezeAccount;\n    };\n}\n\n/**\n * Decode a FreezeAccount instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeFreezeAccountInstruction(\n    instruction: TransactionInstruction,\n    programId = TOKEN_PROGRAM_ID,\n): DecodedFreezeAccountInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== freezeAccountInstructionData.span) throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { account, mint, authority, multiSigners },\n        data,\n    } = decodeFreezeAccountInstructionUnchecked(instruction);\n    if (data.instruction !== TokenInstruction.FreezeAccount) throw new TokenInvalidInstructionTypeError();\n    if (!account || !mint || !authority) throw new TokenInvalidInstructionKeysError();\n\n    // TODO: key checks?\n\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated FreezeAccount instruction */\nexport interface DecodedFreezeAccountInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        account: AccountMeta | undefined;\n        mint: AccountMeta | undefined;\n        authority: AccountMeta | undefined;\n        multiSigners: AccountMeta[];\n    };\n    data: {\n        instruction: number;\n    };\n}\n\n/**\n * Decode a FreezeAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeFreezeAccountInstructionUnchecked({\n    programId,\n    keys: [account, mint, authority, ...multiSigners],\n    data,\n}: TransactionInstruction): DecodedFreezeAccountInstructionUnchecked {\n    return {\n        programId,\n        keys: {\n            account,\n            mint,\n            authority,\n            multiSigners,\n        },\n        data: freezeAccountInstructionData.decode(data),\n    };\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { createUpdateMultiplierDataInstruction } from './instructions.js';\n\n/**\n * Update scaled UI amount multiplier\n *\n * @param connection            Connection to use\n * @param payer                 Payer of the transaction fees\n * @param mint                  The token mint\n * @param owner                 Owner of the scaled UI amount mint\n * @param multiplier            New multiplier\n * @param effectiveTimestamp    Effective time stamp for the new multiplier\n * @param multiSigners          Signing accounts if `owner` is a multisig\n * @param confirmOptions        Options for confirming the transaction\n * @param programId             SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function updateMultiplier(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: Signer | PublicKey,\n    multiplier: number,\n    effectiveTimestamp: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateMultiplierDataInstruction(\n            mint,\n            ownerPublicKey,\n            multiplier,\n            effectiveTimestamp,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getConstantDecoder,\n    getConstantEncoder,\n    getTupleDecoder,\n    getTupleEncoder,\n    getUnionDecoder,\n    getUnionEncoder,\n    getUnitDecoder,\n    getUnitEncoder,\n} from '@solana/codecs-data-structures';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, None, none, Option, OptionOrNullable, Some, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/** Defines the config for Option codecs. */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Defines how the `None` value should be represented.\n     *\n     * By default, no none value is used. This means a `None` value will be\n     * represented by the absence of the item.\n     *\n     * When `'zeroes'` is provided, a `None` value will skip the bytes that would\n     * have been used for the item. Note that this returns a fixed-size codec\n     * and thus will only work if the item codec is of fixed size.\n     *\n     * When a custom byte array is provided, a `None` value will be represented\n     * by the provided byte array. Note that this returns a variable-size codec\n     * since the byte array representing `None` does not need to match the size\n     * of the item codec.\n     *\n     * @defaultValue No none value is used.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The codec to use for the boolean prefix, if any.\n     *\n     * By default a `u8` number is used as a prefix to determine if the value is `None`.\n     * The value `0` is encoded for `None` and `1` if the value is present.\n     * This can be set to any number codec to customize the prefix.\n     *\n     * When `null` is provided, no prefix is used and the `noneValue` is used to\n     * determine if the value is `None`. If no `noneValue` is provided, then the\n     * absence of any bytes is used to determine if the value is `None`.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Creates a encoder for an optional value using the `Option<T>` type.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getOptionEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<OptionOrNullable<TFrom>, TSize>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: None | null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: Some<TFrom> | TFrom): [boolean, TFrom] => [\n                true,\n                isOption(value) && isSome(value) ? value.value : value,\n            ]),\n        ],\n        variant => {\n            const option = isOption<TFrom>(variant) ? variant : wrapNullable(variant);\n            return Number(isSome(option));\n        },\n    );\n}\n\n/**\n * Creates a decoder for an optional value using the `Option<T>` type.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getOptionDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<Option<TTo>, TSize>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => none<TTo>()),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value)),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Creates a codec for an optional value using the `Option<T>` type.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>, TSize>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    type ConfigCast = OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getOptionEncoder<TFrom>(item, config as ConfigCast),\n        getOptionDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, SystemProgram, Transaction } from '@solana/web3.js';\nimport {\n    createInitializeGroupInstruction,\n    createUpdateGroupMaxSizeInstruction,\n    createUpdateGroupAuthorityInstruction,\n    createInitializeMemberInstruction,\n    TOKEN_GROUP_SIZE,\n    TOKEN_GROUP_MEMBER_SIZE,\n} from '@solana/spl-token-group';\n\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport { getSigners } from '../../actions/internal.js';\n\n/**\n * Initialize a new `Group`\n *\n * Assumes one has already initialized a mint for the group.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param mintAuthority    Group mint authority\n * @param updateAuthority  Group update authority\n * @param maxSize          Maximum number of members in the group\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupInitializeGroup(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    updateAuthority: PublicKey | null,\n    maxSize: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createInitializeGroupInstruction({\n            programId,\n            group: mint,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            updateAuthority,\n            maxSize,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Initialize a new `Group` with rent transfer.\n *\n * Assumes one has already initialized a mint for the group.\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param mintAuthority    Group mint authority\n * @param updateAuthority  Group update authority\n * @param maxSize          Maximum number of members in the group\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupInitializeGroupWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    updateAuthority: PublicKey | null,\n    maxSize: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const lamports = await connection.getMinimumBalanceForRentExemption(TOKEN_GROUP_SIZE);\n\n    const transaction = new Transaction().add(\n        SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: mint,\n            lamports,\n        }),\n        createInitializeGroupInstruction({\n            programId,\n            group: mint,\n            mint,\n            mintAuthority: mintAuthorityPublicKey,\n            updateAuthority,\n            maxSize,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Update the max size of a `Group`\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param updateAuthority  Group update authority\n * @param maxSize          Maximum number of members in the group\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupUpdateGroupMaxSize(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    maxSize: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateGroupMaxSizeInstruction({\n            programId,\n            group: mint,\n            updateAuthority: updateAuthorityPublicKey,\n            maxSize,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Update the authority of a `Group`\n *\n * @param connection       Connection to use\n * @param payer            Payer of the transaction fee\n * @param mint             Group mint\n * @param updateAuthority  Group update authority\n * @param newAuthority     New authority for the token group, or unset\n * @param multiSigners     Signing accounts if `authority` is a multisig\n * @param confirmOptions   Options for confirming the transaction\n * @param programId        SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupUpdateGroupAuthority(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    updateAuthority: PublicKey | Signer,\n    newAuthority: PublicKey | null,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [updateAuthorityPublicKey, signers] = getSigners(updateAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createUpdateGroupAuthorityInstruction({\n            programId,\n            group: mint,\n            currentAuthority: updateAuthorityPublicKey,\n            newAuthority,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Initialize a new `Member` of a `Group`\n *\n * Assumes the `Group` has already been initialized,\n * as well as the mint for the member.\n *\n * @param connection             Connection to use\n * @param payer                  Payer of the transaction fee\n * @param mint                   Member mint\n * @param mintAuthority          Member mint authority\n * @param group                  Group mint\n * @param groupUpdateAuthority   Group update authority\n * @param multiSigners           Signing accounts if `authority` is a multisig\n * @param confirmOptions         Options for confirming the transaction\n * @param programId              SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupMemberInitialize(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    group: PublicKey,\n    groupUpdateAuthority: PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createInitializeMemberInstruction({\n            programId,\n            member: mint,\n            memberMint: mint,\n            memberMintAuthority: mintAuthorityPublicKey,\n            group,\n            groupUpdateAuthority,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Initialize a new `Member` of a `Group` with rent transfer.\n *\n * Assumes the `Group` has already been initialized,\n * as well as the mint for the member.\n *\n * @param connection             Connection to use\n * @param payer                  Payer of the transaction fee\n * @param mint                   Member mint\n * @param mintAuthority          Member mint authority\n * @param group                  Group mint\n * @param groupUpdateAuthority   Group update authority\n * @param multiSigners           Signing accounts if `authority` is a multisig\n * @param confirmOptions         Options for confirming the transaction\n * @param programId              SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function tokenGroupMemberInitializeWithRentTransfer(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    mintAuthority: PublicKey | Signer,\n    group: PublicKey,\n    groupUpdateAuthority: PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [mintAuthorityPublicKey, signers] = getSigners(mintAuthority, multiSigners);\n\n    const lamports = await connection.getMinimumBalanceForRentExemption(TOKEN_GROUP_MEMBER_SIZE);\n\n    const transaction = new Transaction().add(\n        SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: mint,\n            lamports,\n        }),\n        createInitializeMemberInstruction({\n            programId,\n            member: mint,\n            memberMint: mint,\n            memberMintAuthority: mintAuthorityPublicKey,\n            group,\n            groupUpdateAuthority,\n        }),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { getSigners } from '../../actions/internal.js';\nimport { TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    createHarvestWithheldTokensToMintInstruction,\n    createSetTransferFeeInstruction,\n    createTransferCheckedWithFeeInstruction,\n    createWithdrawWithheldTokensFromAccountsInstruction,\n    createWithdrawWithheldTokensFromMintInstruction,\n} from './instructions.js';\n\n/**\n * Transfer tokens from one account to another, asserting the transfer fee, token mint, and decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param source         Source account\n * @param mint           Mint for the account\n * @param destination    Destination account\n * @param owner          Owner of the source account\n * @param amount         Number of tokens to transfer\n * @param decimals       Number of decimals in transfer amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function transferCheckedWithFee(\n    connection: Connection,\n    payer: Signer,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    owner: Signer | PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createTransferCheckedWithFeeInstruction(\n            source,\n            mint,\n            destination,\n            ownerPublicKey,\n            amount,\n            decimals,\n            fee,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Withdraw withheld tokens from mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param destination    The destination account\n * @param authority      The mint's withdraw withheld tokens authority\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function withdrawWithheldTokensFromMint(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createWithdrawWithheldTokensFromMintInstruction(mint, destination, authorityPublicKey, signers, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Withdraw withheld tokens from accounts\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param destination    The destination account\n * @param authority      The mint's withdraw withheld tokens authority\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param sources        Source accounts from which to withdraw withheld fees\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function withdrawWithheldTokensFromAccounts(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[],\n    sources: PublicKey[],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createWithdrawWithheldTokensFromAccountsInstruction(\n            mint,\n            destination,\n            authorityPublicKey,\n            signers,\n            sources,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n\n/**\n * Harvest withheld tokens from accounts to the mint\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           The token mint\n * @param sources        Source accounts from which to withdraw withheld fees\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function harvestWithheldTokensToMint(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    sources: PublicKey[],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const transaction = new Transaction().add(createHarvestWithheldTokensToMintInstruction(mint, sources, programId));\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n}\n\n/**\n * Update transfer fee and maximum fee\n *\n * @param connection                Connection to use\n * @param payer                     Payer of the transaction fees\n * @param mint                      The token mint\n * @param authority                 The authority of the transfer fee\n * @param multiSigners              Signing accounts if `owner` is a multisig\n * @param transferFeeBasisPoints    Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee                Maximum fee assessed on transfers\n * @param confirmOptions            Options for confirming the transaction\n * @param programId                 SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function setTransferFee(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    authority: Signer | PublicKey,\n    multiSigners: Signer[],\n    transferFeeBasisPoints: number,\n    maximumFee: bigint,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_2022_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createSetTransferFeeInstruction(\n            mint,\n            authorityPublicKey,\n            signers,\n            transferFeeBasisPoints,\n            maximumFee,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createApproveCheckedInstruction } from '../instructions/approveChecked.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Approve a delegate to transfer up to a maximum number of tokens from an account, asserting the token mint and\n * decimals\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Address of the mint\n * @param account        Address of the account\n * @param delegate       Account authorized to perform a transfer tokens from the source account\n * @param owner          Owner of the source account\n * @param amount         Maximum number of tokens the delegate may transfer\n * @param decimals       Number of decimals in approve amount\n * @param multiSigners   Signing accounts if `owner` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function approveChecked(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    account: PublicKey,\n    delegate: PublicKey,\n    owner: Signer | PublicKey,\n    amount: number | bigint,\n    decimals: number,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [ownerPublicKey, signers] = getSigners(owner, multiSigners);\n\n    const transaction = new Transaction().add(\n        createApproveCheckedInstruction(\n            account,\n            mint,\n            delegate,\n            ownerPublicKey,\n            amount,\n            decimals,\n            multiSigners,\n            programId,\n        ),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import type { ConfirmOptions, Connection, PublicKey, Signer, TransactionSignature } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { createMintToInstruction } from '../instructions/mintTo.js';\nimport { getSigners } from './internal.js';\n\n/**\n * Mint tokens to an account\n *\n * @param connection     Connection to use\n * @param payer          Payer of the transaction fees\n * @param mint           Mint for the account\n * @param destination    Address of the account to mint to\n * @param authority      Minting authority\n * @param amount         Amount to mint\n * @param multiSigners   Signing accounts if `authority` is a multisig\n * @param confirmOptions Options for confirming the transaction\n * @param programId      SPL Token program account\n *\n * @return Signature of the confirmed transaction\n */\nexport async function mintTo(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: Signer | PublicKey,\n    amount: number | bigint,\n    multiSigners: Signer[] = [],\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n): Promise<TransactionSignature> {\n    const [authorityPublicKey, signers] = getSigners(authority, multiSigners);\n\n    const transaction = new Transaction().add(\n        createMintToInstruction(mint, destination, authorityPublicKey, amount, multiSigners, programId),\n    );\n\n    return await sendAndConfirmTransaction(connection, transaction, [payer, ...signers], confirmOptions);\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Represents all the size options for array-like codecs\n * — i.e. `array`, `map` and `set`.\n *\n * It can be one of the following:\n * - a {@link NumberCodec} that prefixes its content with its size.\n * - a fixed number of items.\n * - or `'remainder'` to infer the number of items by dividing\n *   the rest of the byte array by the fixed size of its item.\n *   Note that this option is only available for fixed-size items.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/** Defines the configs for array codecs. */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Decodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an array of items.\n *\n * @param item - The codec to use for the array's items.\n * @param config - A set of config for the codec.\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** The total size of the encoded value in bytes. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value to a `Uint8Array`.\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a value from a `Uint8Array`.\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a `Uint8Array`.\n * It supports encoding looser types than it decodes for convenience.\n * For example, a `bigint` encoder will always decode to a `bigint`\n * but can be used to encode a `number`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value. Defaults to `TFrom`.\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Get the encoded size of a given value in bytes.\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/** Fills the missing `encode` function using the existing `write` function. */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/** Fills the missing `decode` function using the existing `read` function. */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/** Fills the missing `encode` and `decode` function using the existing `write` and `read` functions. */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\nexport function assertIsVariableSize<T>(encoder: Encoder<T>): asserts encoder is VariableSizeEncoder<T>;\nexport function assertIsVariableSize<T>(decoder: Decoder<T>): asserts decoder is VariableSizeDecoder<T>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an encoder and a decoder into a codec.\n * The encoder and decoder must have the same fixed size, max size and description.\n * If a description is provided, it will override the encoder and decoder descriptions.\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/** Encodes strings in base10. */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base10. */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base10. */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { isOption, isSome, None, Some } from './option';\n\n/**\n * Lists all types that should not be recursively unwrapped.\n *\n * @see {@link UnwrappedOption}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that defines the recursive unwrapping of a type `T`\n * such that all nested {@link Option} types are unwrapped.\n *\n * For each nested {@link Option} type, if the option is a {@link Some},\n * it returns the type of its value, otherwise, it returns the provided\n * fallback type `U` which defaults to `null`.\n */\nexport type UnwrappedOption<T, U = null> =\n    T extends Some<infer TValue>\n        ? UnwrappedOption<TValue, U>\n        : T extends None\n          ? U\n          : T extends UnUnwrappables\n            ? T\n            : T extends object\n              ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n              : T extends Array<infer TItem>\n                ? Array<UnwrappedOption<TItem, U>>\n                : T;\n\n/**\n * Recursively go through a type `T` such that all\n * nested {@link Option} types are unwrapped.\n *\n * For each nested {@link Option} type, if the option is a {@link Some},\n * it returns its value, otherwise, it returns the provided fallback value\n * which defaults to `null`.\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/** Defines the config for bitArray codecs. */\nexport type BitArrayCodecConfig = {\n    /**\n     * Whether to read the bits in reverse order.\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Encodes an array of booleans into bits.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the encoder.\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Decodes bits into an array of booleans.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the decoder.\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * An array of boolean codec that converts booleans to bits and vice versa.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the codec.\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * Note that, if the sentinel is found in the encoded value, an error is thrown.\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until a `Uint8Array` sentinel is found.\n *\n * If the sentinel is not found in the byte array to decode, an error is thrown.\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * Note that, if the sentinel is found in the encoded value\n * or not found in the byte array to decode, an error is thrown.\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** Encodes strings in base58. */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base58. */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base58. */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Decodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * A string serializer that reslices bytes into custom chunks\n * of bits that are then mapped to a custom alphabet.\n *\n * This can be used to create serializers whose alphabet\n * is a power of 2 such as base16 or base64.\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/** Defines the config for boolean codecs. */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec to delegate to.\n     * @defaultValue u8 size.\n     */\n    size?: TSize;\n};\n\n/**\n * Encodes booleans.\n *\n * @param config - A set of config for the encoder.\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Decodes booleans.\n *\n * @param config - A set of config for the decoder.\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Creates a boolean codec.\n *\n * @param config - A set of config for the codec.\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Encodes byte arrays as provided.\n *\n * To control the size of the encoded byte array, you can use\n * the `fixEncoderSize` or `addEncoderSizePrefix` functions.\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Decodes byte arrays as-is.\n *\n * To control the size of the decoded byte array, you can use\n * the `fixDecoderSize` or `addDecoderSizePrefix` functions.\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Creates a sized bytes codec.\n *\n * To control the size of the encoded and decoded byte arrays,\n * you can use the `fixCodecSize` or `addCodecSizePrefix` functions.\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Encodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Decodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Encodes and decodes short u16 numbers.\n *\n * Short u16 numbers are the same as u16, but serialized with 1 to 3 bytes.\n * If the value is above 0x7f, the top bit is set and the remaining\n * value is stored in the next bytes. Each byte follows the same\n * pattern until the 3rd byte. The 3rd byte, if needed, uses\n * all 8 bits to store the last byte of the original value.\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty.\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode.\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/** Encodes strings in base64. */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/** Decodes strings in base64. */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/** Encodes and decodes strings in base64. */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Creates a void encoder that always sets the provided byte array when encoding.\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Creates a void decoder that reads the next bytes and fails if they do not match the provided constant.\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Creates a void codec that always sets the provided byte array\n * when encoding and, when decoding, asserts that the next\n * bytes match the provided byte array.\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the `decoder` by reading the `prefix` encoder prefix.\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Bounds the size of the `codec` using the provided `prefix` codec prefix.\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","/**Removes null characters from a string. */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/** Pads a string with null characters at the end. */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a tuple-like array.\n *\n * @param items - The encoders to use for each item in the tuple.\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a tuple-like array.\n *\n * @param items - The decoders to use for each item in the tuple.\n */\n\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a tuple-like array.\n *\n * @param items - The codecs to use for each item in the tuple.\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/** Encodes UTF-8 strings using the native `TextEncoder` API. */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/** Decodes UTF-8 strings using the native `TextDecoder` API. */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/** Encodes and decodes UTF-8 strings using the native `TextEncoder` and `TextDecoder` API. */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","import {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SolanaErrorCode,\n} from './codes';\nimport { RpcSimulateTransactionResult } from './json-rpc-error';\n\ntype BasicInstructionErrorContext<T extends SolanaErrorCode> = Readonly<{ [P in T]: { index: number } }>;\n\ntype DefaultUnspecifiedErrorContextToUndefined<T> = {\n    [P in SolanaErrorCode]: P extends keyof T ? T[P] : undefined;\n};\n\ntype TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\ninterface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors/#adding-a-new-error\n *\n * WARNING:\n *   - Don't change or remove members of an error's context.\n */\nexport type SolanaErrorContext = DefaultUnspecifiedErrorContextToUndefined<\n    BasicInstructionErrorContext<\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    > & {\n        [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: {\n            putativeAddress: string;\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: {\n            actual: number;\n            maxSeeds: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: {\n            actual: number;\n            index: number;\n            maxSeedLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: {\n            bump: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: {\n            currentBlockHeight: bigint;\n            lastValidBlockHeight: bigint;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: {\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: {\n            stringValues: string[];\n        };\n        [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: {\n            encodedBytes: ReadonlyUint8Array;\n            hexEncodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: {\n            decoderFixedSize: number;\n            encoderFixedSize: number;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: {\n            decoderMaxSize: number | undefined;\n            encoderMaxSize: number | undefined;\n        };\n        [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            formattedValidDiscriminators: string;\n            validDiscriminators: number[];\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: {\n            codecDescription: string;\n            expectedSize: number;\n            hexZeroValue: string;\n            zeroValue: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n            expected: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: {\n            constant: ReadonlyUint8Array;\n            data: ReadonlyUint8Array;\n            hexConstant: string;\n            hexData: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: {\n            formattedNumericalValues: string;\n            numericalValues: number[];\n            stringValues: string[];\n            variant: number | string | symbol;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: {\n            actual: bigint | number;\n            codecDescription: string;\n            expected: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: {\n            alphabet: string;\n            base: number;\n            value: string;\n        };\n        [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            maxRange: number;\n            minRange: number;\n        };\n        [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: {\n            codecDescription: string;\n            max: bigint | number;\n            min: bigint | number;\n            value: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: {\n            bytesLength: number;\n            codecDescription: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: {\n            decodedBytes: ReadonlyUint8Array;\n            hexDecodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: {\n            maxRange: number;\n            minRange: number;\n            variant: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: {\n            encodedData: string;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: {\n            code: number;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            index: number;\n            instructionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: {\n            data?: Uint8Array;\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: {\n            accountAddresses?: string[];\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: {\n            actualProgramAddress: string;\n            expectedProgramAddress: string;\n        };\n        [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__INVALID_NONCE]: {\n            actualNonceValue: string;\n            expectedNonceValue: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: {\n            cacheKey: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: {\n            unexpectedValue: unknown;\n        };\n        [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: {\n            contextSlot: number;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: {\n            numSlotsBehind?: number;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: Omit<\n            RpcSimulateTransactionResult,\n            'err'\n        >;\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: {\n            byteLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: {\n            nonceAccountAddress: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST]: {\n            notificationName: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT]: {\n            errorEvent: Event;\n        };\n        [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: {\n            argumentLabel: string;\n            keyPath: readonly (number | string | symbol)[];\n            methodName: string;\n            optionalPathLabel: string;\n            path?: string;\n            value: bigint;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: {\n            message: string;\n            statusCode: number;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: {\n            headers: string[];\n        };\n        [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: {\n            key: CryptoKey;\n        };\n        [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: {\n            value: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            transactionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: {\n            expectedAddresses: string[];\n            unexpectedAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: {\n            lookupTableAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: {\n            highestKnownIndex: number;\n            highestRequestedIndex: number;\n            lookupTableAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: {\n            numRequiredSignatures: number;\n            signaturesLength: number;\n            signerAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: {\n            actualVersion: number;\n        };\n    }\n>;\n\nexport function decodeEncodedContext(encodedContext: string): object {\n    const decodedUrlString = __NODEJS__ ? Buffer.from(encodedContext, 'base64').toString('utf8') : atob(encodedContext);\n    return Object.fromEntries(new URLSearchParams(decodedUrlString).entries());\n}\n\nfunction encodeValue(value: unknown): string {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join('%2C%20' /* \", \" */);\n        return '%5B' /* \"[\" */ + commaSeparatedValues + /* \"]\" */ '%5D';\n    } else if (typeof value === 'bigint') {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(\n            String(\n                value != null && Object.getPrototypeOf(value) === null\n                    ? // Plain objects with no prototype don't have a `toString` method.\n                      // Convert them before stringifying them.\n                      { ...(value as object) }\n                    : value,\n            ),\n        );\n    }\n}\n\nfunction encodeObjectContextEntry([key, value]: [string, unknown]): `${typeof key}=${string}` {\n    return `${key}=${encodeValue(value)}`;\n}\n\nexport function encodeContextObject(context: object): string {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join('&');\n    return __NODEJS__ ? Buffer.from(searchParamsString, 'utf8').toString('base64') : btoa(searchParamsString);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Creates a union encoder from the provided array of encoder.\n *\n * @param variants - The variant encoders of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): Encoder<GetEncoderTypeFromVariants<TVariants>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    });\n}\n\n/**\n * Creates a union decoder from the provided array of decoder.\n *\n * @param variants - The variant decoders of the union.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Decoder<GetDecoderTypeFromVariants<TVariants>> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Creates a union codec from the provided array of codec.\n *\n * @param variants - The variant codecs of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Codec<\n    GetEncoderTypeFromVariants<TVariants>,\n    GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants, getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    );\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","import {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]:\n        'Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.',\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]:\n        'Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]:\n        'Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]:\n        'Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].',\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]:\n        'Invalid discriminated union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]:\n        'Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.',\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]:\n        'Invalid literal union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]:\n        'Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].',\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]:\n        'Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.',\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: 'No random values implementation could be found.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]:\n        'The provided private key does not match the provided public key.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST]:\n        \"Either the notification name must end in 'Notifications' or the API must supply a \" +\n        \"subscription creator function for the notification '$notificationName' to map between \" +\n        'the notification name and the subscribe/unsubscribe method names.',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`ITransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]:\n        'Wallet account signers do not support signing multiple messages/transactions in a single operation',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: 'Cannot export a non-extractable key.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall ' +\n        '@solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: 'Timestamp value must be in the range [-8.64e15, 8.64e15]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]:\n        'Attempted to sign a transaction with an address that is not a signer for it',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]:\n        'Transaction has no expected signers therefore it cannot be encoded',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Failed to estimate the compute unit consumption for this transaction message. This is ' +\n        'likely because simulating the transaction failed. Inspect the `cause` property of this ' +\n        'error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]:\n        'The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n};\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder.\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder.\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec.\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n */\n\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Codec, combineCodec, Decoder, Encoder, transformDecoder, transformEncoder } from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Defines a discriminated union using discriminated union types.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariant<WebPageEvent, '__kind', 'click'>;\n * // -> { __kind: 'click', x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariantContent<WebPageEvent, '__kind', 'click'>;\n * // -> { x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/** Defines the config for discriminated union codecs. */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`.\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec to use for the enum discriminator prefixing the variant.\n     * @defaultValue u8 prefix.\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\n/**\n * Creates a discriminated union encoder.\n *\n * @param variants - The variant encoders of the discriminated union.\n * @param config - A set of config for the encoder.\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    );\n}\n\n/**\n * Creates a discriminated union decoder.\n *\n * @param variants - The variant decoders of the discriminated union.\n * @param config - A set of config for the decoder.\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    );\n}\n\n/**\n * Creates a discriminated union codec.\n *\n * @param variants - The variant codecs of the discriminated union.\n * @param config - A set of config for the codec.\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): Codec<\n    GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n    GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n        GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config),\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    );\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n\n/** @deprecated Use `getDiscriminatedUnionEncoder` instead. */\nexport const getDataEnumEncoder = getDiscriminatedUnionEncoder;\n\n/** @deprecated Use `getDiscriminatedUnionDecoder` instead. */\nexport const getDataEnumDecoder = getDiscriminatedUnionDecoder;\n\n/** @deprecated Use `getDiscriminatedUnionCodec` instead. */\nexport const getDataEnumCodec = getDiscriminatedUnionCodec;\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder.\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder.\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder.\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder.\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec.\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec.\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [\n        ...new Set(Object.values(constructor).filter(v => typeof v === 'number') as number[]),\n    ].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/** Defines the config for enum codecs. */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec to use for the enum discriminator.\n     * @defaultValue u8 discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * When set to `true`, numeric values will be used as discriminantors and\n     * an error will be thrown if a string value is found on the enum.\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Creates an enum encoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the encoder.\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Creates an enum decoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the decoder.\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Creates an enum codec.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the codec.\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n\n/** @deprecated Use `getEnumEncoder` instead. */\nexport const getScalarEnumEncoder = getEnumEncoder;\n\n/** @deprecated Use `getEnumDecoder` instead. */\nexport const getScalarEnumDecoder = getEnumDecoder;\n\n/** @deprecated Use `getEnumCodec` instead. */\nexport const getScalarEnumCodec = getEnumCodec;\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Converts an encoder A to a encoder B by mapping their values.\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Converts an decoder A to a decoder B by mapping their values.\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Converts a codec A to a codec B by mapping their values.\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Prefixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Prefixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Prefixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import { SolanaErrorCode } from './codes';\nimport { encodeContextObject } from './context';\nimport { SolanaErrorMessages } from './messages';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n            fragments.push(\n                variableName in context ? `${context[variableName as keyof typeof context]}` : `$${variableName}`,\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(code: TErrorCode, context: object = {}): string {\n    if (process.env.NODE_ENV !== \"production\") {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Suffixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Suffixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Suffixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/** Defines the config for Map codecs. */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Creates a encoder for a map.\n *\n * @param key - The encoder to use for the map's keys.\n * @param value - The encoder to use for the map's values.\n * @param config - A set of config for the encoder.\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Creates a decoder for a map.\n *\n * @param key - The decoder to use for the map's keys.\n * @param value - The decoder to use for the map's values.\n * @param config - A set of config for the decoder.\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Creates a codec for a map.\n *\n * @param key - The codec to use for the map's keys.\n * @param value - The codec to use for the map's values.\n * @param config - A set of config for the codec.\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Creates a void encoder.\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Creates a void decoder.\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Creates a void codec.\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/** Defines the config for nullable codecs. */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Defines how the `None` (or `null`) value should be represented.\n     *\n     * By default, no none value is used. This means a `null` value will be\n     * represented by the absence of the item.\n     *\n     * When `'zeroes'` is provided, a `null` value will skip the bytes that would\n     * have been used for the item. Note that this returns a fixed-size codec\n     * and thus will only work if the item codec is of fixed size.\n     *\n     * When a custom byte array is provided, a `null` value will be represented\n     * by the provided byte array. Note that this returns a variable-size codec\n     * since the byte array representing `null` does not need to match the size\n     * of the item codec.\n     *\n     * @defaultValue No none value is used.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The codec to use for the boolean prefix, if any.\n     *\n     * By default a `u8` number is used as a prefix to determine if the value is `null`.\n     * The value `0` is encoded for `null` and `1` if the value is present.\n     * This can be set to any number codec to customize the prefix.\n     *\n     * When `null` is provided, no prefix is used and the `noneValue` is used to\n     * determine if the value is `null`. If no `noneValue` is provided, then the\n     * absence of any bytes is used to determine if the value is `null`.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Creates a encoder for an optional value using `null` as the `None` value.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Creates a decoder for an optional value using `null` as the `None` value.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Creates a codec for an optional value using `null` as the `None` value.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import { SolanaErrorCode, SolanaErrorCodeWithCause } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = Readonly<{\n    [P in SolanaErrorCode]: (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]) & {\n        __code: P;\n    };\n}>;\n\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    readonly cause?: TErrorCode extends SolanaErrorCodeWithCause ? SolanaError : unknown = this.cause;\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            // If the `ErrorOptions` type ever changes, update this code.\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = { cause };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest as SolanaErrorContext[TErrorCode];\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = {\n            __code: code,\n            ...context,\n        } as SolanaErrorCodedContext[TErrorCode];\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n","export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/** Defines the config for set codecs. */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the set.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Decodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Creates a codec for an set of items.\n *\n * @param item - The codec to use for the set's items.\n * @param config - A set of config for the codec.\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype Fields<T> = readonly (readonly [string, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a custom object.\n *\n * @param fields - The name and encoder of each field.\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a custom object.\n *\n * @param fields - The name and decoder of each field.\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a custom object.\n *\n * @param fields - The name and codec of each field.\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    index: number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: rpcErrorContext as number,\n                        index,\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                    return {\n                        encodedData: rpcErrorContext as string,\n                        index,\n                    };\n                }\n                return { index };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n","import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: rpcErrorContext as number,\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: (rpcErrorContext as { account_index: number }).account_index,\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n","import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/response.rs\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: number;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: number;\n              owner: string;\n              rentEpoch: number;\n              space?: number;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    logs: string[] | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: number | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError({ code, data, message }: RpcErrorResponse): SolanaError {\n    let out: SolanaError;\n    if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n        const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n        const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n        out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n            ...preflightErrorContext,\n            ...causeObject,\n        });\n    } else {\n        let errorContext;\n        switch (code) {\n            case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n            case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n            case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n            case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n            case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n            case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                // The server supplies no structured data, but rather a pre-formatted message. Put\n                // the server message in `context` so as not to completely lose the data. The long\n                // term fix for this is to add data to the server responses and modify the\n                // messages in `@solana/errors` to be actual format strings.\n                errorContext = { __serverMessage: message };\n                break;\n            default:\n                if (typeof data === 'object' && !Array.isArray(data)) {\n                    errorContext = data;\n                }\n        }\n        out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n"],"names":["alphabet","Endian","newOffset","combineCodec","createEncoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","createDecoder","getEncodedSize","isFixedSize","transformEncoder","getU8Decoder","transformDecoder","getU8Encoder","isSolanaError","containsBytes","ORDERED_ERROR_NAMES"],"mappings":"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RjE,CJOb,CAAA,YINc,IAAgB,IAAA,EAAA,CAAgB,CAAG,EFsCb,IAAA,CEtCoB,GAE9D,YADM,CAAA,EAAgB,GACf,CFqCwB,AHsB7B,AGrBE,CF/BU,EAAA,MIPa,QAiBX,KAVpB,CJKH,ApEsRF,GwE3RK,SAUqDD,GAAa,EL4DpC,AhI2JE,EAAE,CqIhOtC,GAAqB,SACL,CAQwE,GANzE,CADD,CADU,AACD,IAAA,IAAA,EAAA,CAAoB,CAAe,EL6DZ,CAAG,GAAA,CK7DgB,CFoDT,CEpDe,KAAM,CAAA,MAAM,CAAC,CAAA,CAAA,EH3BtE,CAAA,UAAW,EAAE,CAAA,CG4BkB,CxEgSL,CAAA,EmE1QN,IKtBuB,CAAA,gD1ERgD,KElBf,CrEG9D,AqEH+D,ErEI3F,KsEKkG,CAAC,StDNhE,A/CAA,AIAA,AKAA,A4BAA,AoBAA,ADAA,AvDAA,AIAA,AEAA,ALAA,AIAA,AEAA,ALAA,E4CCnC,A5CAA,AGAA,ANAA,AQAA,ACAA,AJAA,AJAA,AoCAA,AnCAA,AsDAA,ACAA,AlDAA,AHAA,I2BAqB,EACrB,uBAAuB,AmE6CiB,CAA+B,E1C9CvC,AnDAA,ADAA,AHAA,ADAA,AyDAA,AnDAA,AJAA,A6BEnC,AvBFmC,A6BAA,A5BAA,AsCAA,AxCAA,AJAA,EHChC,CwDAH,AjDAA,AJAA,AGAA,A+BAA,AoBAA,AjDAA,AHAA,ADAA,AFAA,A6CAA,AtCAA,ARAA,G8BCM,G1BDA,AmDAA,ACAA,AvDAA,A6CAA,AzCAA,AGAA,ARAA,AEAA,ACAA,AIAA,ADAA,A8BAA,WNCc,CAAC,EvBDD,AJAA,AKAA,AHAA,AJAA,AsDAA,ArDAA,AEAA,A0CAA,AVAA,A9BAA,ANAA,AwDAA,CnDAC,A+BAA,A9BAA,AJAA,AsDAA,ArDAA,AFAA,AOAA,A+CAA,AvDAA,AIAA,A0CAA,AvCAA,URAc,GACnC,MAAM,AkG6C0B,CAAA,CAAA,KAAA,CAAA,CAAA,QlG7CT,CAAC,KkG6CQ,CAAA,CAAA,KAAA,CAAA,CAAA,OAAA,CAAkD,KAAE,CAAA,CAAK,CsB/BC,AAAC,C3BDA,A2BCA,+ItBqC7D,WAAA,CAAA,0FAON,WAAc,4BA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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209]}